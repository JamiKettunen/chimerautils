diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/bc/bc/bc.y src.freebsd/bc/bc/bc.y
--- src.orig/bc/bc/bc.y	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/bc/bc/bc.y	2023-01-13 18:21:52.649566649 +0100
@@ -1094,7 +1094,7 @@
 
 /* ARGSUSED */
 static void
-sigchld(int signo __unused)
+sigchld(int signo __attribute__((unused)))
 {
 	pid_t pid;
 	int status, save_errno = errno;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/bc/bc/scan.l src.freebsd/bc/bc/scan.l
--- src.orig/bc/bc/scan.l	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/bc/bc/scan.l	2023-01-13 18:21:52.649566649 +0100
@@ -31,6 +31,7 @@
 #include "extern.h"
 #include "bc.h"
 #include "pathnames.h"
+#include "compat.h"
 
 int		lineno;
 bool		interactive;
@@ -242,7 +243,7 @@
 
 /* ARGSUSED */
 void
-abort_line(int sig __unused)
+abort_line(int sig __attribute__((unused)))
 {
 	static const char str1[] = "[\n]P\n";
 	static const char str2[] = "[^C\n]P\n";
@@ -265,7 +266,7 @@
  * line after a ^C.
  */
 unsigned char
-bc_eof(EditLine *e, int ch __unused)
+bc_eof(EditLine *e, int ch __attribute__((unused)))
 {
 	const struct lineinfo *info = el_line(e);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/bc/dc/bcode.c src.freebsd/bc/dc/bcode.c
--- src.orig/bc/dc/bcode.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/bc/dc/bcode.c	2023-01-13 18:21:52.649566649 +0100
@@ -72,7 +72,7 @@
 static void		 pop_print(void);
 static void		 pop_printn(void);
 static __inline void	 print_stack(void);
-static __inline void	 dup(void);
+static __inline void	 dcdup(void);
 static void		 swap(void);
 static void		 drop(void);
 
@@ -197,7 +197,7 @@
 	{ '_',	parse_number	},
 	{ 'a',	to_ascii	},
 	{ 'c',	clear_stack	},
-	{ 'd',	dup		},
+	{ 'd',	dcdup		},
 	{ 'e',	print_err	},
 	{ 'f',	print_stack	},
 	{ 'i',	set_ibase	},
@@ -378,7 +378,7 @@
 	bn_checkp(BN_copy(i, n->number));
 
 	if (n->scale == 0 && f != NULL)
-		bn_check(BN_zero(f));
+		BN_zero(f);
 	else if (n->scale < sizeof(factors)/sizeof(factors[0])) {
 		rem = BN_div_word(i, factors[n->scale]);
 		if (f != NULL)
@@ -551,7 +551,7 @@
 }
 
 static __inline void
-dup(void)
+dcdup(void)
 {
 
 	stack_dup(&bmachine.stack);
@@ -811,7 +811,7 @@
 		v = stack_tos(&bmachine.reg[idx]);
 		if (v == NULL) {
 			n = new_number();
-			bn_check(BN_zero(n->number));
+			BN_zero(n->number);
 			push_number(n);
 		} else
 			push(stack_dup_value(v, &copy));
@@ -896,7 +896,7 @@
 			v = frame_retrieve(stack, idx);
 			if (v == NULL || v->type == BCODE_NONE) {
 				n = new_number();
-				bn_check(BN_zero(n->number));
+				BN_zero(n->number);
 				push_number(n);
 			}
 			else
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/bc/dc/dc.c src.freebsd/bc/dc/dc.c
--- src.orig/bc/dc/dc.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/bc/dc/dc.c	2023-01-13 18:21:52.649566649 +0100
@@ -22,7 +22,6 @@
 
 #include <sys/stat.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -135,19 +134,12 @@
 		if (fd < 0)
 			err(1, "cannot open file %s", argv[0]);
 
-		if (caph_limit_stream(fd, CAPH_READ) < 0 ||
-		    caph_limit_stdio() < 0 ||
-		    caph_enter() < 0)
-			err(1, "capsicum");
-
 		procfd(fd, argv[0]);
 		preproc_done = true;
 	}
 	if (preproc_done)
 		return (0);
 
-	if (caph_limit_stdio() < 0 || caph_enter())
-		err(1, "capsicum");
 	src_setstream(&src, stdin);
 	reset_bmachine(&src);
 	eval();
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/bc/dc/inout.c src.freebsd/bc/dc/inout.c
--- src.orig/bc/dc/inout.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/bc/dc/inout.c	2023-01-13 18:21:52.649566649 +0100
@@ -25,6 +25,7 @@
 #include <string.h>
 
 #include "extern.h"
+#include "compat.h"
 
 #define MAX_CHARS_PER_LINE 68
 
@@ -192,7 +193,7 @@
 	bool dot = false, sign = false;
 
 	n = new_number();
-	bn_check(BN_zero(n->number));
+	BN_zero(n->number);
 
 	while ((ch = (*src->vtable->readchar)(src)) != EOF) {
 
@@ -230,8 +231,8 @@
 		base_n = BN_new();
 		exponent = BN_new();
 		divisor = new_number();
-		bn_check(BN_zero(base_n));
-		bn_check(BN_zero(exponent));
+		BN_zero(base_n);
+		BN_zero(exponent);
 
 		bn_check(BN_add_word(base_n, base));
 		bn_check(BN_add_word(exponent, iscale));
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/compat/expand_number.c src.freebsd/compat/expand_number.c
--- src.orig/compat/expand_number.c	2022-05-12 06:53:59.000000000 +0200
+++ src.freebsd/compat/expand_number.c	2023-01-13 18:21:52.649566649 +0100
@@ -34,7 +34,6 @@
 #include <ctype.h>
 #include <errno.h>
 #include <inttypes.h>
-#include <libutil.h>
 #include <stdint.h>
 
 int
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/compat/humanize_number.c src.freebsd/compat/humanize_number.c
--- src.orig/compat/humanize_number.c	2022-05-12 06:53:59.000000000 +0200
+++ src.freebsd/compat/humanize_number.c	2023-01-13 18:21:52.653564257 +0100
@@ -43,7 +43,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <locale.h>
-#include <libutil.h>
+
+#include "compat.h"
 
 static const int maxscale = 6;
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/compat/merge.c src.freebsd/compat/merge.c
--- src.orig/compat/merge.c	2022-05-12 06:53:59.000000000 +0200
+++ src.freebsd/compat/merge.c	2023-01-13 18:21:52.653564257 +0100
@@ -38,6 +38,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#define __is_aligned(x, align) (((uintptr_t)x & ((align) - 1)) == 0)
+
 /*
  * Hybrid exponential search/linear search merge sort with hybrid
  * natural/pairwise first pass.  Requires about .3% more comparisons
@@ -52,11 +54,15 @@
  * (The default is pairwise merging.)
  */
 
+#include <sys/types.h>
 #include <sys/param.h>
 
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdint.h>
+
+#include "compat.h"
 
 #ifdef I_AM_MERGESORT_B
 #include "block_abi.h"
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/compat/setmode.c src.freebsd/compat/setmode.c
--- src.orig/compat/setmode.c	2022-05-12 06:53:59.000000000 +0200
+++ src.freebsd/compat/setmode.c	2023-01-13 18:21:52.653564257 +0100
@@ -36,10 +36,8 @@
 __SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
 __FBSDID("$FreeBSD$");
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <ctype.h>
 #include <errno.h>
@@ -52,8 +50,6 @@
 #ifdef SETMODE_DEBUG
 #include <stdio.h>
 #endif
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
 #define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
@@ -208,12 +204,12 @@
 		}
 		if (errno == ERANGE && (perml == LONG_MAX || perml == LONG_MIN))
 			goto out;
-		if (perml & ~(STANDARD_BITS|S_ISTXT)) {
+		if (perml & ~(STANDARD_BITS|S_ISVTX)) {
 			errno = EINVAL;
 			goto out;
 		}
 		perm = (mode_t)perml;
-		ADDCMD('=', (STANDARD_BITS|S_ISTXT), perm, mask);
+		ADDCMD('=', (STANDARD_BITS|S_ISVTX), perm, mask);
 		set->cmd = 0;
 		return (saveset);
 	}
@@ -251,7 +247,7 @@
 		if (op == '=')
 			equalopdone = 0;
 
-		who &= ~S_ISTXT;
+		who &= ~S_ISVTX;
 		for (perm = 0, permXbits = 0;; ++p) {
 			switch (*p) {
 			case 'r':
@@ -265,8 +261,8 @@
 			case 't':
 				/* If only "other" bits ignore sticky. */
 				if (!who || who & ~S_IRWXO) {
-					who |= S_ISTXT;
-					perm |= S_ISTXT;
+					who |= S_ISVTX;
+					perm |= S_ISVTX;
 				}
 				break;
 			case 'w':
@@ -346,9 +342,7 @@
 get_current_umask(void)
 {
 	sigset_t sigset, sigoset;
-	size_t len;
 	mode_t mask;
-	u_short smask;
 
 #ifdef KERN_PROC_UMASK
 	/*
@@ -366,9 +360,9 @@
 	 * handler, protect them as best we can.
 	 */
 	sigfillset(&sigset);
-	(void)__libc_sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
 	(void)umask(mask = umask(0));
-	(void)__libc_sigprocmask(SIG_SETMASK, &sigoset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
 	return (mask);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/compat/vis.c src.freebsd/compat/vis.c
--- src.orig/compat/vis.c	2022-05-12 06:53:56.000000000 +0200
+++ src.freebsd/compat/vis.c	2023-01-13 18:21:52.653564257 +0100
@@ -64,7 +64,6 @@
 #define	_DIAGASSERT(x)	assert(x)
 #endif
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/param.h>
 
@@ -74,6 +73,7 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <limits.h>
 
 #ifdef __weak_alias
 __weak_alias(strvisx,_strvisx)
@@ -81,7 +81,6 @@
 
 #if !HAVE_VIS || !HAVE_SVIS
 #include <ctype.h>
-#include <limits.h>
 #include <stdio.h>
 #include <string.h>
 
@@ -133,30 +132,6 @@
 static const wchar_t char_shell[] = L"'`\";&<>()|{}]\\$!^~";
 static const wchar_t char_glob[] = L"*?[#";
 
-#if !HAVE_NBTOOL_CONFIG_H
-#ifndef __NetBSD__
-/*
- * On NetBSD MB_LEN_MAX is currently 32 which does not fit on any integer
- * integral type and it is probably wrong, since currently the maximum
- * number of bytes and character needs is 6. Until this is fixed, the
- * loops below are using sizeof(uint64_t) - 1 instead of MB_LEN_MAX, and
- * the assertion is commented out.
- */
-#ifdef __FreeBSD__
-/*
- * On FreeBSD including <sys/systm.h> for CTASSERT only works in kernel
- * mode.
- */
-#ifndef CTASSERT
-#define CTASSERT(x)             _CTASSERT(x, __LINE__)
-#define _CTASSERT(x, y)         __CTASSERT(x, y)
-#define __CTASSERT(x, y)        typedef char __assert ## y[(x) ? 1 : -1]
-#endif
-#endif /* __FreeBSD__ */
-CTASSERT(MB_LEN_MAX <= sizeof(uint64_t));
-#endif /* !__NetBSD__ */
-#endif
-
 /*
  * This is do_hvis, for HTTP style (RFC 1808)
  */
@@ -305,7 +280,7 @@
 do_svis(wchar_t *dst, wint_t c, int flags, wint_t nextc, const wchar_t *extra)
 {
 	int iswextra, i, shft;
-	uint64_t bmsk, wmsk;
+	u_int64_t bmsk, wmsk;
 
 	iswextra = wcschr(extra, c) != NULL;
 	if (!iswextra && (ISGRAPH(flags, c) || iswwhite(c) ||
@@ -318,11 +293,11 @@
 	wmsk = 0;
 	for (i = sizeof(wmsk) - 1; i >= 0; i--) {
 		shft = i * NBBY;
-		bmsk = (uint64_t)0xffLL << shft;
+		bmsk = (u_int64_t)0xffLL << shft;
 		wmsk |= bmsk;
 		if ((c & wmsk) || i == 0)
 			dst = do_mbyte(dst, (wint_t)(
-			    (uint64_t)(c & bmsk) >> shft),
+			    (u_int64_t)(c & bmsk) >> shft),
 			    flags, nextc, iswextra);
 	}
 
@@ -397,7 +372,7 @@
 {
 	wchar_t *dst, *src, *pdst, *psrc, *start, *extra;
 	size_t len, olen;
-	uint64_t bmsk, wmsk;
+	u_int64_t bmsk, wmsk;
 	wint_t c;
 	visfun_t f;
 	int clen = 0, cerr, error = -1, i, shft;
@@ -555,11 +530,11 @@
 			wmsk = 0;
 			for (i = sizeof(wmsk) - 1; i >= 0; i--) {
 				shft = i * NBBY;
-				bmsk = (uint64_t)0xffLL << shft;
+				bmsk = (u_int64_t)0xffLL << shft;
 				wmsk |= bmsk;
 				if ((*dst & wmsk) || i == 0)
 					mbdst[clen++] = (char)(
-					    (uint64_t)(*dst & bmsk) >>
+					    (u_int64_t)(*dst & bmsk) >>
 					    shft);
 			}
 			cerr = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/basename/basename.c src.freebsd/coreutils/basename/basename.c
--- src.orig/coreutils/basename/basename.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/basename/basename.c	2023-01-13 18:21:52.653564257 +0100
@@ -44,7 +44,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <libgen.h>
 #include <limits.h>
@@ -67,9 +66,6 @@
 
 	setlocale(LC_ALL, "");
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	aflag = 0;
 	suffix = NULL;
 	suffixlen = 0;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/cat/cat.c src.freebsd/coreutils/cat/cat.c
--- src.orig/coreutils/cat/cat.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/cat/cat.c	2023-01-13 18:21:52.653564257 +0100
@@ -48,7 +48,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 #ifndef NO_UDOM_SUPPORT
@@ -57,7 +56,6 @@
 #include <netdb.h>
 #endif
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -70,14 +68,11 @@
 #include <wchar.h>
 #include <wctype.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-#include <casper/cap_net.h>
+#include "compat.h"
 
 static int bflag, eflag, lflag, nflag, sflag, tflag, vflag;
 static int rval;
 static const char *filename;
-static fileargs_t *fa;
 
 static void usage(void) __dead2;
 static void scanfiles(char *argv[], int cooked);
@@ -145,29 +140,6 @@
 }
 #endif
 
-static void
-init_casper(int argc, char *argv[])
-{
-	cap_channel_t *casper;
-	cap_rights_t rights;
-
-	casper = cap_init();
-	if (casper == NULL)
-		err(EXIT_FAILURE, "unable to create Casper");
-
-	fa = fileargs_cinit(casper, argc, argv, O_RDONLY, 0,
-	    cap_rights_init(&rights, CAP_READ | CAP_FSTAT | CAP_FCNTL),
-	    FA_OPEN | FA_REALPATH);
-	if (fa == NULL)
-		err(EXIT_FAILURE, "unable to create fileargs");
-
-#ifndef NO_UDOM_SUPPORT
-	init_casper_net(casper);
-#endif
-
-	cap_close(casper);
-}
-
 int
 main(int argc, char *argv[])
 {
@@ -217,13 +189,6 @@
 			err(EXIT_FAILURE, "stdout");
 	}
 
-	init_casper(argc, argv);
-
-	caph_cache_catpages();
-
-	if (caph_enter_casper() < 0)
-		err(EXIT_FAILURE, "capsicum");
-
 	if (bflag || eflag || nflag || sflag || tflag || vflag)
 		scanfiles(argv, 1);
 	else
@@ -244,7 +209,7 @@
 }
 
 static void
-scanfiles(char *argv[], int cooked __unused)
+scanfiles(char *argv[], int cooked __attribute__((unused)))
 {
 	int fd, i;
 	char *path;
@@ -260,7 +225,7 @@
 			fd = STDIN_FILENO;
 		} else {
 			filename = path;
-			fd = fileargs_open(fa, path);
+			fd = open(path, O_RDONLY);
 #ifndef NO_UDOM_SUPPORT
 			if (fd < 0 && errno == EOPNOTSUPP)
 				fd = udom_open(path, O_RDONLY);
@@ -343,7 +308,6 @@
 				if (ferror(fp) && errno == EILSEQ) {
 					clearerr(fp);
 					/* Resync attempt. */
-					memset(&fp->_mbstate, 0, sizeof(mbstate_t));
 					if ((ch = getc(fp)) == EOF)
 						break;
 					wch = ch;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chmod/chmod.1 src.freebsd/coreutils/chmod/chmod.1
--- src.orig/coreutils/chmod/chmod.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/chmod/chmod.1	2023-01-13 18:21:52.653564257 +0100
@@ -40,7 +40,7 @@
 .Nd change file modes
 .Sh SYNOPSIS
 .Nm
-.Op Fl fhv
+.Op Fl fv
 .Op Fl R Op Fl H | L | P
 .Ar mode
 .Ar
@@ -66,9 +66,6 @@
 option is specified, symbolic links on the command line are followed
 and hence unaffected by the command.
 (Symbolic links encountered during tree traversal are not followed.)
-.It Fl h
-If the file is a symbolic link, change the mode of the link itself
-rather than the file that the link points to.
 .It Fl L
 If the
 .Fl R
@@ -109,7 +106,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chmod/chmod.c src.freebsd/coreutils/chmod/chmod.c
--- src.orig/coreutils/chmod/chmod.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/chmod/chmod.c	2023-01-13 18:21:52.653564257 +0100
@@ -41,7 +41,6 @@
 #endif /* not lint */
 #endif
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
 #include <sys/stat.h>
@@ -57,13 +56,14 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 static volatile sig_atomic_t siginfo;
 
 static void usage(void);
-static int may_have_nfs4acl(const FTSENT *ent, int hflag);
 
 static void
-siginfo_handler(int sig __unused)
+siginfo_handler(int sig __attribute__((unused)))
 {
 
 	siginfo = 1;
@@ -75,14 +75,14 @@
 	FTS *ftsp;
 	FTSENT *p;
 	mode_t *set;
-	int Hflag, Lflag, Rflag, ch, fflag, fts_options, hflag, rval;
+	int Hflag, Lflag, Rflag, ch, fflag, fts_options, rval;
 	int vflag;
 	char *mode;
 	mode_t newmode;
 
 	set = NULL;
-	Hflag = Lflag = Rflag = fflag = hflag = vflag = 0;
-	while ((ch = getopt(argc, argv, "HLPRXfghorstuvwx")) != -1)
+	Hflag = Lflag = Rflag = fflag = vflag = 0;
+	while ((ch = getopt(argc, argv, "HLPRXfgorstuvwx")) != -1)
 		switch (ch) {
 		case 'H':
 			Hflag = 1;
@@ -101,16 +101,6 @@
 		case 'f':
 			fflag = 1;
 			break;
-		case 'h':
-			/*
-			 * In System V the -h option causes chmod to change
-			 * the mode of the symbolic link. 4.4BSD's symbolic
-			 * links didn't have modes, so it was an undocumented
-			 * noop.  In FreeBSD 3.0, lchmod(2) is introduced and
-			 * this option does real work.
-			 */
-			hflag = 1;
-			break;
 		/*
 		 * XXX
 		 * "-[rwx]" are valid mode commands.  If they are the entire
@@ -140,9 +130,6 @@
 	(void)signal(SIGINFO, siginfo_handler);
 
 	if (Rflag) {
-		if (hflag)
-			errx(1, "the -R and -h options may not be "
-			    "specified together.");
 		if (Lflag) {
 			fts_options = FTS_LOGICAL;
 		} else {
@@ -152,8 +139,6 @@
 				fts_options |= FTS_COMFOLLOW;
 			}
 		}
-	} else if (hflag) {
-		fts_options = FTS_PHYSICAL;
 	} else {
 		fts_options = FTS_LOGICAL;
 	}
@@ -194,14 +179,6 @@
 			break;
 		}
 		newmode = getmode(set, p->fts_statp->st_mode);
-		/*
-		 * With NFSv4 ACLs, it is possible that applying a mode
-		 * identical to the one computed from an ACL will change
-		 * that ACL.
-		 */
-		if (may_have_nfs4acl(p, hflag) == 0 &&
-		    (newmode & ALLPERMS) == (p->fts_statp->st_mode & ALLPERMS))
-				continue;
 		if (fchmodat(AT_FDCWD, p->fts_accpath, newmode, atflag) == -1
 		    && !fflag) {
 			warn("%s", p->fts_path);
@@ -236,27 +213,3 @@
 	    "usage: chmod [-fhv] [-R [-H | -L | -P]] mode file ...\n");
 	exit(1);
 }
-
-static int
-may_have_nfs4acl(const FTSENT *ent, int hflag)
-{
-	int ret;
-	static dev_t previous_dev = NODEV;
-	static int supports_acls = -1;
-
-	if (previous_dev != ent->fts_statp->st_dev) {
-		previous_dev = ent->fts_statp->st_dev;
-		supports_acls = 0;
-
-		if (hflag)
-			ret = lpathconf(ent->fts_accpath, _PC_ACL_NFS4);
-		else
-			ret = pathconf(ent->fts_accpath, _PC_ACL_NFS4);
-		if (ret > 0)
-			supports_acls = 1;
-		else if (ret < 0 && errno != EINVAL)
-			warn("%s", ent->fts_path);
-	}
-
-	return (supports_acls);
-}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chown/chgrp.1 src.freebsd/coreutils/chown/chgrp.1
--- src.orig/coreutils/chown/chgrp.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/chown/chgrp.1	2023-01-13 18:21:52.657561866 +0100
@@ -124,7 +124,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chown/chown.8 src.freebsd/coreutils/chown/chown.8
--- src.orig/coreutils/chown/chown.8	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/chown/chown.8	2023-01-13 18:21:52.657561866 +0100
@@ -139,7 +139,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chown/chown.c src.freebsd/coreutils/chown/chown.c
--- src.orig/coreutils/chown/chown.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/chown/chown.c	2023-01-13 18:21:52.657561866 +0100
@@ -62,6 +62,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 static void	a_gid(const char *);
 static void	a_uid(const char *);
 static void	chownerr(const char *);
@@ -76,7 +78,7 @@
 static volatile sig_atomic_t siginfo;
 
 static void
-siginfo_handler(int sig __unused)
+siginfo_handler(int sig __attribute__((unused)))
 {
 
 	siginfo = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chroot/chroot.8 src.freebsd/coreutils/chroot/chroot.8
--- src.orig/coreutils/chroot/chroot.8	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/chroot/chroot.8	2023-01-13 18:21:52.657561866 +0100
@@ -39,7 +39,6 @@
 .Op Fl G Ar group Ns Op Cm \&, Ns Ar group  ...
 .Op Fl g Ar group
 .Op Fl u Ar user
-.Op Fl n
 .Ar newroot
 .Op Ar command Op Ar arg ...
 .Sh DESCRIPTION
@@ -62,16 +61,6 @@
 .It Fl u Ar user
 Run the command as the
 .Ar user .
-.It Fl n
-Use the
-.Dv PROC_NO_NEW_PRIVS_CTL
-.Xr procctl 2
-command before chrooting, effectively disabling SUID/SGID bits
-for the calling process and its descendants.
-If
-.Dv security.bsd.unprivileged_chroot
-sysctl is set to 1, it will make it possible to chroot without
-superuser privileges.
 .El
 .Sh ENVIRONMENT
 The following environment variable is referenced by
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/chroot/chroot.c src.freebsd/coreutils/chroot/chroot.c
--- src.orig/coreutils/chroot/chroot.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/chroot/chroot.c	2023-01-13 18:21:52.657561866 +0100
@@ -44,7 +44,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/procctl.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -69,15 +68,13 @@
 	const char	*shell;
 	gid_t		gid, *gidlist;
 	uid_t		uid;
-	int		arg, ch, error, gids;
+	int			ch, gids;
 	long		ngroups_max;
-	bool		nonprivileged;
 
 	gid = 0;
 	uid = 0;
 	user = group = grouplist = NULL;
-	nonprivileged = false;
-	while ((ch = getopt(argc, argv, "G:g:u:n")) != -1) {
+	while ((ch = getopt(argc, argv, "G:g:u:")) != -1) {
 		switch(ch) {
 		case 'u':
 			user = optarg;
@@ -94,9 +91,6 @@
 			if (*grouplist == '\0')
 				usage();
 			break;
-		case 'n':
-			nonprivileged = true;
-			break;
 		case '?':
 		default:
 			usage();
@@ -160,13 +154,6 @@
 		}
 	}
 
-	if (nonprivileged) {
-		arg = PROC_NO_NEW_PRIVS_ENABLE;
-		error = procctl(P_PID, getpid(), PROC_NO_NEW_PRIVS_CTL, &arg);
-		if (error != 0)
-			err(1, "procctl");
-	}
-
 	if (chdir(argv[0]) == -1 || chroot(".") == -1)
 		err(1, "%s", argv[0]);
 
@@ -193,6 +180,6 @@
 usage(void)
 {
 	(void)fprintf(stderr, "usage: chroot [-g group] [-G group,group,...] "
-	    "[-u user] [-n] newroot [command]\n");
+	    "[-u user] newroot [command]\n");
 	exit(1);
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/cp/cp.1 src.freebsd/coreutils/cp/cp.1
--- src.orig/coreutils/cp/cp.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/cp/cp.1	2023-01-13 18:21:52.657561866 +0100
@@ -172,7 +172,7 @@
 .Nm
 to preserve the following attributes of each source
 file in the copy: modification time, access time,
-file flags, file mode, ACL, user ID, and group ID, as allowed by permissions.
+file flags, file mode, user ID, and group ID, as allowed by permissions.
 .Pp
 If the user ID and group ID cannot be preserved, no error message
 is displayed and the exit value is not altered.
@@ -252,7 +252,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/cp/cp.c src.freebsd/coreutils/cp/cp.c
--- src.orig/coreutils/cp/cp.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/cp/cp.c	2023-01-13 18:21:52.657561866 +0100
@@ -75,6 +75,7 @@
 #include <unistd.h>
 
 #include "extern.h"
+#include "compat.h"
 
 #define	STRIP_TRAILING_SLASH(p) {					\
 	while ((p).p_end > (p).p_path + 1 && (p).p_end[-1] == '/')	\
@@ -92,7 +93,7 @@
 enum op { FILE_TO_FILE, FILE_TO_DIR, DIR_TO_DNE };
 
 static int copy(char *[], enum op, int);
-static void siginfo(int __unused);
+static void siginfo(int __attribute__((unused)));
 
 int
 main(int argc, char *argv[])
@@ -393,12 +394,9 @@
 			if (pflag) {
 				if (setfile(curr->fts_statp, -1))
 					rval = 1;
-				if (preserve_dir_acls(curr->fts_statp,
-				    curr->fts_accpath, to.p_path) != 0)
-					rval = 1;
 			} else {
 				mode = curr->fts_statp->st_mode;
-				if ((mode & (S_ISUID | S_ISGID | S_ISTXT)) ||
+				if ((mode & (S_ISUID | S_ISGID | S_ISVTX)) ||
 				    ((mode | S_IRWXU) & mask) != (mode & mask))
 					if (chmod(to.p_path, mode & mask) !=
 					    0) {
@@ -515,7 +513,7 @@
 }
 
 static void
-siginfo(int sig __unused)
+siginfo(int sig __attribute__((unused)))
 {
 
 	info = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/cp/utils.c src.freebsd/coreutils/cp/utils.c
--- src.orig/coreutils/cp/utils.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/cp/utils.c	2023-01-13 18:21:52.657561866 +0100
@@ -38,7 +38,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 #ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
@@ -52,11 +51,14 @@
 #include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <signal.h>
 #include <sysexits.h>
 #include <unistd.h>
 
 #include "extern.h"
 
+#include "compat.h"
+
 #define	cp_pct(x, y)	((y == 0) ? 0 : (int)(100.0 * (x) / (y)))
 
 /*
@@ -99,11 +101,9 @@
 	static char *buf = NULL;
 	static size_t bufsize;
 	struct stat *fs;
-	ssize_t rcount, wcount;
-	size_t wresid;
+	ssize_t rcount;
 	off_t wtotal;
 	int ch, checkch, from_fd, rval, to_fd;
-	char *bufp;
 #ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
 	char *p;
 #endif
@@ -236,9 +236,14 @@
 				if (use_copy_file_range) {
 					rcount = copy_file_range(from_fd, NULL,
 					    to_fd, NULL, SSIZE_MAX, 0);
-					if (rcount < 0 && errno == EINVAL) {
-						/* Prob a non-seekable FD */
+					if (rcount < 0) switch (errno) {
+					case EINVAL: /* Prob a non-seekable FD */
+					case EXDEV: /* Cross-FS link */
+					case ENOSYS: /* Syscall not supported */
 						use_copy_file_range = 0;
+						break;
+					default:
+						break;
 					}
 				}
 				if (!use_copy_file_range) {
@@ -281,8 +286,6 @@
 	if (!lflag && !sflag) {
 		if (pflag && setfile(fs, to_fd))
 			rval = 1;
-		if (pflag && preserve_fd_acls(from_fd, to_fd) != 0)
-			rval = 1;
 		if (close(to_fd)) {
 			warn("%s", to.p_path);
 			rval = 1;
@@ -409,163 +412,14 @@
 
 	if (!gotstat || fs->st_mode != ts.st_mode)
 		if (fdval ? fchmod(fd, fs->st_mode) :
-		    (islink ? lchmod(to.p_path, fs->st_mode) :
-		    chmod(to.p_path, fs->st_mode))) {
+		    chmod(to.p_path, fs->st_mode)) {
 			warn("chmod: %s", to.p_path);
 			rval = 1;
 		}
 
-	if (!gotstat || fs->st_flags != ts.st_flags)
-		if (fdval ?
-		    fchflags(fd, fs->st_flags) :
-		    (islink ? lchflags(to.p_path, fs->st_flags) :
-		    chflags(to.p_path, fs->st_flags))) {
-			warn("chflags: %s", to.p_path);
-			rval = 1;
-		}
-
 	return (rval);
 }
 
-int
-preserve_fd_acls(int source_fd, int dest_fd)
-{
-	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
-
-	ret = fpathconf(source_fd, _PC_ACL_NFS4);
-	if (ret > 0 ) {
-		acl_supported = 1;
-		acl_type = ACL_TYPE_NFS4;
-	} else if (ret < 0 && errno != EINVAL) {
-		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", to.p_path);
-		return (1);
-	}
-	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
-		if (ret > 0 ) {
-			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
-			    to.p_path);
-			return (1);
-		}
-	}
-	if (acl_supported == 0)
-		return (0);
-
-	acl = acl_get_fd_np(source_fd, acl_type);
-	if (acl == NULL) {
-		warn("failed to get acl entries while setting %s", to.p_path);
-		return (1);
-	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", to.p_path);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
-		warn("failed to set acl entries for %s", to.p_path);
-		acl_free(acl);
-		return (1);
-	}
-	acl_free(acl);
-	return (0);
-}
-
-int
-preserve_dir_acls(struct stat *fs, char *source_dir, char *dest_dir)
-{
-	acl_t (*aclgetf)(const char *, acl_type_t);
-	int (*aclsetf)(const char *, acl_type_t, acl_t);
-	struct acl *aclp;
-	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
-
-	ret = pathconf(source_dir, _PC_ACL_NFS4);
-	if (ret > 0) {
-		acl_supported = 1;
-		acl_type = ACL_TYPE_NFS4;
-	} else if (ret < 0 && errno != EINVAL) {
-		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s", source_dir);
-		return (1);
-	}
-	if (acl_supported == 0) {
-		ret = pathconf(source_dir, _PC_ACL_EXTENDED);
-		if (ret > 0) {
-			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
-			    source_dir);
-			return (1);
-		}
-	}
-	if (acl_supported == 0)
-		return (0);
-
-	/*
-	 * If the file is a link we will not follow it.
-	 */
-	if (S_ISLNK(fs->st_mode)) {
-		aclgetf = acl_get_link_np;
-		aclsetf = acl_set_link_np;
-	} else {
-		aclgetf = acl_get_file;
-		aclsetf = acl_set_file;
-	}
-	if (acl_type == ACL_TYPE_ACCESS) {
-		/*
-		 * Even if there is no ACL_TYPE_DEFAULT entry here, a zero
-		 * size ACL will be returned. So it is not safe to simply
-		 * check the pointer to see if the default ACL is present.
-		 */
-		acl = aclgetf(source_dir, ACL_TYPE_DEFAULT);
-		if (acl == NULL) {
-			warn("failed to get default acl entries on %s",
-			    source_dir);
-			return (1);
-		}
-		aclp = &acl->ats_acl;
-		if (aclp->acl_cnt != 0 && aclsetf(dest_dir,
-		    ACL_TYPE_DEFAULT, acl) < 0) {
-			warn("failed to set default acl entries on %s",
-			    dest_dir);
-			acl_free(acl);
-			return (1);
-		}
-		acl_free(acl);
-	}
-	acl = aclgetf(source_dir, acl_type);
-	if (acl == NULL) {
-		warn("failed to get acl entries on %s", source_dir);
-		return (1);
-	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed on %s", source_dir);
-		acl_free(acl);
-		return (1);
-	}
-	if (trivial) {
-		acl_free(acl);
-		return (0);
-	}
-	if (aclsetf(dest_dir, acl_type, acl) < 0) {
-		warn("failed to set acl entries on %s", dest_dir);
-		acl_free(acl);
-		return (1);
-	}
-	acl_free(acl);
-	return (0);
-}
-
 void
 usage(void)
 {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/csplit/csplit.c src.freebsd/coreutils/csplit/csplit.c
--- src.orig/coreutils/csplit/csplit.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/csplit/csplit.c	2023-01-13 18:21:52.657561866 +0100
@@ -221,7 +221,7 @@
 }
 
 static void
-handlesig(int sig __unused)
+handlesig(int sig __attribute__((unused)))
 {
 	const char msg[] = "csplit: caught signal, cleaning up\n";
 
@@ -237,8 +237,10 @@
 	FILE *fp;
 
 	if ((size_t)snprintf(currfile, sizeof(currfile), "%s%0*ld", prefix,
-	    (int)sufflen, nfiles) >= sizeof(currfile))
-		errc(1, ENAMETOOLONG, NULL);
+	    (int)sufflen, nfiles) >= sizeof(currfile)) {
+		errno = ENAMETOOLONG;
+		err(1, NULL);
+	}
 	if ((fp = fopen(currfile, "w+")) == NULL)
 		err(1, "%s", currfile);
 	nfiles++;
@@ -379,7 +381,7 @@
 	} else
 		ofs = 0;
 
-	if (regcomp(&cre, re, REG_BASIC|REG_NOSUB) != 0)
+	if (regcomp(&cre, re, REG_NOSUB) != 0)
 		errx(1, "%s: bad regular expression", re);
 
 	if (*expr == '/')
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/cut/cut.c src.freebsd/coreutils/cut/cut.c
--- src.orig/coreutils/cut/cut.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/cut/cut.c	2023-01-13 18:21:52.661559474 +0100
@@ -241,7 +241,7 @@
 }
 
 static int
-b_cut(FILE *fp, const char *fname __unused)
+b_cut(FILE *fp, const char *fname __attribute__((unused)))
 {
 	int ch, col;
 	char *pos;
@@ -277,14 +277,15 @@
 static int
 b_n_cut(FILE *fp, const char *fname)
 {
-	size_t col, i, lbuflen;
-	char *lbuf;
+	size_t col, i, bufsize = 0;
+	ssize_t lbuflen;
+	char *lbuf = NULL;
 	int canwrite, clen, warned;
 	mbstate_t mbs;
 
 	memset(&mbs, 0, sizeof(mbs));
 	warned = 0;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		for (col = 0; lbuflen > 0; col += clen) {
 			if ((clen = mbrlen(lbuf, lbuflen, &mbs)) < 0) {
 				if (!warned) {
@@ -333,6 +334,7 @@
 		if (lbuflen > 0)
 			putchar('\n');
 	}
+	free(lbuf);
 	return (warned);
 }
 
@@ -391,29 +393,31 @@
 	int field, i, isdelim;
 	char *pos, *p;
 	int output;
-	char *lbuf, *mlbuf;
-	size_t clen, lbuflen, reallen;
+	char *lbuf = NULL;
+	size_t clen, bufsize = 0, reallen;
+	ssize_t lbuflen;
 
-	mlbuf = NULL;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		reallen = lbuflen;
 		/* Assert EOL has a newline. */
-		if (*(lbuf + lbuflen - 1) != '\n') {
+		if (lbuflen > 0 && *(lbuf + lbuflen - 1) != '\n') {
 			/* Can't have > 1 line with no trailing newline. */
-			mlbuf = malloc(lbuflen + 1);
-			if (mlbuf == NULL)
-				err(1, "malloc");
-			memcpy(mlbuf, lbuf, lbuflen);
-			*(mlbuf + lbuflen) = '\n';
-			lbuf = mlbuf;
+			if ((ssize_t)bufsize < (lbuflen + 1)) {
+				bufsize = lbuflen + 1;
+				lbuf = realloc(lbuf, bufsize);
+			}
+			if (lbuf == NULL)
+				err(1, "realloc");
+			lbuf[lbuflen] = '\n';
 			reallen++;
 		}
 		output = 0;
 		for (isdelim = 0, p = lbuf;; p += clen) {
 			clen = mbrtowc(&ch, p, lbuf + reallen - p, NULL);
 			if (clen == (size_t)-1 || clen == (size_t)-2) {
-				warnc(EILSEQ, "%s", fname);
-				free(mlbuf);
+				errno = EILSEQ;
+				warn("%s", fname);
+				free(lbuf);
 				return (1);
 			}
 			if (clen == 0)
@@ -439,8 +443,9 @@
 				clen = mbrtowc(&ch, p, lbuf + reallen - p,
 				    NULL);
 				if (clen == (size_t)-1 || clen == (size_t)-2) {
-					warnc(EILSEQ, "%s", fname);
-					free(mlbuf);
+					errno = EILSEQ;
+					warn("%s", fname);
+					free(lbuf);
 					return (1);
 				}
 				if (clen == 0)
@@ -472,7 +477,7 @@
 		}
 		(void)putchar('\n');
 	}
-	free(mlbuf);
+	free(lbuf);
 	return (0);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/date/date.c src.freebsd/coreutils/date/date.c
--- src.orig/coreutils/date/date.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/date/date.c	2023-01-13 18:21:52.661559474 +0100
@@ -58,9 +58,13 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <utmpx.h>
+#include <time.h>
+#include <langinfo.h>
 
 #include "vary.h"
 
+#include "compat.h"
+
 #ifndef	TM_YEAR_BASE
 #define	TM_YEAR_BASE	1900
 #endif
@@ -164,7 +168,14 @@
 	if (!rflag && time(&tval) == -1)
 		err(1, "time");
 
-	format = "%+";
+	/* Linux libc's do not support %+ */
+#ifdef _DATE_FMT
+	/* glibc extension */
+	format = nl_langinfo(_DATE_FMT);
+#else
+	/* fallback, e.g. musl */
+	format = "%a %b %e %H:%M:%S %Z %Y";
+#endif
 
 	if (Rflag)
 		format = rfc2822_format;
@@ -344,14 +355,18 @@
 	if (!jflag) {
 		utx.ut_type = OLD_TIME;
 		memset(utx.ut_id, 0, sizeof(utx.ut_id));
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 		tv.tv_sec = tval;
 		tv.tv_usec = 0;
 		if (settimeofday(&tv, NULL) != 0)
 			err(1, "settimeofday (timeval)");
 		utx.ut_type = NEW_TIME;
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 
 		if ((p = getlogin()) == NULL)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/args.c src.freebsd/coreutils/dd/args.c
--- src.orig/coreutils/dd/args.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/args.c	2023-01-13 18:21:52.661559474 +0100
@@ -55,6 +55,8 @@
 #include "dd.h"
 #include "extern.h"
 
+#include "compat.h"
+
 static int	c_arg(const void *, const void *);
 static int	c_conv(const void *, const void *);
 static int	c_iflag(const void *, const void *);
@@ -214,8 +216,10 @@
 	uintmax_t res;
 
 	res = get_num(arg);
-	if (res == UINTMAX_MAX)
-		errc(1, ERANGE, "%s", oper);
+	if (res == UINTMAX_MAX) {
+		errno = ERANGE;
+		err(1, "%s", oper);
+	}
 	if (res == 0)
 		cpy_cnt = UINTMAX_MAX;
 	else
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/dd.1 src.freebsd/coreutils/dd/dd.1
--- src.orig/coreutils/dd/dd.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/dd.1	2023-01-13 18:21:52.661559474 +0100
@@ -417,7 +417,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/dd.c src.freebsd/coreutils/dd/dd.c
--- src.orig/coreutils/dd/dd.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/dd.c	2023-01-13 18:21:52.661559474 +0100
@@ -49,15 +49,10 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
-#include <sys/capsicum.h>
-#include <sys/conf.h>
-#include <sys/disklabel.h>
-#include <sys/filio.h>
 #include <sys/mtio.h>
 #include <sys/time.h>
 
 #include <assert.h>
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -72,6 +67,7 @@
 
 #include "dd.h"
 #include "extern.h"
+#include "compat.h"
 
 static void dd_close(void);
 static void dd_in(void);
@@ -93,7 +89,7 @@
 volatile sig_atomic_t need_progress;
 
 int
-main(int argc __unused, char *argv[])
+main(int argc __attribute__((unused)), char *argv[])
 {
 	struct itimerval itv = { { 1, 0 }, { 1, 0 } }; /* SIGALARM every second, if needed */
 
@@ -101,10 +97,6 @@
 	jcl(argv);
 	setup();
 
-	caph_cache_catpages();
-	if (caph_enter() < 0)
-		err(1, "unable to enter capability mode");
-
 	(void)signal(SIGINFO, siginfo_handler);
 	if (ddflags & C_PROGRESS) {
 		(void)signal(SIGALRM, sigalarm_handler);
@@ -144,8 +136,6 @@
 {
 	u_int cnt;
 	int iflags, oflags;
-	cap_rights_t rights;
-	unsigned long cmds[] = { FIODTYPE, MTIOCTOP };
 
 	if (in.name == NULL) {
 		in.name = "stdin";
@@ -161,16 +151,9 @@
 
 	getfdtype(&in);
 
-	cap_rights_init(&rights, CAP_READ, CAP_SEEK);
-	if (caph_rights_limit(in.fd, &rights) == -1)
-		err(1, "unable to limit capability rights");
-
 	if (files_cnt > 1 && !(in.flags & ISTAPE))
 		errx(1, "files is not supported for non-tape devices");
 
-	cap_rights_set(&rights, CAP_FTRUNCATE, CAP_IOCTL, CAP_WRITE);
-	if (ddflags & (C_FDATASYNC | C_FSYNC))
-		cap_rights_set(&rights, CAP_FSYNC);
 	if (out.name == NULL) {
 		/* No way to check for read access here. */
 		out.fd = STDOUT_FILENO;
@@ -179,7 +162,7 @@
 			oflags = fcntl(out.fd, F_GETFL);
 			if (oflags == -1)
 				err(1, "unable to get fd flags for stdout");
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 			if (fcntl(out.fd, F_SETFL, oflags) == -1)
 				err(1, "unable to set fd flags for stdout");
 		}
@@ -188,7 +171,7 @@
 		if (!(ddflags & (C_SEEK | C_NOTRUNC)))
 			oflags |= O_TRUNC;
 		if (ddflags & C_OFSYNC)
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 		if (ddflags & C_ODIRECT)
 			oflags |= O_DIRECT;
 		out.fd = open(out.name, O_RDWR | oflags, DEFFILEMODE);
@@ -200,7 +183,6 @@
 		if (out.fd == -1) {
 			out.fd = open(out.name, O_WRONLY | oflags, DEFFILEMODE);
 			out.flags |= NOREAD;
-			cap_rights_clear(&rights, CAP_READ);
 		}
 		if (out.fd == -1)
 			err(1, "%s", out.name);
@@ -208,26 +190,6 @@
 
 	getfdtype(&out);
 
-	if (caph_rights_limit(out.fd, &rights) == -1)
-		err(1, "unable to limit capability rights");
-	if (caph_ioctls_limit(out.fd, cmds, nitems(cmds)) == -1)
-		err(1, "unable to limit capability rights");
-
-	if (in.fd != STDIN_FILENO && out.fd != STDIN_FILENO) {
-		if (caph_limit_stdin() == -1)
-			err(1, "unable to limit capability rights");
-	}
-
-	if (in.fd != STDOUT_FILENO && out.fd != STDOUT_FILENO) {
-		if (caph_limit_stdout() == -1)
-			err(1, "unable to limit capability rights");
-	}
-
-	if (in.fd != STDERR_FILENO && out.fd != STDERR_FILENO) {
-		if (caph_limit_stderr() == -1)
-			err(1, "unable to limit capability rights");
-	}
-
 	/*
 	 * Allocate space for the input and output buffers.  If not doing
 	 * record oriented I/O, only need a single buffer.
@@ -316,23 +278,16 @@
 getfdtype(IO *io)
 {
 	struct stat sb;
-	int type;
 
 	if (fstat(io->fd, &sb) == -1)
 		err(1, "%s", io->name);
 	if (S_ISREG(sb.st_mode))
 		io->flags |= ISTRUNC;
-	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) { 
-		if (ioctl(io->fd, FIODTYPE, &type) == -1) {
-			err(1, "%s", io->name);
-		} else {
-			if (type & D_TAPE)
-				io->flags |= ISTAPE;
-			else if (type & (D_DISK | D_MEM))
-				io->flags |= ISSEEK;
-			if (S_ISCHR(sb.st_mode) && (type & D_TAPE) == 0)
-				io->flags |= ISCHR;
-		}
+	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
+		if (S_ISCHR(sb.st_mode))
+			io->flags |= ISCHR;
+		if (S_ISBLK(sb.st_mode))
+			io->flags |= ISSEEK;
 		return;
 	}
 	errno = 0;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/dd.h src.freebsd/coreutils/dd/dd.h
--- src.orig/coreutils/dd/dd.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/dd.h	2023-01-13 18:21:52.661559474 +0100
@@ -36,6 +36,8 @@
  * $FreeBSD$
  */
 
+#include <sys/types.h>
+
 /* Input/output stream state. */
 typedef struct {
 	u_char		*db;		/* buffer address */
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/extern.h src.freebsd/coreutils/dd/extern.h
--- src.orig/coreutils/dd/extern.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/extern.h	2023-01-13 18:21:52.661559474 +0100
@@ -36,6 +36,8 @@
  * $FreeBSD$
  */
 
+#include <signal.h>
+
 void block(void);
 void block_close(void);
 void dd_out(int);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/misc.c src.freebsd/coreutils/dd/misc.c
--- src.orig/coreutils/dd/misc.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/misc.c	2023-01-13 18:21:52.661559474 +0100
@@ -46,7 +46,6 @@
 #include <err.h>
 #include <errno.h>
 #include <inttypes.h>
-#include <libutil.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -57,6 +56,8 @@
 #include "dd.h"
 #include "extern.h"
 
+#include "compat.h"
+
 double
 secs_elapsed(void)
 {
@@ -133,7 +134,7 @@
 
 /* ARGSUSED */
 void
-siginfo_handler(int signo __unused)
+siginfo_handler(int signo __attribute__((unused)))
 {
 
 	need_summary = 1;
@@ -141,7 +142,7 @@
 
 /* ARGSUSED */
 void
-sigalarm_handler(int signo __unused)
+sigalarm_handler(int signo __attribute__((unused)))
 {
 
 	need_progress = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dd/position.c src.freebsd/coreutils/dd/position.c
--- src.orig/coreutils/dd/position.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/dd/position.c	2023-01-13 18:21:52.661559474 +0100
@@ -72,9 +72,9 @@
 	 *
 	 * Bail out if the calculation of a file offset would overflow.
 	 */
-	if ((io->flags & ISCHR) == 0 && (n < 0 || n > OFF_MAX / (ssize_t)sz))
+	if ((io->flags & ISCHR) == 0 && (n < 0 || n > LONG_MAX / (ssize_t)sz))
 		errx(1, "seek offsets cannot be larger than %jd",
-		    (intmax_t)OFF_MAX);
+		    (intmax_t)LONG_MAX);
 	else if ((io->flags & ISCHR) != 0 && (uint64_t)n > UINT64_MAX / sz)
 		errx(1, "seek offsets cannot be larger than %ju",
 		    (uintmax_t)UINT64_MAX);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/df/df.1 src.freebsd/coreutils/df/df.1
--- src.orig/coreutils/df/df.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/df/df.1	2023-01-13 18:21:52.661559474 +0100
@@ -39,7 +39,7 @@
 .Nm
 .Op Fl -libxo
 .Op Fl b | g | H | h | k | m | P
-.Op Fl acilnT
+.Op Fl acilT
 .Op Fl \&,
 .Op Fl t Ar type
 .Op Ar file | filesystem ...
@@ -127,15 +127,6 @@
 This overrides any
 .Ev BLOCKSIZE
 specification from the environment.
-.It Fl n
-Print out the previously obtained statistics from the file systems.
-This option should be used if it is possible that one or more
-file systems are in a state such that they will not be able to provide
-statistics without a long delay.
-When this option is specified,
-.Nm
-will not request new statistics from the file systems, but will respond
-with the possibly stale statistics that were previously obtained.
 .It Fl P
 Explicitly use 512 byte blocks, overriding any
 .Ev BLOCKSIZE
@@ -219,7 +210,7 @@
 .Fl t
 option can be specified only once:
 .Bd -literal -offset indent
-$ df -i -n -t nodevfs,linsysfs
+$ df -i -t nodevfs,linsysfs
 Filesystem   1K-blocks      Used      Avail Capacity iused     ifree %iused
 Mounted on
 /dev/ada1p2  223235736 159618992   45757888    78% 1657590  27234568    6%   /
@@ -277,13 +268,6 @@
 .At v1 .
 .Sh BUGS
 The
-.Fl n
-flag is ignored if a file or file system is specified.
-Also, if a mount
-point is not accessible by the user, it is possible that the file system
-information could be stale.
-.Pp
-The
 .Fl b
 and
 .Fl P
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/df/df.c src.freebsd/coreutils/df/df.c
--- src.orig/coreutils/df/df.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/df/df.c	2023-01-14 03:06:55.429092333 +0100
@@ -50,11 +50,10 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/statvfs.h>
 #include <sys/mount.h>
-#include <sys/sysctl.h>
 #include <err.h>
 #include <getopt.h>
-#include <libutil.h>
 #include <locale.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -63,10 +62,40 @@
 #include <sysexits.h>
 #include <unistd.h>
 #include <libxo/xo.h>
+#include <assert.h>
+#include <mntent.h>
+
+#include "compat.h"
 
 #define UNITS_SI	1
 #define UNITS_2		2
 
+/*
+ * Static list of network filesystems
+ *
+ * This replaces the makenetvfslist() function from FreeBSD, but this
+ * list should be made in to something we can generate at runtime or
+ * just expand the list.
+ */
+#define NETVFSLIST "nonfs,nfs4,smb,cifs"
+
+/* combining data from getmntent() and statvfs() on Linux */
+struct mntinfo {
+    char *f_mntfromname;          /* mnt_fsname from getmntent */
+    char *f_mntonname;            /* mnt_dir from getmntent */
+    char *f_fstypename;           /* mnt_fsname from getmntent */
+    char *f_opts;                 /* mnt_opts from getmntent */
+    unsigned long f_bsize;        /* f_bsize from statvfs */
+    fsblkcnt_t f_blocks;          /* f_blocks from statvfs */
+    fsblkcnt_t f_bfree;           /* f_bfree from statvfs */
+    fsblkcnt_t f_bavail;          /* f_bavail from statvfs */
+    fsfilcnt_t f_files;           /* f_files from statvfs */
+    fsfilcnt_t f_ffree;           /* f_ffree from statvfs */
+    unsigned long f_flag;         /* f_flag from statvfs */
+    dev_t f_dev;                  /* st_dev from stat */
+    unsigned int f_selected;      /* used internally here only */
+};
+
 /* Maximum widths of various fields. */
 struct maxwidths {
 	int	mntfrom;
@@ -78,20 +107,20 @@
 	int	ifree;
 };
 
-static void	  addstat(struct statfs *, struct statfs *);
-static char	 *getmntpt(const char *);
+static void	  addstat(struct mntinfo *, struct mntinfo *);
+static char	 *getmntpt(struct mntinfo **, const size_t, const char *);
 static const char **makevfslist(char *fslist, int *skip);
 static int	  checkvfsname(const char *vfsname, const char **vfslist, int skip);
 static int	  checkvfsselected(char *);
 static int	  int64width(int64_t);
-static char	 *makenetvfslist(void);
-static void	  prthuman(const struct statfs *, int64_t);
+static void	  prthuman(const struct mntinfo *, int64_t);
 static void	  prthumanval(const char *, int64_t);
 static intmax_t	  fsbtoblk(int64_t, uint64_t, u_long);
-static void	  prtstat(struct statfs *, struct maxwidths *);
-static size_t	  regetmntinfo(struct statfs **, long);
-static void	  update_maxwidths(struct maxwidths *, const struct statfs *);
+static void	  prtstat(struct mntinfo *, struct maxwidths *);
+static void	  update_maxwidths(struct maxwidths *, const struct mntinfo *);
 static void	  usage(void);
+static int	  getmntinfo(struct mntinfo **);
+static void	  freemntinfo(struct mntinfo *, int);
 
 static __inline int
 imax(int a, int b)
@@ -99,7 +128,7 @@
 	return (a > b ? a : b);
 }
 
-static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, nflag, Tflag;
+static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, Tflag;
 static int	  thousands;
 static int	  skipvfs_l, skipvfs_t;
 static const char **vfslist_l, **vfslist_t;
@@ -114,9 +143,9 @@
 main(int argc, char *argv[])
 {
 	struct stat stbuf;
-	struct statfs statfsbuf, totalbuf;
+	struct mntinfo *mntbuf = NULL;
+	struct mntinfo totalbuf;
 	struct maxwidths maxwidths;
-	struct statfs *mntbuf;
 	char *mntpt;
 	int i, mntsize;
 	int ch, rv;
@@ -125,13 +154,12 @@
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	memset(&totalbuf, 0, sizeof(totalbuf));
 	totalbuf.f_bsize = DEV_BSIZE;
-	strlcpy(totalbuf.f_mntfromname, "total", MNAMELEN);
 
 	argc = xo_parse_args(argc, argv);
 	if (argc < 0)
 		exit(1);
 
-	while ((ch = getopt_long(argc, argv, "+abcgHhiklmnPt:T,", long_options,
+	while ((ch = getopt_long(argc, argv, "+abcgHhiklmPt:T,", long_options,
 	    NULL)) != -1)
 		switch (ch) {
 		case 'a':
@@ -176,7 +204,7 @@
 			/* Ignore duplicate -l */
 			if (lflag)
 				break;
-			vfslist_l = makevfslist(makenetvfslist(), &skipvfs_l);
+			vfslist_l = makevfslist(NETVFSLIST, &skipvfs_l);
 			lflag = 1;
 			break;
 		case 'm':
@@ -184,7 +212,6 @@
 			hflag = 0;
 			break;
 		case 'n':
-			nflag = 1;
 			break;
 		case 't':
 			if (vfslist_t != NULL)
@@ -205,32 +232,28 @@
 	argv += optind;
 
 	rv = 0;
-	if (!*argv) {
-		/* everything (modulo -t) */
-		mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
-		mntsize = regetmntinfo(&mntbuf, mntsize);
-	} else {
-		/* just the filesystems specified on the command line */
-		mntbuf = malloc(argc * sizeof(*mntbuf));
-		if (mntbuf == NULL)
-			xo_err(1, "malloc()");
-		mntsize = 0;
-		/* continued in for loop below */
-	}
+	mntsize = getmntinfo(&mntbuf);
 
 	xo_open_container("storage-system-information");
 	xo_open_list("filesystem");
 
+	/* unselect all filesystems if an explicit list is given */
+	if (*argv) {
+		for (i = 0; i < mntsize; i++) {
+			mntbuf[i].f_selected = 0;
+		}
+	}
+
 	/* iterate through specified filesystems */
 	for (; *argv; argv++) {
 		if (stat(*argv, &stbuf) < 0) {
-			if ((mntpt = getmntpt(*argv)) == NULL) {
+			if ((mntpt = getmntpt(&mntbuf, mntsize, *argv)) == NULL) {
 				xo_warn("%s", *argv);
 				rv = 1;
 				continue;
 			}
 		} else if (S_ISCHR(stbuf.st_mode)) {
-			mntpt = getmntpt(*argv);
+			mntpt = getmntpt(&mntbuf, mntsize, *argv);
 			if (mntpt == NULL) {
 				xo_warnx("%s: not mounted", *argv);
 				rv = 1;
@@ -239,46 +262,27 @@
 		} else {
 			mntpt = *argv;
 		}
-
-		/*
-		 * Statfs does not take a `wait' flag, so we cannot
-		 * implement nflag here.
-		 */
-		if (statfs(mntpt, &statfsbuf) < 0) {
-			xo_warn("%s", mntpt);
-			rv = 1;
-			continue;
-		}
-
-		/*
-		 * Check to make sure the arguments we've been given are
-		 * satisfied.  Return an error if we have been asked to
-		 * list a mount point that does not match the other args
-		 * we've been given (-l, -t, etc.).
-		 */
-		if (checkvfsselected(statfsbuf.f_fstypename) != 0) {
-			rv = 1;
-			continue;
+		for (i = 0; i < mntsize; i++) {
+			/* selected specified filesystems if the mount point or device matches */
+			if (((stbuf.st_dev == mntbuf[i].f_dev) || !strcmp(mntbuf[i].f_mntfromname, mntpt) || !strcmp(mntbuf[i].f_mntonname, mntpt)) && checkvfsselected(mntbuf[i].f_fstypename) == 0) {
+				mntbuf[i].f_selected = 1;
+				break;
+			}
 		}
-
-		/* the user asked for it, so ignore the ignore flag */
-		statfsbuf.f_flags &= ~MNT_IGNORE;
-
-		/* add to list */
-		mntbuf[mntsize++] = statfsbuf;
 	}
 
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	for (i = 0; i < mntsize; i++) {
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected) {
 			update_maxwidths(&maxwidths, &mntbuf[i]);
 			if (cflag)
 				addstat(&totalbuf, &mntbuf[i]);
 		}
 	}
-	for (i = 0; i < mntsize; i++)
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0)
+	for (i = 0; i < mntsize; i++) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected)
 			prtstat(&mntbuf[i], &maxwidths);
+	}
 
 	xo_close_list("filesystem");
 
@@ -287,19 +291,21 @@
 
 	xo_close_container("storage-system-information");
 	xo_finish();
+	freemntinfo(mntbuf, mntsize);
 	exit(rv);
 }
 
 static char *
-getmntpt(const char *name)
+getmntpt(struct mntinfo **mntbuf, const size_t mntsize, const char *name)
 {
-	size_t mntsize, i;
-	struct statfs *mntbuf;
+	size_t i;
+
+	if (mntsize == 0 || mntbuf == NULL || name == NULL)
+		return NULL;
 
-	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
 	for (i = 0; i < mntsize; i++) {
-		if (!strcmp(mntbuf[i].f_mntfromname, name))
-			return (mntbuf[i].f_mntonname);
+		if (mntbuf[i] == NULL)
+			continue;
 	}
 	return (NULL);
 }
@@ -376,45 +382,8 @@
 	return (result);
 }
 
-/*
- * Make a pass over the file system info in ``mntbuf'' filtering out
- * file system types not in vfslist_{l,t} and possibly re-stating to get
- * current (not cached) info.  Returns the new count of valid statfs bufs.
- */
-static size_t
-regetmntinfo(struct statfs **mntbufp, long mntsize)
-{
-	int error, i, j;
-	struct statfs *mntbuf;
-
-	if (vfslist_l == NULL && vfslist_t == NULL)
-		return (nflag ? mntsize : getmntinfo(mntbufp, MNT_WAIT));
-
-	mntbuf = *mntbufp;
-	for (j = 0, i = 0; i < mntsize; i++) {
-		if (checkvfsselected(mntbuf[i].f_fstypename) != 0)
-			continue;
-		/*
-		 * XXX statfs(2) can fail for various reasons. It may be
-		 * possible that the user does not have access to the
-		 * pathname, if this happens, we will fall back on
-		 * "stale" filesystem statistics.
-		 */
-		error = statfs(mntbuf[i].f_mntonname, &mntbuf[j]);
-		if (nflag || error < 0)
-			if (i != j) {
-				if (error < 0)
-					xo_warnx("%s stats possibly stale",
-					    mntbuf[i].f_mntonname);
-				mntbuf[j] = mntbuf[i];
-			}
-		j++;
-	}
-	return (j);
-}
-
 static void
-prthuman(const struct statfs *sfsp, int64_t used)
+prthuman(const struct mntinfo *sfsp, int64_t used)
 {
 
 	prthumanval("  {:blocks/%6s}", sfsp->f_blocks * sfsp->f_bsize);
@@ -458,7 +427,7 @@
 }
 
 /*
- * Convert statfs returned file system size into BLOCKSIZE units.
+ * Convert statvfs returned file system size into BLOCKSIZE units.
  */
 static intmax_t
 fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
@@ -470,7 +439,7 @@
  * Print out status about a file system.
  */
 static void
-prtstat(struct statfs *sfsp, struct maxwidths *mwp)
+prtstat(struct mntinfo *sfsp, struct maxwidths *mwp)
 {
 	static long blocksize;
 	static int headerlen, timesthrough = 0;
@@ -544,7 +513,7 @@
 		    mwp->avail, fsbtoblk(sfsp->f_bavail,
 		    sfsp->f_bsize, blocksize));
 	}
-	xo_emit(" {:used-percent/%5.0f}{U:%%}",
+	xo_emit("   {:used-percent/%5.0f}{U:%%}",
 	    availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
 	if (iflag) {
 		inodes = sfsp->f_files;
@@ -566,23 +535,23 @@
 			(double)used / (double)inodes * 100.0);
 	} else
 		xo_emit("  ");
-	if (strncmp(sfsp->f_mntfromname, "total", MNAMELEN) != 0)
-		xo_emit("  {:mounted-on}", sfsp->f_mntonname);
+	if (strcmp(sfsp->f_mntfromname, "total") != 0)
+		xo_emit("{:mounted-on}", sfsp->f_mntonname);
 	xo_emit("\n");
 	xo_close_instance("filesystem");
 }
 
 static void
-addstat(struct statfs *totalfsp, struct statfs *statfsp)
+addstat(struct mntinfo *totalfsp, struct mntinfo *statvfsp)
 {
 	uint64_t bsize;
 
-	bsize = statfsp->f_bsize / totalfsp->f_bsize;
-	totalfsp->f_blocks += statfsp->f_blocks * bsize;
-	totalfsp->f_bfree += statfsp->f_bfree * bsize;
-	totalfsp->f_bavail += statfsp->f_bavail * bsize;
-	totalfsp->f_files += statfsp->f_files;
-	totalfsp->f_ffree += statfsp->f_ffree;
+	bsize = statvfsp->f_bsize / totalfsp->f_bsize;
+	totalfsp->f_blocks += statvfsp->f_blocks * bsize;
+	totalfsp->f_bfree += statvfsp->f_bfree * bsize;
+	totalfsp->f_bavail += statvfsp->f_bavail * bsize;
+	totalfsp->f_files += statvfsp->f_files;
+	totalfsp->f_ffree += statvfsp->f_ffree;
 }
 
 /*
@@ -590,7 +559,7 @@
  * the file system specified by `sfsp'.
  */
 static void
-update_maxwidths(struct maxwidths *mwp, const struct statfs *sfsp)
+update_maxwidths(struct maxwidths *mwp, const struct mntinfo *sfsp)
 {
 	static long blocksize = 0;
 	int dummy;
@@ -642,69 +611,95 @@
 	exit(EX_USAGE);
 }
 
-static char *
-makenetvfslist(void)
+static int
+getmntinfo(struct mntinfo **mntbuf)
 {
-	char *str, *strptr, **listptr;
-	struct xvfsconf *xvfsp, *keep_xvfsp;
-	size_t buflen;
-	int cnt, i, maxvfsconf;
+	struct mntinfo *list = NULL;
+	struct mntinfo *current = NULL;
+	struct mntent *ent = NULL;
+	int mntsize = 0;
+	FILE *fp = NULL;
+	struct statvfs svfsbuf;
+	struct stat stmnt;
+
+#ifdef _PATH_MOUNTED
+	fp = setmntent(_PATH_MOUNTED, "r");
+#else
+	if (access("/proc/self/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/self/mounts", "r");
+	} else if (access("/proc/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/mounts", "r");
+	} else if (access("/etc/mtab", R_OK) == 0) {
+	    fp = setmntent("/etc/mtab", "r");
+	}
+#endif
+
+	if (fp == NULL) {
+	    err(1, "setmntent");
+	}
+
+	while ((ent = getmntent(fp)) != NULL) {
+	    /* skip if necessary */
+	    if (hasmntopt(ent, MNTTYPE_IGNORE) != NULL) {
+	        continue;
+	    }
+
+	    /* filter out filesystems to be skipped */
+	    if (vfslist_l || vfslist_t) {
+	        if (checkvfsselected(ent->mnt_type) != 0)
+	            continue;
+	    }
+
+	    /* get stat(vfs) fields and copy those over */
+	    if (statvfs(ent->mnt_dir, &svfsbuf) == -1 || stat(ent->mnt_dir, &stmnt) == -1) {
+	        if ((errno == EACCES) || (errno == EPERM)) continue;
+	        err(1, "statvfs");
+	    }
+
+	    /* allocate the entry */
+	    list = realloc(list, (mntsize + 1) * sizeof(*list));
+	    assert(list != NULL);
+	    current = list + mntsize;
+
+	    /* fill the struct with getmntent fields */
+	    current->f_fstypename = strdup(ent->mnt_type);
+	    current->f_mntfromname = strdup(ent->mnt_fsname);
+	    current->f_mntonname = strdup(ent->mnt_dir);
+	    current->f_opts = strdup(ent->mnt_opts);
+
+	    current->f_flag = svfsbuf.f_flag;
+	    current->f_blocks = svfsbuf.f_blocks;
+	    current->f_bsize = svfsbuf.f_bsize;
+	    current->f_bfree = svfsbuf.f_bfree;
+	    current->f_bavail = svfsbuf.f_bavail;
+	    current->f_files = svfsbuf.f_files;
+	    current->f_ffree = svfsbuf.f_ffree;
+
+	    current->f_dev = stmnt.st_dev;
+
+	    current->f_selected = 1;
 
-	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		return (NULL);
-	}
-	xvfsp = malloc(buflen);
-	if (xvfsp == NULL) {
-		xo_warnx("malloc failed");
-		return (NULL);
+	    mntsize++;
 	}
-	keep_xvfsp = xvfsp;
-	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		free(keep_xvfsp);
-		return (NULL);
-	}
-	maxvfsconf = buflen / sizeof(struct xvfsconf);
 
-	if ((listptr = malloc(sizeof(char*) * maxvfsconf)) == NULL) {
-		xo_warnx("malloc failed");
-		free(keep_xvfsp);
-		return (NULL);
-	}
+	endmntent(fp);
 
-	for (cnt = 0, i = 0; i < maxvfsconf; i++) {
-		if (xvfsp->vfc_flags & VFCF_NETWORK) {
-			listptr[cnt++] = strdup(xvfsp->vfc_name);
-			if (listptr[cnt-1] == NULL) {
-				xo_warnx("malloc failed");
-				free(listptr);
-				free(keep_xvfsp);
-				return (NULL);
-			}
-		}
-		xvfsp++;
-	}
+	*mntbuf = list;
+	return mntsize;
+}
 
-	if (cnt == 0 ||
-	    (str = malloc(sizeof(char) * (32 * cnt + cnt + 2))) == NULL) {
-		if (cnt > 0)
-			xo_warnx("malloc failed");
-		free(listptr);
-		free(keep_xvfsp);
-		return (NULL);
+static void
+freemntinfo(struct mntinfo *mntbuf, int mntsize)
+{
+	int i = 0;
+
+	for (i = 0; i < mntsize; i++) {
+	    free(mntbuf[i].f_fstypename);
+	    free(mntbuf[i].f_mntfromname);
+	    free(mntbuf[i].f_mntonname);
+	    free(mntbuf[i].f_opts);
 	}
 
-	*str = 'n'; *(str + 1) = 'o';
-	for (i = 0, strptr = str + 2; i < cnt; i++, strptr++) {
-		strlcpy(strptr, listptr[i], 32);
-		strptr += strlen(listptr[i]);
-		*strptr = ',';
-		free(listptr[i]);
-	}
-	*(--strptr) = '\0';
-
-	free(keep_xvfsp);
-	free(listptr);
-	return (str);
+	free(mntbuf);
+	return;
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/dirname/dirname.c src.freebsd/coreutils/dirname/dirname.c
--- src.orig/coreutils/dirname/dirname.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/dirname/dirname.c	2023-01-13 18:21:52.661559474 +0100
@@ -41,7 +41,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <libgen.h>
 #include <stdio.h>
@@ -56,9 +55,6 @@
 	char *p;
 	int ch;
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	while ((ch = getopt(argc, argv, "")) != -1)
 		switch(ch) {
 		case '?':
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/du/du.1 src.freebsd/coreutils/du/du.1
--- src.orig/coreutils/du/du.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/du/du.1	2023-01-13 18:21:52.661559474 +0100
@@ -116,12 +116,6 @@
 are counted (and displayed) as many times as they are found.
 .It Fl m
 Display block counts in 1048576-byte (1 MiB) blocks.
-.It Fl n
-Ignore files and directories with user
-.Dq nodump
-flag
-.Pq Dv UF_NODUMP
-set.
 .It Fl r
 Generate messages about directories that cannot be read, files
 that cannot be opened, and so on.
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/du/du.c src.freebsd/coreutils/du/du.c
--- src.orig/coreutils/du/du.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/du/du.c	2023-01-13 18:21:52.665557082 +0100
@@ -54,8 +54,8 @@
 #include <fnmatch.h>
 #include <fts.h>
 #include <getopt.h>
-#include <libutil.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,6 +63,8 @@
 #include <sysexits.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 #define SI_OPT	(CHAR_MAX + 1)
 
 #define UNITS_2		1
@@ -80,9 +82,8 @@
 static void	ignoreadd(const char *);
 static void	ignoreclean(void);
 static int	ignorep(FTSENT *);
-static void	siginfo(int __unused);
+static void	siginfo(int __attribute__((unused)));
 
-static int	nodumpflag = 0;
 static int	Aflag, hflag;
 static long	blocksize, cblocksize;
 static volatile sig_atomic_t info;
@@ -121,7 +122,7 @@
 	depth = INT_MAX;
 	SLIST_INIT(&ignores);
 
-	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmnrt:x",
+	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmrt:x",
 	    long_options, NULL)) != -1)
 		switch (ch) {
 		case 'A':
@@ -187,19 +188,23 @@
 			hflag = 0;
 			blocksize = 1048576;
 			break;
-		case 'n':
-			nodumpflag = 1;
-			break;
 		case 'r':		 /* Compatibility. */
 			break;
-		case 't' :
-			if (expand_number(optarg, &threshold) != 0 ||
-			    threshold == 0) {
+		case 't' : {
+			uint64_t thresh;
+			/* expand_number takes an unsigned pointer but will happily store
+			 * negative values (represented as values beyond signed maximum)
+			 * store in unsigned and then copy to avoid UB
+			 */
+			int ret = expand_number(optarg, &thresh);
+			memcpy(&threshold, &thresh, sizeof(threshold));
+			if (ret != 0 || threshold == 0) {
 				warnx("invalid threshold: %s", optarg);
 				usage();
 			} else if (threshold < 0)
 				threshold_sign = -1;
 			break;
+		}
 		case 'x':
 			ftsoptions |= FTS_XDEV;
 			break;
@@ -281,18 +286,18 @@
 			curblocks = Aflag ?
 			    howmany(p->fts_statp->st_size, cblocksize) :
 			    howmany(p->fts_statp->st_blocks, cblocksize);
-			p->fts_parent->fts_bignum += p->fts_bignum +=
+			p->fts_parent->fts_number += p->fts_number +=
 			    curblocks;
 
 			if (p->fts_level <= depth && threshold <=
-			    threshold_sign * howmany(p->fts_bignum *
+			    threshold_sign * howmany(p->fts_number *
 			    cblocksize, blocksize)) {
 				if (hflag > 0) {
-					prthumanval(p->fts_bignum);
+					prthumanval(p->fts_number);
 					(void)printf("\t%s\n", p->fts_path);
 				} else {
 					(void)printf("%jd\t%s\n",
-					    (intmax_t)howmany(p->fts_bignum *
+					    (intmax_t)howmany(p->fts_number *
 					    cblocksize, blocksize),
 					    p->fts_path);
 				}
@@ -334,9 +339,9 @@
 				}
 			}
 
-			p->fts_parent->fts_bignum += curblocks;
+			p->fts_parent->fts_number += curblocks;
 		}
-		savednumber = p->fts_parent->fts_bignum;
+		savednumber = p->fts_parent->fts_number;
 	}
 
 	if (errno)
@@ -547,8 +552,6 @@
 {
 	struct ignentry *ign;
 
-	if (nodumpflag && (ent->fts_statp->st_flags & UF_NODUMP))
-		return 1;
 	SLIST_FOREACH(ign, &ignores, next)
 		if (fnmatch(ign->mask, ent->fts_name, 0) != FNM_NOMATCH)
 			return 1;
@@ -556,7 +559,7 @@
 }
 
 static void
-siginfo(int sig __unused)
+siginfo(int sig __attribute__((unused)))
 {
 
 	info = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/echo/echo.c src.freebsd/coreutils/echo/echo.c
--- src.orig/coreutils/echo/echo.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/echo/echo.c	2023-01-13 18:21:52.665557082 +0100
@@ -47,7 +47,6 @@
 #include <sys/uio.h>
 
 #include <assert.h>
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <limits.h>
@@ -64,9 +63,6 @@
 	char space[] = " ";
 	char newline[] = "\n";
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	/* This utility may NOT do getopt(3) option parsing. */
 	if (*++argv && !strcmp(*argv, "-n")) {
 		++argv;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/env/env.1 src.freebsd/coreutils/env/env.1
--- src.orig/coreutils/env/env.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/env/env.1	2023-01-13 18:21:52.665557082 +0100
@@ -40,12 +40,10 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl 0iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl u Ar name
 .Op Ar name Ns = Ns Ar value ...
 .Nm
 .Op Fl iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl P Ar altpath
 .Op Fl S Ar string
 .Op Fl u Ar name
@@ -82,34 +80,6 @@
 by
 .Nm
 is ignored completely.
-.\"	-L | -U
-.It Fl L | Fl U Ar user Ns Op / Ns Ar class
-Add the environment variable definitions from
-.Xr login.conf 5
-for the specified user and login class to the environment, after
-processing any
-.Fl i
-or
-.Fl u
-options, but before processing any
-.Ar name Ns = Ns Ar value
-options.
-If
-.Fl L
-is used, only the system-wide
-.Pa /etc/login.conf.db
-file is read; if
-.Fl U
-is used, then the specified user's
-.Pa ~/.login_conf
-is read as well.
-The user may be specified by name or by uid.
-If a username of
-.Sq Li \&-
-is given, then no user lookup will be done, the login class will default to
-.Sq Li default
-if not explicitly given, and no substitutions will be done on the values.
-.\"	-P
 .It Fl P Ar altpath
 Search the set of directories as specified by
 .Ar altpath
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/env/env.c src.freebsd/coreutils/env/env.c
--- src.orig/coreutils/env/env.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/env/env.c	2023-01-13 18:21:52.665557082 +0100
@@ -42,13 +42,11 @@
 #endif
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
-#include <login_cap.h>
 #include <pwd.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -76,23 +74,18 @@
 {
 	char *altpath, **ep, *p, **parg, term;
 	char *cleanenv[1];
-	char *login_class, *login_name;
+	char *login_name;
 	struct passwd *pw;
-	login_cap_t *lc;
-	bool login_as_user;
 	uid_t uid;
 	int ch, want_clear;
 	int rtrn;
 
 	altpath = NULL;
-	login_class = NULL;
 	login_name = NULL;
 	pw = NULL;
-	lc = NULL;
-	login_as_user = false;
 	want_clear = 0;
 	term = '\n';
-	while ((ch = getopt(argc, argv, "-0iL:P:S:U:u:v")) != -1)
+	while ((ch = getopt(argc, argv, "0iP:S:u:v")) != -1)
 		switch(ch) {
 		case '-':
 		case 'i':
@@ -101,12 +94,6 @@
 		case '0':
 			term = '\0';
 			break;
-		case 'U':
-			login_as_user = true;
-			/* FALLTHROUGH */
-		case 'L':
-			login_name = optarg;
-			break;
 		case 'P':
 			altpath = strdup(optarg);
 			break;
@@ -134,6 +121,10 @@
 		default:
 			usage();
 		}
+	if (optind < argc && !strcmp(argv[optind], "-")) {
+		want_clear = 1;
+		++argv; /* skip the initial - during later scan */
+	}
 	if (want_clear) {
 		environ = cleanenv;
 		cleanenv[0] = NULL;
@@ -141,9 +132,6 @@
 			fprintf(stderr, "#env clearing environ\n");
 	}
 	if (login_name != NULL) {
-		login_class = strchr(login_name, '/');
-		if (login_class)
-			*login_class++ = '\0';
 		if (*login_name != '\0' && strcmp(login_name, "-") != 0) {
 			pw = getpwnam(login_name);
 			if (pw == NULL) {
@@ -156,38 +144,8 @@
 			if (pw == NULL)
 				errx(EXIT_FAILURE, "no such user: %s", login_name);
 		}
-		/*
-		 * Note that it is safe for pw to be null here; the libutil
-		 * code handles that, bypassing substitution of $ and using
-		 * the class "default" if no class name is given either.
-		 */
-		if (login_class != NULL) {
-			lc = login_getclass(login_class);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "no such login class: %s",
-				    login_class);
-		} else {
-			lc = login_getpwclass(pw);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "login_getpwclass failed");
-		}
 
-		/*
-		 * This is not done with setusercontext() because that will
-		 * try and use ~/.login_conf even when we don't want it to.
-		 */
-		setclassenvironment(lc, pw, 1);
-		setclassenvironment(lc, pw, 0);
-		if (login_as_user) {
-			login_close(lc);
-			if ((lc = login_getuserclass(pw)) != NULL) {
-				setclassenvironment(lc, pw, 1);
-				setclassenvironment(lc, pw, 0);
-			}
-		}
 		endpwent();
-		if (lc != NULL)
-			login_close(lc);
 	}
 	for (argv += optind; *argv && (p = strchr(*argv, '=')); ++argv) {
 		if (env_verbosity)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/env/envopts.c src.freebsd/coreutils/env/envopts.c
--- src.orig/coreutils/env/envopts.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/env/envopts.c	2023-01-13 18:21:52.665557082 +0100
@@ -33,6 +33,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <err.h>
@@ -44,6 +45,7 @@
 #include <unistd.h>
 
 #include "envopts.h"
+#include "compat.h"
 
 static const char *
 		 expand_vars(int in_thisarg, char **thisarg_p, char **dest_p,
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/expr/expr.y src.freebsd/coreutils/expr/expr.y
--- src.orig/coreutils/expr/expr.y	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/expr/expr.y	2023-01-13 18:21:52.665557082 +0100
@@ -270,8 +270,7 @@
 	int c;
 
 	setlocale(LC_ALL, "");
-	if (getenv("EXPR_COMPAT") != NULL
-	    || check_utility_compat("expr")) {
+	if (getenv("EXPR_COMPAT") != NULL) {
 		av = argv + 1;
 		nonposix = 1;
 	} else {
@@ -299,7 +298,7 @@
 }
 
 int
-yyerror(const char *s __unused)
+yyerror(const char *s __attribute__((unused)))
 {
 	errx(ERR_EXIT, "syntax error");
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/factor/factor.c src.freebsd/coreutils/factor/factor.c
--- src.orig/coreutils/factor/factor.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/factor/factor.c	2023-01-13 18:21:52.665557082 +0100
@@ -66,6 +66,7 @@
  * If no args are given, the list of numbers are read from stdin.
  */
 
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/fmt/fmt.c src.freebsd/coreutils/fmt/fmt.c
--- src.orig/coreutils/fmt/fmt.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/fmt/fmt.c	2023-01-13 18:21:52.665557082 +0100
@@ -185,6 +185,7 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <stdint.h>
 
 /* Something that, we hope, will never be a genuine line length,
  * indentation etc.
@@ -380,7 +381,7 @@
 		goal_length = 65;
 	if (max_length == 0)
 		max_length = goal_length + 10;
-	if (max_length >= SIZE_T_MAX / sizeof(wchar_t))
+	if (max_length >= SIZE_MAX / sizeof(wchar_t))
 		errx(EX_USAGE, "max length too large");
 	/* really needn't be longer */
 	output_buffer = XMALLOC((max_length + 1) * sizeof(wchar_t));
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/head/head.c src.freebsd/coreutils/head/head.c
--- src.orig/coreutils/head/head.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/head/head.c	2023-01-13 18:21:52.665557082 +0100
@@ -43,10 +43,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
 #include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -57,9 +55,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 /*
  * head - give the first few lines of a stream or of each of a set of files
  *
@@ -85,8 +80,6 @@
 	char *ep;
 	off_t bytecnt;
 	int ch, first, linecnt, eval;
-	fileargs_t *fa;
-	cap_rights_t rights;
 
 	linecnt = -1;
 	eval = 0;
@@ -114,22 +107,13 @@
 	argc -= optind;
 	argv += optind;
 
-	fa = fileargs_init(argc, argv, O_RDONLY, 0,
-	    cap_rights_init(&rights, CAP_READ, CAP_FSTAT, CAP_FCNTL), FA_OPEN);
-	if (fa == NULL)
-		err(1, "unable to init casper");
-
-	caph_cache_catpages();
-	if (caph_limit_stdio() < 0 || caph_enter_casper() < 0)
-		err(1, "unable to enter capability mode");
-
 	if (linecnt != -1 && bytecnt != -1)
 		errx(1, "can't combine line and byte counts");
 	if (linecnt == -1)
 		linecnt = 10;
 	if (*argv != NULL) {
 		for (first = 1; *argv != NULL; ++argv) {
-			if ((fp = fileargs_fopen(fa, *argv, "r")) == NULL) {
+			if ((fp = fopen(*argv, "r")) == NULL) {
 				warn("%s", *argv);
 				eval = 1;
 				continue;
@@ -150,22 +134,23 @@
 	else
 		head_bytes(stdin, bytecnt);
 
-	fileargs_free(fa);
 	exit(eval);
 }
 
 static void
 head(FILE *fp, int cnt)
 {
-	char *cp;
-	size_t error, readlen;
+	char *cp = NULL;
+	size_t error, bufsize = 0;
+	ssize_t readlen;
 
-	while (cnt != 0 && (cp = fgetln(fp, &readlen)) != NULL) {
+	while (cnt != 0 && (readlen = getline(&cp, &bufsize, fp)) >= 0) {
 		error = fwrite(cp, sizeof(char), readlen, stdout);
-		if (error != readlen)
+		if ((ssize_t)error != readlen)
 			err(1, "stdout");
 		cnt--;
 	}
+	free(cp);
 }
 
 static void
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/id/id.1 src.freebsd/coreutils/id/id.1
--- src.orig/coreutils/id/id.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/id/id.1	2023-01-13 18:21:52.665557082 +0100
@@ -41,18 +41,12 @@
 .Nm
 .Op Ar user
 .Nm
-.Fl A
-.Nm
 .Fl G Op Fl n
 .Op Ar user
 .Nm
-.Fl M
-.Nm
 .Fl P
 .Op Ar user
 .Nm
-.Fl c
-.Nm
 .Fl g Op Fl nr
 .Op Ar user
 .Nm
@@ -77,22 +71,15 @@
 .Pp
 The options are as follows:
 .Bl -tag -width indent
-.It Fl A
-Display the process audit user ID and other process audit properties, which
-requires privilege.
 .It Fl G
 Display the different group IDs (effective, real and supplementary)
 as white-space separated numbers, in no particular order.
-.It Fl M
-Display the MAC label of the current process.
 .It Fl P
 Display the id as a password file entry.
 .It Fl a
 Ignored for compatibility with other
 .Nm
 implementations.
-.It Fl c
-Display current login class.
 .It Fl g
 Display the effective group ID as a number.
 .It Fl n
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/id/id.c src.freebsd/coreutils/id/id.c
--- src.orig/coreutils/id/id.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/id/id.c	2023-01-13 18:21:52.665557082 +0100
@@ -43,12 +43,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/mac.h>
-
-#ifdef USE_BSM_AUDIT
-#include <bsm/audit.h>
-#endif
 
 #include <err.h>
 #include <errno.h>
@@ -67,7 +63,6 @@
 static void	auditid(void);
 #endif
 static void	group(struct passwd *, int);
-static void	maclabel(void);
 static void	usage(void);
 static struct passwd *who(char *);
 
@@ -78,14 +73,10 @@
 {
 	struct group *gr;
 	struct passwd *pw;
-	int Gflag, Mflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
-	int Aflag, cflag;
-	int error;
+	int Gflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
 	const char *myname;
-	char loginclass[MAXLOGNAME];
 
-	Gflag = Mflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
-	Aflag = cflag = 0;
+	Gflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
 
 	myname = strrchr(argv[0], '/');
 	myname = (myname != NULL) ? myname + 1 : argv[0];
@@ -99,27 +90,16 @@
 	}
 
 	while ((ch = getopt(argc, argv,
-	    (isgroups || iswhoami) ? "" : "APGMacgnpru")) != -1)
+	    (isgroups || iswhoami) ? "" : "PGagnpru")) != -1)
 		switch(ch) {
-#ifdef USE_BSM_AUDIT
-		case 'A':
-			Aflag = 1;
-			break;
-#endif
 		case 'G':
 			Gflag = 1;
 			break;
-		case 'M':
-			Mflag = 1;
-			break;
 		case 'P':
 			Pflag = 1;
 			break;
 		case 'a':
 			break;
-		case 'c':
-			cflag = 1;
-			break;
 		case 'g':
 			gflag = 1;
 			break;
@@ -144,10 +124,8 @@
 
 	if (iswhoami && argc > 0)
 		usage();
-	if ((cflag || Aflag || Mflag) && argc > 0)
-		usage();
 
-	switch(Aflag + Gflag + Mflag + Pflag + gflag + pflag + uflag) {
+	switch(Gflag + Pflag + gflag + pflag + uflag) {
 	case 1:
 		break;
 	case 0:
@@ -160,24 +138,6 @@
 
 	pw = *argv ? who(*argv) : NULL;
 
-	if (Mflag && pw != NULL)
-		usage();
-
-#ifdef USE_BSM_AUDIT
-	if (Aflag) {
-		auditid();
-		exit(0);
-	}
-#endif
-
-	if (cflag) {
-		error = getloginclass(loginclass, sizeof(loginclass));
-		if (error != 0)
-			err(1, "loginclass");
-		(void)printf("%s\n", loginclass);
-		exit(0);
-	}
-
 	if (gflag) {
 		id = pw ? pw->pw_gid : rflag ? getgid() : getegid();
 		if (nflag && (gr = getgrgid(id)))
@@ -201,11 +161,6 @@
 		exit(0);
 	}
 
-	if (Mflag) {
-		maclabel();
-		exit(0);
-	}
-
 	if (Pflag) {
 		pline(pw);
 		exit(0);
@@ -418,30 +373,6 @@
 	free(groups);
 }
 
-static void
-maclabel(void)
-{
-	char *string;
-	mac_t label;
-	int error;
-
-	error = mac_prepare_process_label(&label);
-	if (error == -1)
-		errx(1, "mac_prepare_type: %s", strerror(errno));
-
-	error = mac_get_proc(label);
-	if (error == -1)
-		errx(1, "mac_get_proc: %s", strerror(errno));
-
-	error = mac_to_text(label, &string);
-	if (error == -1)
-		errx(1, "mac_to_text: %s", strerror(errno));
-
-	(void)printf("%s\n", string);
-	mac_free(label);
-	free(string);
-}
-
 static struct passwd *
 who(char *u)
 {
@@ -471,9 +402,9 @@
 			err(1, "getpwuid");
 	}
 
-	(void)printf("%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n", pw->pw_name,
-			pw->pw_passwd, pw->pw_uid, pw->pw_gid, pw->pw_class,
-			(long)pw->pw_change, (long)pw->pw_expire, pw->pw_gecos,
+	(void)printf("%s:%s:%d:%d:%s:%s:%s\n", pw->pw_name,
+			pw->pw_passwd, pw->pw_uid, pw->pw_gid,
+			pw->pw_gecos,
 			pw->pw_dir, pw->pw_shell);
 }
 
@@ -487,7 +418,7 @@
 	else if (iswhoami)
 		(void)fprintf(stderr, "usage: whoami\n");
 	else
-		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n",
 		    "usage: id [user]",
 #ifdef USE_BSM_AUDIT
 		    "       id -A\n",
@@ -495,9 +426,7 @@
 		    "",
 #endif
 		    "       id -G [-n] [user]",
-		    "       id -M",
 		    "       id -P [user]",
-		    "       id -c",
 		    "       id -g [-nr] [user]",
 		    "       id -p [user]",
 		    "       id -u [-nr] [user]");
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/join/join.c src.freebsd/coreutils/join/join.c
--- src.orig/coreutils/join/join.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/join/join.c	2023-01-13 18:21:52.665557082 +0100
@@ -47,6 +47,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/param.h>
 
 #include <err.h>
@@ -276,9 +277,10 @@
 slurp(INPUT *F)
 {
 	LINE *lp, *lastlp, tmp;
-	size_t len;
+	size_t blen = 0;
+	ssize_t len;
 	int cnt;
-	char *bp, *fieldp;
+	char *bp, *buf = NULL, *fieldp;
 
 	/*
 	 * Read all of the lines from an input file that have the same
@@ -321,21 +323,21 @@
 			F->pushbool = 0;
 			continue;
 		}
-		if ((bp = fgetln(F->fp, &len)) == NULL)
+		if ((len = getline(&buf, &blen, F->fp)) < 0) {
+			free(buf);
 			return;
-		if (lp->linealloc <= len + 1) {
+		}
+		if (lp->linealloc <= (size_t)(len + 1)) {
 			lp->linealloc += MAX(100, len + 1 - lp->linealloc);
 			if ((lp->line =
 			    realloc(lp->line, lp->linealloc)) == NULL)
 				err(1, NULL);
 		}
-		memmove(lp->line, bp, len);
+		memmove(lp->line, buf, len);
 
 		/* Replace trailing newline, if it exists. */
-		if (bp[len - 1] == '\n')
+		if (buf[len - 1] == '\n')
 			lp->line[len - 1] = '\0';
-		else
-			lp->line[len] = '\0';
 		bp = lp->line;
 
 		/* Split the line into fields, allocate space as necessary. */
@@ -359,6 +361,7 @@
 			break;
 		}
 	}
+	free(buf);
 }
 
 static char *
@@ -373,8 +376,10 @@
 		return (NULL);
 	for (tok = s;;) {
 		n = mbrtowc(&c, s, MB_LEN_MAX, NULL);
-		if (n == (size_t)-1 || n == (size_t)-2)
-			errc(1, EILSEQ, NULL);	/* XXX */
+		if (n == (size_t)-1 || n == (size_t)-2) {
+			errno = EILSEQ;
+			err(1, NULL);	/* XXX */
+		}
 		s += n;
 		spanp = delim;
 		do {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ln/ln.c src.freebsd/coreutils/ln/ln.c
--- src.orig/coreutils/ln/ln.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ln/ln.c	2023-01-13 18:21:52.665557082 +0100
@@ -56,6 +56,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 static int	fflag;			/* Unlink existing files. */
 static int	Fflag;			/* Remove empty directories also. */
 static int	hflag;			/* Check new name for symlink first. */
@@ -148,6 +150,7 @@
 	switch(argc) {
 	case 0:
 		usage();
+		break;
 		/* NOTREACHED */
 	case 1:				/* ln source */
 		exit(linkit(argv[0], ".", 1));
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/logname/logname.c src.freebsd/coreutils/logname/logname.c
--- src.orig/coreutils/logname/logname.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/logname/logname.c	2023-01-13 18:21:52.669554691 +0100
@@ -41,7 +41,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <unistd.h>
 #include <stdio.h>
@@ -50,13 +49,10 @@
 void usage(void);
 
 int
-main(int argc, char *argv[] __unused)
+main(int argc, char *argv[] __attribute__((unused)))
 {
 	char *p;
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	if (argc != 1)
 		usage();
 	if ((p = getlogin()) == NULL)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/cmp.c src.freebsd/coreutils/ls/cmp.c
--- src.orig/coreutils/ls/cmp.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/cmp.c	2023-01-13 18:21:52.669554691 +0100
@@ -123,35 +123,6 @@
 }
 
 int
-birthcmp(const FTSENT *a, const FTSENT *b)
-{
-
-	if (b->fts_statp->st_birthtim.tv_sec >
-	    a->fts_statp->st_birthtim.tv_sec)
-		return (1);
-	if (b->fts_statp->st_birthtim.tv_sec <
-	    a->fts_statp->st_birthtim.tv_sec)
-		return (-1);
-	if (b->fts_statp->st_birthtim.tv_nsec >
-	    a->fts_statp->st_birthtim.tv_nsec)
-		return (1);
-	if (b->fts_statp->st_birthtim.tv_nsec <
-	    a->fts_statp->st_birthtim.tv_nsec)
-		return (-1);
-	if (f_samesort)
-		return (strcoll(b->fts_name, a->fts_name));
-	else
-		return (strcoll(a->fts_name, b->fts_name));
-}
-
-int
-revbirthcmp(const FTSENT *a, const FTSENT *b)
-{
-
-	return (birthcmp(b, a));
-}
-
-int
 statcmp(const FTSENT *a, const FTSENT *b)
 {
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/extern.h src.freebsd/coreutils/ls/extern.h
--- src.orig/coreutils/ls/extern.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/extern.h	2023-01-13 18:21:52.669554691 +0100
@@ -36,8 +36,6 @@
 
 int	 acccmp(const FTSENT *, const FTSENT *);
 int	 revacccmp(const FTSENT *, const FTSENT *);
-int	 birthcmp(const FTSENT *, const FTSENT *);
-int	 revbirthcmp(const FTSENT *, const FTSENT *);
 int	 modcmp(const FTSENT *, const FTSENT *);
 int	 revmodcmp(const FTSENT *, const FTSENT *);
 int	 namecmp(const FTSENT *, const FTSENT *);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/ls.1 src.freebsd/coreutils/ls/ls.1
--- src.orig/coreutils/ls/ls.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/ls.1	2023-01-13 18:21:52.669554691 +0100
@@ -40,7 +40,7 @@
 .Nd list directory contents
 .Sh SYNOPSIS
 .Nm
-.Op Fl ABCFGHILPRSTUWZabcdfghiklmnopqrstuwxy1\&,
+.Op Fl ABCFGHILPRSTWabcdfghiklmnpqrstuwxy1\&,
 .Op Fl -color Ns = Ns Ar when
 .Op Fl D Ar format
 .Op Ar
@@ -185,19 +185,10 @@
 option gives even more control over the output format.
 This option is not defined in
 .St -p1003.1-2008 .
-.It Fl U
-Use time when file was created for sorting or printing.
-This option is not defined in
-.St -p1003.1-2008 .
 .It Fl W
 Display whiteouts when scanning directories.
 This option is not defined in
 .St -p1003.1-2008 .
-.It Fl Z
-Display each file's MAC label; see
-.Xr maclabel 7 .
-This option is not defined in
-.St -p1003.1-2008 .
 .It Fl a
 Include directory entries whose names begin with a
 dot
@@ -338,15 +329,6 @@
 or group name in a long
 .Pq Fl l
 output.
-.It Fl o
-Include the file flags in a long
-.Pq Fl l
-output.
-This option is incompatible with
-.St -p1003.1-2008 .
-See
-.Xr chflags 1
-for a list of file flags and their meanings.
 .It Fl p
 Write a slash
 .Pq Ql /
@@ -856,11 +838,10 @@
 .Dl $ ls -l
 .Pp
 In addition to listing the contents of the current working directory in
-long format, show inode numbers, file flags (see
-.Xr chflags 1 ) ,
+long format, show inode numbers,
 and suffix each filename with a symbol representing its file type:
 .Pp
-.Dl $ ls -lioF
+.Dl $ ls -liF
 .Pp
 List the files in
 .Pa /var/log ,
@@ -874,7 +855,6 @@
 .St -p1003.2
 specification.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr getfacl 1 ,
 .Xr sort 1 ,
@@ -889,9 +869,9 @@
 .Xr getfmac 8
 .Sh STANDARDS
 With the exception of options
-.Fl g , n
+.Fl g
 and
-.Fl o ,
+.Fl n,
 the
 .Nm
 utility conforms to
@@ -899,7 +879,7 @@
 and
 .St -p1003.1-2008 .
 The options
-.Fl B , D , G , I , T , U , W , Z , b , h , w , y
+.Fl B , D , G , I , T , W , b , h , w , y
 and
 .Fl ,
 are non-standard extensions.
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/ls.c src.freebsd/coreutils/ls/ls.c
--- src.orig/coreutils/ls/ls.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/ls.c	2023-01-13 18:21:52.669554691 +0100
@@ -49,7 +49,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <sys/mac.h>
+#include <sys/types.h>
 
 #include <ctype.h>
 #include <dirent.h>
@@ -75,6 +75,8 @@
 #include "ls.h"
 #include "extern.h"
 
+#include "compat.h"
+
 /*
  * Upward approximation of the maximum number of characters needed to
  * represent a value of integral type t as a string, excluding the
@@ -98,7 +100,7 @@
 	} while(0)
 
 static void	 display(const FTSENT *, FTSENT *, int);
-static int	 mastercmp(const FTSENT * const *, const FTSENT * const *);
+static int	 mastercmp(const FTSENT **, const FTSENT **);
 static void	 traverse(int, char **, int);
 
 #define	COLOR_OPT	(CHAR_MAX + 1)
@@ -117,12 +119,9 @@
 
 /* flags */
        int f_accesstime;	/* use time of last access */
-       int f_birthtime;		/* use time of birth */
-       int f_flags;		/* show flags associated with a file */
        int f_humanval;		/* show human-readable file sizes */
        int f_inode;		/* print inode */
 static int f_kblocks;		/* print size in kilobytes */
-       int f_label;		/* show MAC label */
 static int f_listdir;		/* list actual directory, not contents */
 static int f_listdot;		/* list files beginning with . */
        int f_longform;		/* long listing format */
@@ -274,7 +273,7 @@
 		colorflag = COLORFLAG_AUTO;
 #endif
 	while ((ch = getopt_long(argc, argv,
-	    "+1ABCD:FGHILPRSTUWXZabcdfghiklmnopqrstuwxy,", long_opts,
+	    "+1ABCD:FGHILPRSTWXabcdfghiklmnpqrstuwxy,", long_opts,
 	    NULL)) != -1) {
 		switch (ch) {
 		/*
@@ -299,21 +298,14 @@
 			f_longform = 0;
 			f_singlecol = 0;
 			break;
-		/* The -c, -u, and -U options override each other. */
+		/* The -c and -u options override each other. */
 		case 'c':
 			f_statustime = 1;
 			f_accesstime = 0;
-			f_birthtime = 0;
 			break;
 		case 'u':
 			f_accesstime = 1;
 			f_statustime = 0;
-			f_birthtime = 0;
-			break;
-		case 'U':
-			f_birthtime = 1;
-			f_accesstime = 0;
-			f_statustime = 0;
 			break;
 		case 'f':
 			f_nosort = 1;
@@ -387,9 +379,6 @@
 		case 'W':
 			f_whiteout = 1;
 			break;
-		case 'Z':
-			f_label = 1;
-			break;
 		case 'b':
 			f_nonprint = 0;
 			f_octal = 0;
@@ -420,9 +409,6 @@
 		case 'n':
 			f_numericonly = 1;
 			break;
-		case 'o':
-			f_flags = 1;
-			break;
 		case 'p':
 			f_slash = 1;
 			f_type = 1;
@@ -458,8 +444,6 @@
 				errx(2, "unsupported --color value '%s' (must be always, auto, or never)",
 				    optarg);
 			break;
-#else
-			warnx("color support not compiled in");
 #endif
 		default:
 		case '?':
@@ -570,8 +554,6 @@
 			sortfcn = revsizecmp;
 		else if (f_accesstime)
 			sortfcn = revacccmp;
-		else if (f_birthtime)
-			sortfcn = revbirthcmp;
 		else if (f_statustime)
 			sortfcn = revstatcmp;
 		else		/* Use modification time. */
@@ -583,8 +565,6 @@
 			sortfcn = sizecmp;
 		else if (f_accesstime)
 			sortfcn = acccmp;
-		else if (f_birthtime)
-			sortfcn = birthcmp;
 		else if (f_statustime)
 			sortfcn = statcmp;
 		else		/* Use modification time. */
@@ -641,7 +621,7 @@
 	 * If not recursing down this tree and don't need stat info, just get
 	 * the names.
 	 */
-	ch_options = !f_recursive && !f_label &&
+	ch_options = !f_recursive &&
 	    options & FTS_NOSTAT ? FTS_NAMEONLY : 0;
 
 	while (errno = 0, (p = fts_read(ftsp)) != NULL)
@@ -692,7 +672,7 @@
  * points to the parent directory of the display list.
  */
 static void
-display(const FTSENT *p, FTSENT *list, int options)
+display(const FTSENT *p, FTSENT *list, int options __attribute__((unused)))
 {
 	struct stat *sp;
 	DISPLAY d;
@@ -701,8 +681,7 @@
 	off_t maxsize;
 	long maxblock;
 	uintmax_t maxinode;
-	u_long btotal, labelstrlen, maxlen, maxnlink;
-	u_long maxlabelstr;
+	u_long btotal, maxlen, maxnlink;
 	u_int sizelen;
 	int maxflags;
 	gid_t maxgroup;
@@ -710,8 +689,9 @@
 	size_t flen, ulen, glen;
 	char *initmax;
 	int entries, needstats;
+	struct passwd *pwentry = NULL;
+	struct group *grentry = NULL;
 	const char *user, *group;
-	char *flags, *labelstr = NULL;
 	char ngroup[STRBUF_SIZEOF(uid_t) + 1];
 	char nuser[STRBUF_SIZEOF(gid_t) + 1];
 	u_long width[9];
@@ -759,7 +739,6 @@
 	maxflags = width[5];
 	maxsize = width[6];
 	maxlen = width[7];
-	maxlabelstr = width[8];
 
 	MAKENINES(maxinode);
 	MAKENINES(maxblock);
@@ -768,7 +747,6 @@
 
 	d.s_size = 0;
 	sizelen = 0;
-	flags = NULL;
 	for (cur = list, entries = 0; cur; cur = cur->fts_link) {
 		if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS) {
 			warnx("%s: %s",
@@ -823,96 +801,34 @@
 					user = nuser;
 					group = ngroup;
 				} else {
-					user = user_from_uid(sp->st_uid, 0);
+					pwentry = getpwuid(sp->st_uid);
 					/*
-					 * user_from_uid(..., 0) only returns
-					 * NULL in OOM conditions.  We could
-					 * format the uid here, but (1) in
-					 * general ls(1) exits on OOM, and (2)
-					 * there is another allocation/exit
-					 * path directly below, which will
-					 * likely exit anyway.
+					 * getpwuid and getgrgid are allowed to
+					 * return NULL when the information is
+					 * not known (i.e. not in /etc/passwd)
+					 * so fall back to numeric IDs if needed
 					 */
-					if (user == NULL)
-						err(1, "user_from_uid");
-					group = group_from_gid(sp->st_gid, 0);
+					if (pwentry == NULL) {
+						(void)snprintf(nuser, sizeof(nuser),
+						    "%u", sp->st_uid);
+						user = nuser;
+					} else
+						user = pwentry->pw_name;
+					grentry = getgrgid(sp->st_gid);
 					/* Ditto. */
-					if (group == NULL)
-						err(1, "group_from_gid");
+					if (grentry == NULL) {
+						(void)snprintf(ngroup, sizeof(ngroup),
+						    "%u", sp->st_gid);
+						group = ngroup;
+					} else
+						group = grentry->gr_name;
 				}
 				if ((ulen = strlen(user)) > maxuser)
 					maxuser = ulen;
 				if ((glen = strlen(group)) > maxgroup)
 					maxgroup = glen;
-				if (f_flags) {
-					flags = fflagstostr(sp->st_flags);
-					if (flags != NULL && *flags == '\0') {
-						free(flags);
-						flags = strdup("-");
-					}
-					if (flags == NULL)
-						err(1, "fflagstostr");
-					flen = strlen(flags);
-					if (flen > (size_t)maxflags)
-						maxflags = flen;
-				} else
-					flen = 0;
-				labelstr = NULL;
-				if (f_label) {
-					char name[PATH_MAX + 1];
-					mac_t label;
-					int error;
-
-					error = mac_prepare_file_label(&label);
-					if (error == -1) {
-						warn("MAC label for %s/%s",
-						    cur->fts_parent->fts_path,
-						    cur->fts_name);
-						goto label_out;
-					}
-
-					if (cur->fts_level == FTS_ROOTLEVEL)
-						snprintf(name, sizeof(name),
-						    "%s", cur->fts_name);
-					else
-						snprintf(name, sizeof(name),
-						    "%s/%s", cur->fts_parent->
-						    fts_accpath, cur->fts_name);
-
-					if (options & FTS_LOGICAL)
-						error = mac_get_file(name,
-						    label);
-					else
-						error = mac_get_link(name,
-						    label);
-					if (error == -1) {
-						warn("MAC label for %s/%s",
-						    cur->fts_parent->fts_path,
-						    cur->fts_name);
-						mac_free(label);
-						goto label_out;
-					}
-
-					error = mac_to_text(label,
-					    &labelstr);
-					if (error == -1) {
-						warn("MAC label for %s/%s",
-						    cur->fts_parent->fts_path,
-						    cur->fts_name);
-						mac_free(label);
-						goto label_out;
-					}
-					mac_free(label);
-label_out:
-					if (labelstr == NULL)
-						labelstr = strdup("-");
-					labelstrlen = strlen(labelstr);
-					if (labelstrlen > maxlabelstr)
-						maxlabelstr = labelstrlen;
-				} else
-					labelstrlen = 0;
 
-				if ((np = malloc(sizeof(NAMES) + labelstrlen +
+				if ((np = malloc(sizeof(NAMES) +
 				    ulen + glen + flen + 4)) == NULL)
 					err(1, "malloc");
 
@@ -929,17 +845,6 @@
 						d.s_size = sizelen;
 				}
 
-				if (f_flags) {
-					np->flags = &np->data[ulen + glen + 2];
-					(void)strcpy(np->flags, flags);
-					free(flags);
-				}
-				if (f_label) {
-					np->label = &np->data[ulen + glen + 2
-					    + (f_flags ? flen + 1 : 0)];
-					(void)strcpy(np->label, labelstr);
-					free(labelstr);
-				}
 				cur->fts_pointer = np;
 			}
 		}
@@ -962,7 +867,6 @@
 		d.btotal = btotal;
 		d.s_block = snprintf(NULL, 0, "%lu", howmany(maxblock, blocksize));
 		d.s_flags = maxflags;
-		d.s_label = maxlabelstr;
 		d.s_group = maxgroup;
 		d.s_inode = snprintf(NULL, 0, "%ju", maxinode);
 		d.s_nlink = snprintf(NULL, 0, "%lu", maxnlink);
@@ -989,7 +893,7 @@
  * All other levels use the sort function.  Error entries remain unsorted.
  */
 static int
-mastercmp(const FTSENT * const *a, const FTSENT * const *b)
+mastercmp(const FTSENT **a, const FTSENT **b)
 {
 	int a_info, b_info;
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/ls.h src.freebsd/coreutils/ls/ls.h
--- src.orig/coreutils/ls/ls.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/ls.h	2023-01-13 18:21:52.669554691 +0100
@@ -42,8 +42,6 @@
 extern long blocksize;		/* block size units */
 
 extern int f_accesstime;	/* use time of last access */
-extern int f_birthtime;	/* use time of file creation */
-extern int f_flags;		/* show flags associated with a file */
 extern int f_humanval;		/* show human-readable file sizes */
 extern int f_label;		/* show MAC label */
 extern int f_inode;		/* print inode */
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/print.c src.freebsd/coreutils/ls/print.c
--- src.orig/coreutils/ls/print.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/print.c	2023-01-13 18:21:52.669554691 +0100
@@ -42,13 +42,11 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
-#include <sys/acl.h>
 
 #include <err.h>
 #include <errno.h>
 #include <fts.h>
 #include <langinfo.h>
-#include <libutil.h>
 #include <limits.h>
 #include <stdio.h>
 #include <stdint.h>
@@ -66,6 +64,8 @@
 #include "ls.h"
 #include "extern.h"
 
+#include "compat.h"
+
 static int	printaname(const FTSENT *, u_long, u_long);
 static void	printdev(size_t, dev_t);
 static void	printlink(const FTSENT *);
@@ -78,7 +78,6 @@
 static void	endcolor(int);
 static int	colortype(mode_t);
 #endif
-static void	aclmode(char *, const FTSENT *);
 
 #define	IS_NOPRINT(p)	((p)->fts_number == NO_PRINT)
 
@@ -231,23 +230,16 @@
 			(void)printf("%*jd ",
 			    dp->s_block, howmany(sp->st_blocks, blocksize));
 		strmode(sp->st_mode, buf);
-		aclmode(buf, p);
 		np = p->fts_pointer;
 		(void)printf("%s %*ju %-*s  %-*s  ", buf, dp->s_nlink,
 		    (uintmax_t)sp->st_nlink, dp->s_user, np->user, dp->s_group,
 		    np->group);
-		if (f_flags)
-			(void)printf("%-*s ", dp->s_flags, np->flags);
-		if (f_label)
-			(void)printf("%-*s ", dp->s_label, np->label);
 		if (S_ISCHR(sp->st_mode) || S_ISBLK(sp->st_mode))
 			printdev(dp->s_size, sp->st_rdev);
 		else
 			printsize(dp->s_size, sp->st_size);
 		if (f_accesstime)
 			printtime(sp->st_atime);
-		else if (f_birthtime)
-			printtime(sp->st_birthtime);
 		else if (f_statustime)
 			printtime(sp->st_ctime);
 		else
@@ -464,8 +456,11 @@
 	const char *format;
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	if (now == 0)
 		now = time(NULL);
 
@@ -511,9 +506,6 @@
 	case S_IFSOCK:
 		(void)putchar('=');
 		return (1);
-	case S_IFWHT:
-		(void)putchar('%');
-		return (1);
 	default:
 		break;
 	}
@@ -617,7 +609,7 @@
 	switch (mode & S_IFMT) {
 	case S_IFDIR:
 		if (mode & S_IWOTH)
-			if (mode & S_ISTXT)
+			if (mode & S_ISVTX)
 				printcolor(C_WSDIR);
 			else
 				printcolor(C_WDIR);
@@ -754,74 +746,3 @@
 	} else
 		(void)printf("%*jd ", (u_int)width, bytes);
 }
-
-/*
- * Add a + after the standard rwxrwxrwx mode if the file has an
- * ACL. strmode() reserves space at the end of the string.
- */
-static void
-aclmode(char *buf, const FTSENT *p)
-{
-	char name[MAXPATHLEN + 1];
-	int ret, trivial;
-	static dev_t previous_dev = NODEV;
-	static int supports_acls = -1;
-	static int type = ACL_TYPE_ACCESS;
-	acl_t facl;
-
-	/*
-	 * XXX: ACLs are not supported on whiteouts and device files
-	 * residing on UFS.
-	 */
-	if (S_ISCHR(p->fts_statp->st_mode) || S_ISBLK(p->fts_statp->st_mode) ||
-	    S_ISWHT(p->fts_statp->st_mode))
-		return;
-
-	if (previous_dev == p->fts_statp->st_dev && supports_acls == 0)
-		return;
-
-	if (p->fts_level == FTS_ROOTLEVEL)
-		snprintf(name, sizeof(name), "%s", p->fts_name);
-	else
-		snprintf(name, sizeof(name), "%s/%s",
-		    p->fts_parent->fts_accpath, p->fts_name);
-
-	if (previous_dev != p->fts_statp->st_dev) {
-		previous_dev = p->fts_statp->st_dev;
-		supports_acls = 0;
-
-		ret = lpathconf(name, _PC_ACL_NFS4);
-		if (ret > 0) {
-			type = ACL_TYPE_NFS4;
-			supports_acls = 1;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("%s", name);
-			return;
-		}
-		if (supports_acls == 0) {
-			ret = lpathconf(name, _PC_ACL_EXTENDED);
-			if (ret > 0) {
-				type = ACL_TYPE_ACCESS;
-				supports_acls = 1;
-			} else if (ret < 0 && errno != EINVAL) {
-				warn("%s", name);
-				return;
-			}
-		}
-	}
-	if (supports_acls == 0)
-		return;
-	facl = acl_get_link_np(name, type);
-	if (facl == NULL) {
-		warn("%s", name);
-		return;
-	}
-	if (acl_is_trivial_np(facl, &trivial)) {
-		acl_free(facl);
-		warn("%s", name);
-		return;
-	}
-	if (!trivial)
-		buf[10] = '+';
-	acl_free(facl);
-}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/ls/util.c src.freebsd/coreutils/ls/util.c
--- src.orig/coreutils/ls/util.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/ls/util.c	2023-01-13 18:21:52.669554691 +0100
@@ -227,9 +227,9 @@
 {
 	(void)fprintf(stderr,
 #ifdef COLORLS
-	"usage: ls [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuwxy1,] [--color=when] [-D format]"
+	"usage: ls [-ABCFGHILPRSTWabcdfghiklmnpqrstuwxy1,] [--color=when] [-D format]"
 #else
-	"usage: ls [-ABCFHILPRSTUWZabcdfghiklmnopqrstuwxy1,] [-D format]"
+	"usage: ls [-ABCFHILPRSTWabcdfghiklmnpqrstuwxy1,] [-D format]"
 #endif
 		      " [file ...]\n");
 	exit(1);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/mkdir/mkdir.c src.freebsd/coreutils/mkdir/mkdir.c
--- src.orig/coreutils/mkdir/mkdir.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/mkdir/mkdir.c	2023-01-13 18:21:52.669554691 +0100
@@ -55,6 +55,8 @@
 #include <sysexits.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 static int	build(char *, mode_t);
 static void	usage(void);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/mkfifo/mkfifo.c src.freebsd/coreutils/mkfifo/mkfifo.c
--- src.orig/coreutils/mkfifo/mkfifo.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/mkfifo/mkfifo.c	2023-01-13 18:21:52.669554691 +0100
@@ -53,6 +53,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 #define	BASEMODE	S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | \
 			S_IROTH | S_IWOTH
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/mknod/mknod.c src.freebsd/coreutils/mknod/mknod.c
--- src.orig/coreutils/mknod/mknod.c	2022-05-12 06:54:00.000000000 +0200
+++ src.freebsd/coreutils/mknod/mknod.c	2023-01-13 18:21:52.669554691 +0100
@@ -48,6 +48,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 
 #include <err.h>
 #include <errno.h>
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/mv/mv.c src.freebsd/coreutils/mv/mv.c
--- src.orig/coreutils/mv/mv.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/mv/mv.c	2023-01-13 18:21:52.669554691 +0100
@@ -47,12 +47,12 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/statvfs.h>
 
 #include <err.h>
 #include <errno.h>
@@ -67,6 +67,8 @@
 #include <sysexits.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 /* Exit code for a failed exec. */
 #define EXEC_FAILED 127
 
@@ -76,8 +78,6 @@
 static int	do_move(const char *, const char *);
 static int	fastcopy(const char *, const char *, struct stat *);
 static void	usage(void);
-static void	preserve_fd_acls(int source_fd, int dest_fd, const char *source_path,
-		    const char *dest_path);
 
 int
 main(int argc, char *argv[])
@@ -178,6 +178,8 @@
 	struct stat sb;
 	int ask, ch, first;
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/*
 	 * Check access.  If interactive and file exists, ask user if it
@@ -203,10 +205,15 @@
 			ask = 1;
 		} else if (access(to, W_OK) && !stat(to, &sb) && isatty(STDIN_FILENO)) {
 			strmode(sb.st_mode, modep);
+			pw = getpwuid(sb.st_uid);
+			if (pw == NULL)
+				err(EXIT_FAILURE, "getpwuid");
+			gr = getgrgid(sb.st_gid);
+			if (gr == NULL)
+				err(EXIT_FAILURE, "getgrgid");
 			(void)fprintf(stderr, "override %s%s%s/%s for %s? %s",
 			    modep + 1, modep[9] == ' ' ? "" : " ",
-			    user_from_uid((unsigned long)sb.st_uid, 0),
-			    group_from_gid((unsigned long)sb.st_gid, 0), to, YESNO);
+			    pw->pw_name, gr->gr_name, to, YESNO);
 			ask = 1;
 		}
 		if (ask) {
@@ -231,7 +238,6 @@
 	}
 
 	if (errno == EXDEV) {
-		struct statfs sfs;
 		char path[PATH_MAX];
 
 		/*
@@ -248,11 +254,6 @@
 				warn("cannot resolve %s: %s", from, path);
 				return (1);
 			}
-			if (!statfs(path, &sfs) &&
-			    !strcmp(path, sfs.f_mntonname)) {
-				warnx("cannot rename a mount point");
-				return (1);
-			}
 		}
 	} else {
 		warn("rename %s to %s", from, to);
@@ -280,7 +281,6 @@
 	static char *bp = NULL;
 	mode_t oldmode;
 	int nread, from_fd, to_fd;
-	struct stat tsb;
 
 	if ((from_fd = open(from, O_RDONLY, 0)) < 0) {
 		warn("fastcopy: open() failed (from): %s", from);
@@ -326,32 +326,7 @@
 	}
 	if (fchmod(to_fd, sbp->st_mode))
 		warn("%s: set mode (was: 0%03o)", to, oldmode);
-	/*
-	 * POSIX 1003.2c states that if _POSIX_ACL_EXTENDED is in effect
-	 * for dest_file, then its ACLs shall reflect the ACLs of the
-	 * source_file.
-	 */
-	preserve_fd_acls(from_fd, to_fd, from, to);
 	(void)close(from_fd);
-	/*
-	 * XXX
-	 * NFS doesn't support chflags; ignore errors unless there's reason
-	 * to believe we're losing bits.  (Note, this still won't be right
-	 * if the server supports flags and we were trying to *remove* flags
-	 * on a file that we copied, i.e., that we didn't create.)
-	 */
-	if (fstat(to_fd, &tsb) == 0) {
-		if ((sbp->st_flags  & ~UF_ARCHIVE) !=
-		    (tsb.st_flags & ~UF_ARCHIVE)) {
-			if (fchflags(to_fd,
-			    sbp->st_flags | (tsb.st_flags & UF_ARCHIVE)))
-				if (errno != EOPNOTSUPP ||
-				    ((sbp->st_flags & ~UF_ARCHIVE) != 0))
-					warn("%s: set flags (was: 0%07o)",
-					    to, sbp->st_flags);
-		}
-	} else
-		warn("%s: cannot stat", to);
 
 	ts[0] = sbp->st_atim;
 	ts[1] = sbp->st_mtim;
@@ -451,59 +426,6 @@
 }
 
 static void
-preserve_fd_acls(int source_fd, int dest_fd, const char *source_path,
-    const char *dest_path)
-{
-	acl_t acl;
-	acl_type_t acl_type;
-	int acl_supported = 0, ret, trivial;
-
-	ret = fpathconf(source_fd, _PC_ACL_NFS4);
-	if (ret > 0 ) {
-		acl_supported = 1;
-		acl_type = ACL_TYPE_NFS4;
-	} else if (ret < 0 && errno != EINVAL) {
-		warn("fpathconf(..., _PC_ACL_NFS4) failed for %s",
-		    source_path);
-		return;
-	}
-	if (acl_supported == 0) {
-		ret = fpathconf(source_fd, _PC_ACL_EXTENDED);
-		if (ret > 0 ) {
-			acl_supported = 1;
-			acl_type = ACL_TYPE_ACCESS;
-		} else if (ret < 0 && errno != EINVAL) {
-			warn("fpathconf(..., _PC_ACL_EXTENDED) failed for %s",
-			    source_path);
-			return;
-		}
-	}
-	if (acl_supported == 0)
-		return;
-
-	acl = acl_get_fd_np(source_fd, acl_type);
-	if (acl == NULL) {
-		warn("failed to get acl entries for %s", source_path);
-		return;
-	}
-	if (acl_is_trivial_np(acl, &trivial)) {
-		warn("acl_is_trivial() failed for %s", source_path);
-		acl_free(acl);
-		return;
-	}
-	if (trivial) {
-		acl_free(acl);
-		return;
-	}
-	if (acl_set_fd_np(dest_fd, acl, acl_type) < 0) {
-		warn("failed to set acl entries for %s", dest_path);
-		acl_free(acl);
-		return;
-	}
-	acl_free(acl);
-}
-
-static void
 usage(void)
 {
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/nl/nl.c src.freebsd/coreutils/nl/nl.c
--- src.orig/coreutils/nl/nl.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/nl/nl.c	2023-01-13 18:21:52.669554691 +0100
@@ -151,15 +151,19 @@
 			break;
 		case 'd':
 			clen = mbrlen(optarg, MB_CUR_MAX, NULL);
-			if (clen == (size_t)-1 || clen == (size_t)-2)
-				errc(EXIT_FAILURE, EILSEQ, NULL);
+			if (clen == (size_t)-1 || clen == (size_t)-2) {
+				errno = EILSEQ;
+				err(EXIT_FAILURE, NULL);
+			}
 			if (clen != 0) {
 				memcpy(delim1, optarg, delim1len = clen);
 				clen = mbrlen(optarg + delim1len,
 				    MB_CUR_MAX, NULL);
 				if (clen == (size_t)-1 ||
-				    clen == (size_t)-2)
-					errc(EXIT_FAILURE, EILSEQ, NULL);
+				    clen == (size_t)-2) {
+					errno = EILSEQ;
+					err(EXIT_FAILURE, NULL);
+				}
 				if (clen != 0) {
 					memcpy(delim2, optarg + delim1len,
 					    delim2len = clen);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/pr/pr.c src.freebsd/coreutils/pr/pr.c
--- src.orig/coreutils/pr/pr.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/pr/pr.c	2023-01-13 18:21:52.673552299 +0100
@@ -65,6 +65,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <time.h>
 
 #include "pr.h"
 #include "extern.h"
@@ -1547,7 +1548,7 @@
  * terminate():	when a SIGINT is recvd
  */
 void
-terminate(int which_sig __unused)
+terminate(int which_sig __attribute__((unused)))
 {
 	flsh_errs();
 	exit(1);
@@ -1857,7 +1858,9 @@
 
 	(void) setlocale(LC_TIME, (Lflag != NULL) ? Lflag : "");
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 	timefrmt = strdup(d_first ? TIMEFMTD : TIMEFMTM);
 
 	return(0);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/printenv/printenv.c src.freebsd/coreutils/printenv/printenv.c
--- src.orig/coreutils/printenv/printenv.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/printenv/printenv.c	2023-01-13 18:21:52.673552299 +0100
@@ -46,7 +46,6 @@
 
 #include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -69,9 +68,6 @@
 	size_t len;
 	int ch;
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	while ((ch = getopt(argc, argv, "")) != -1)
 		switch(ch) {
 		case '?':
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/rm/rm.1 src.freebsd/coreutils/rm/rm.1
--- src.orig/coreutils/rm/rm.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/rm/rm.1	2023-01-13 18:21:52.673552299 +0100
@@ -42,7 +42,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl f | i
-.Op Fl dIRrvWx
+.Op Fl dIRrvx
 .Ar
 .Nm unlink
 .Op Fl -
@@ -110,11 +110,6 @@
 .Fl R .
 .It Fl v
 Be verbose when deleting files, showing them as they are removed.
-.It Fl W
-Attempt to undelete the named files.
-Currently, this option can only be used to recover
-files covered by whiteouts in a union file system (see
-.Xr undelete 2 ) .
 .It Fl x
 When removing a hierarchy, do not cross mount points.
 .El
@@ -211,9 +206,7 @@
 .Fx 13
 and may be removed in the future.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr rmdir 1 ,
-.Xr undelete 2 ,
 .Xr unlink 2 ,
 .Xr fts 3 ,
 .Xr getopt 3 ,
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/rm/rm.c src.freebsd/coreutils/rm/rm.c
--- src.orig/coreutils/rm/rm.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/rm/rm.c	2023-01-13 18:21:52.673552299 +0100
@@ -54,13 +54,16 @@
 #include <grp.h>
 #include <locale.h>
 #include <pwd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
 
-static int dflag, eval, fflag, iflag, vflag, Wflag, stdin_ok;
+#include "compat.h"
+
+static int dflag, eval, fflag, iflag, vflag, stdin_ok;
 static int rflag, Iflag, xflag;
 static uid_t uid;
 static volatile sig_atomic_t info;
@@ -71,7 +74,7 @@
 static void	checkslash(char **);
 static void	rm_file(char **);
 static void	rm_tree(char **);
-static void siginfo(int __unused);
+static void siginfo(int __attribute__((unused)));
 static void	usage(void);
 
 /*
@@ -109,7 +112,7 @@
 	}
 
 	rflag = xflag = 0;
-	while ((ch = getopt(argc, argv, "dfiIPRrvWx")) != -1)
+	while ((ch = getopt(argc, argv, "dfiIPRrvx")) != -1)
 		switch(ch) {
 		case 'd':
 			dflag = 1;
@@ -135,9 +138,6 @@
 		case 'v':
 			vflag = 1;
 			break;
-		case 'W':
-			Wflag = 1;
-			break;
 		case 'x':
 			xflag = 1;
 			break;
@@ -198,8 +198,6 @@
 	flags = FTS_PHYSICAL;
 	if (!needstat)
 		flags |= FTS_NOSTAT;
-	if (Wflag)
-		flags |= FTS_WHITEOUT;
 	if (xflag)
 		flags |= FTS_XDEV;
 	if (!(fts = fts_open(argv, flags, NULL))) {
@@ -238,12 +236,6 @@
 				(void)fts_set(fts, p, FTS_SKIP);
 				p->fts_number = SKIPPED;
 			}
-			else if (!uid &&
-				 (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-				 !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-				 lchflags(p->fts_accpath,
-					 p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE)) < 0)
-				goto err;
 			continue;
 		case FTS_DP:
 			/* Post-order: see if user skipped. */
@@ -256,77 +248,51 @@
 				continue;
 		}
 
-		rval = 0;
-		if (!uid &&
-		    (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-		    !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)))
-			rval = lchflags(p->fts_accpath,
-				       p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE));
-		if (rval == 0) {
+		/*
+		 * If we can't read or search the directory, may still be
+		 * able to remove it.  Don't print out the un{read,search}able
+		 * message unless the remove fails.
+		 */
+		switch (p->fts_info) {
+		case FTS_DP:
+		case FTS_DNR:
+			rval = rmdir(p->fts_accpath);
+			if (rval == 0 || (fflag && errno == ENOENT)) {
+				if (rval == 0 && vflag)
+					(void)printf("%s\n",
+					    p->fts_path);
+				if (rval == 0 && info) {
+					info = 0;
+					(void)printf("%s\n",
+					    p->fts_path);
+				}
+				continue;
+			}
+			break;
+		case FTS_NS:
 			/*
-			 * If we can't read or search the directory, may still be
-			 * able to remove it.  Don't print out the un{read,search}able
-			 * message unless the remove fails.
+			 * Assume that since fts_read() couldn't stat
+			 * the file, it can't be unlinked.
 			 */
-			switch (p->fts_info) {
-			case FTS_DP:
-			case FTS_DNR:
-				rval = rmdir(p->fts_accpath);
-				if (rval == 0 || (fflag && errno == ENOENT)) {
-					if (rval == 0 && vflag)
-						(void)printf("%s\n",
-						    p->fts_path);
-					if (rval == 0 && info) {
-						info = 0;
-						(void)printf("%s\n",
-						    p->fts_path);
-					}
-					continue;
-				}
-				break;
-
-			case FTS_W:
-				rval = undelete(p->fts_accpath);
-				if (rval == 0 && (fflag && errno == ENOENT)) {
-					if (vflag)
-						(void)printf("%s\n",
-						    p->fts_path);
-					if (info) {
-						info = 0;
-						(void)printf("%s\n",
-						    p->fts_path);
-					}
-					continue;
-				}
-				break;
-
-			case FTS_NS:
-				/*
-				 * Assume that since fts_read() couldn't stat
-				 * the file, it can't be unlinked.
-				 */
-				if (fflag)
-					continue;
-				/* FALLTHROUGH */
-
-			case FTS_F:
-			case FTS_NSOK:
-			default:
-				rval = unlink(p->fts_accpath);
-				if (rval == 0 || (fflag && errno == ENOENT)) {
-					if (rval == 0 && vflag)
-						(void)printf("%s\n",
-						    p->fts_path);
-					if (rval == 0 && info) {
-						info = 0;
-						(void)printf("%s\n",
-						    p->fts_path);
-					}
-					continue;
+			if (fflag)
+				continue;
+			/* FALLTHROUGH */
+		case FTS_F:
+		case FTS_NSOK:
+		default:
+			rval = unlink(p->fts_accpath);
+			if (rval == 0 || (fflag && errno == ENOENT)) {
+				if (rval == 0 && vflag)
+					(void)printf("%s\n",
+					    p->fts_path);
+				if (rval == 0 && info) {
+					info = 0;
+					(void)printf("%s\n",
+					    p->fts_path);
 				}
+				continue;
 			}
 		}
-err:
 		warn("%s", p->fts_path);
 		eval = 1;
 	}
@@ -349,18 +315,10 @@
 	while ((f = *argv++) != NULL) {
 		/* Assume if can't stat the file, can't unlink it. */
 		if (lstat(f, &sb)) {
-			if (Wflag) {
-				sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
-			} else {
-				if (!fflag || errno != ENOENT) {
-					warn("%s", f);
-					eval = 1;
-				}
-				continue;
+			if (!fflag || errno != ENOENT) {
+				warn("%s", f);
+				eval = 1;
 			}
-		} else if (Wflag) {
-			warnx("%s: %s", f, strerror(EEXIST));
-			eval = 1;
 			continue;
 		}
 
@@ -369,21 +327,12 @@
 			eval = 1;
 			continue;
 		}
-		if (!fflag && !S_ISWHT(sb.st_mode) && !check(f, f, &sb))
+		if (!fflag && !check(f, f, &sb))
 			continue;
-		rval = 0;
-		if (!uid && !S_ISWHT(sb.st_mode) &&
-		    (sb.st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-		    !(sb.st_flags & (SF_APPEND|SF_IMMUTABLE)))
-			rval = lchflags(f, sb.st_flags & ~(UF_APPEND|UF_IMMUTABLE));
-		if (rval == 0) {
-			if (S_ISWHT(sb.st_mode))
-				rval = undelete(f);
-			else if (S_ISDIR(sb.st_mode))
-				rval = rmdir(f);
-			else
-				rval = unlink(f);
-		}
+		if (S_ISDIR(sb.st_mode))
+			rval = rmdir(f);
+		else
+			rval = unlink(f);
 		if (rval && (!fflag || errno != ENOENT)) {
 			warn("%s", f);
 			eval = 1;
@@ -401,7 +350,9 @@
 check(const char *path, const char *name, struct stat *sp)
 {
 	int ch, first;
-	char modep[15], *flagsp;
+	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/* Check -i first. */
 	if (iflag)
@@ -413,21 +364,20 @@
 		 * because their permissions are meaningless.  Check stdin_ok
 		 * first because we may not have stat'ed the file.
 		 */
-		if (!stdin_ok || S_ISLNK(sp->st_mode) ||
-		    (!access(name, W_OK) &&
-		    !(sp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-		    (!(sp->st_flags & (UF_APPEND|UF_IMMUTABLE)) || !uid)))
+		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK))
 			return (1);
 		strmode(sp->st_mode, modep);
-		if ((flagsp = fflagstostr(sp->st_flags)) == NULL)
-			err(1, "fflagstostr");
-		(void)fprintf(stderr, "override %s%s%s/%s %s%sfor %s? ",
+		pw = getpwuid(sp->st_uid);
+		if (pw == NULL)
+			err(EXIT_FAILURE, "getpwuid");
+		gr = getgrgid(sp->st_gid);
+		if (gr == NULL)
+			err(EXIT_FAILURE, "getgrgid");
+		(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
 		    modep + 1, modep[10] == ' ' ? "" : " ",
-		    user_from_uid(sp->st_uid, 0),
-		    group_from_gid(sp->st_gid, 0),
-		    *flagsp ? flagsp : "", *flagsp ? " " : "",
+		    pw->pw_name,
+		    gr->gr_name,
 		    path);
-		free(flagsp);
 	}
 	(void)fflush(stderr);
 
@@ -544,7 +494,7 @@
 }
 
 static void
-siginfo(int sig __unused)
+siginfo(int sig __attribute__((unused)))
 {
 
 	info = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/seq/seq.c src.freebsd/coreutils/seq/seq.c
--- src.orig/coreutils/seq/seq.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/seq/seq.c	2023-01-13 18:21:52.673552299 +0100
@@ -52,6 +52,8 @@
 #define ISEXP(c)	((int)(c) == 'e' || (int)(c) == 'E')
 #define ISODIGIT(c)	((int)(c) >= '0' && (int)(c) <= '7')
 
+extern char *__progname;
+
 /* Globals */
 
 static const char *decimal_point = ".";	/* default */
@@ -143,7 +145,7 @@
 	if (errflg) {
 		fprintf(stderr,
 		    "usage: %s [-w] [-f format] [-s string] [-t string] [first [incr]] last\n",
-		    getprogname());
+		    __progname);
 		exit(1);
 	}
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sleep/sleep.1 src.freebsd/coreutils/sleep/sleep.1
--- src.orig/coreutils/sleep/sleep.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/sleep/sleep.1	2023-01-13 18:21:52.673552299 +0100
@@ -52,7 +52,7 @@
 .Nm
 command receives a signal, it takes the standard action.
 When the
-.Dv SIGINFO
+.Dv SIGUSR1
 signal is received, the estimate of the amount of seconds left to
 sleep is printed on the standard output.
 .Sh IMPLEMENTATION NOTES
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sleep/sleep.c src.freebsd/coreutils/sleep/sleep.c
--- src.orig/coreutils/sleep/sleep.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/sleep/sleep.c	2023-01-13 18:21:52.673552299 +0100
@@ -41,7 +41,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <limits.h>
@@ -50,11 +49,13 @@
 #include <stdlib.h>
 #include <time.h>
 
+#include "compat.h"
+
 static void usage(void);
 
 static volatile sig_atomic_t report_requested;
 static void
-report_request(int signo __unused)
+report_request(int signo __attribute__((unused)))
 {
 
 	report_requested = 1;
@@ -65,12 +66,8 @@
 {
 	struct timespec time_to_sleep;
 	double d;
-	time_t original;
 	char buf[2];
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	if (argc != 2)
 		usage();
 
@@ -80,7 +77,7 @@
 		usage();
 	if (d <= 0)
 		return (0);
-	original = time_to_sleep.tv_sec = (time_t)d;
+	time_to_sleep.tv_sec = (time_t)d;
 	time_to_sleep.tv_nsec = 1e9 * (d - time_to_sleep.tv_sec);
 
 	signal(SIGINFO, report_request);
@@ -91,12 +88,7 @@
 	 * attaches. This is a bug but it is hard to fix.
 	 */
 	while (nanosleep(&time_to_sleep, &time_to_sleep) != 0) {
-		if (report_requested) {
-			/* Reporting does not bother with nanoseconds. */
-			warnx("about %d second(s) left out of the original %d",
-			    (int)time_to_sleep.tv_sec, (int)original);
-			report_requested = 0;
-		} else if (errno != EINTR)
+		if (errno != EINTR)
 			err(1, "nanosleep");
 	}
 	return (0);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/bwstring.c src.freebsd/coreutils/sort/bwstring.c
--- src.orig/coreutils/sort/bwstring.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/bwstring.c	2023-01-13 18:21:52.673552299 +0100
@@ -478,40 +478,100 @@
 bwsfgetln(FILE *f, size_t *len, bool zero_ended, struct reader_buffer *rb)
 {
 	wint_t eols;
+	wchar_t sbuf[256];
 
 	eols = zero_ended ? btowc('\0') : btowc('\n');
 
 	if (!zero_ended && (mb_cur_max > 1)) {
-		wchar_t *ret;
-
-		ret = fgetwln(f, len);
-
-		if (ret == NULL) {
+		wchar_t *buf = NULL;
+		wchar_t *wptr;
+		size_t bufsz = 0;
+		size_t wlen;
+		struct bwstring *ret;
+
+		wptr = fgetws(sbuf, sizeof(sbuf) / sizeof(wchar_t), f);
+		if (wptr) {
+			wlen = wcslen(wptr);
+			if (wptr[wlen - 1] == (wchar_t)eols)
+				return bwssbdup(wptr, wlen - 1);
+			if (feof(f))
+				return bwssbdup(wptr, wlen);
+		} else {
 			if (!feof(f))
 				err(2, NULL);
 			return (NULL);
 		}
-		if (*len > 0) {
-			if (ret[*len - 1] == (wchar_t)eols)
-				--(*len);
+		bufsz = wlen + 256;
+		buf = malloc(bufsz * sizeof(wchar_t));
+		memcpy(buf, wptr, wlen * sizeof(wchar_t));
+		for (;;) {
+			wchar_t *nptr = fgetws(&buf[wlen], 256, f);
+			if (!nptr) {
+				if (feof(f))
+					break;
+				free(buf);
+				err(2, NULL);
+			}
+			wlen += wcslen(nptr);
+			if (buf[wlen - 1] == (wchar_t)eols) {
+				--wlen;
+				break;
+			}
+			if (feof(f))
+				break;
+			bufsz += 256;
+			buf = realloc(buf, bufsz);
 		}
-		return (bwssbdup(ret, *len));
-
-	} else if (!zero_ended && (mb_cur_max == 1)) {
-		char *ret;
 
-		ret = fgetln(f, len);
-
-		if (ret == NULL) {
+		ret = bwssbdup(buf, wlen);
+		free(buf);
+		return ret;
+
+	} else if (!zero_ended && (MB_CUR_MAX == 1)) {
+		char *buf = NULL;
+		char *bptr;
+		size_t bufsz = 0;
+		size_t blen;
+		struct bwstring *ret;
+
+		bptr = fgets((char *)sbuf, sizeof(sbuf), f);
+		if (bptr) {
+			blen = strlen(bptr);
+			if (bptr[blen - 1] == '\n')
+				return bwscsbdup((unsigned char *)bptr, blen - 1);
+			if (feof(f))
+				return bwscsbdup((unsigned char *)bptr, blen);
+		} else {
 			if (!feof(f))
 				err(2, NULL);
 			return (NULL);
 		}
-		if (*len > 0) {
-			if (ret[*len - 1] == '\n')
-				--(*len);
+
+		bufsz = blen + 256;
+		buf = malloc(bufsz);
+		memcpy(buf, bptr, blen);
+		for (;;) {
+			char *nptr = fgets(&buf[blen], 256, f);
+			if (!f) {
+				if (feof(f))
+					break;
+				free(buf);
+				err(2, NULL);
+			}
+			blen += strlen(nptr);
+			if (buf[blen - 1] == '\n') {
+				--blen;
+				break;
+			}
+			if (feof(f))
+				break;
+			bufsz += 256;
+			buf = realloc(buf, bufsz);
 		}
-		return (bwscsbdup((unsigned char *)ret, *len));
+
+		ret = bwscsbdup((unsigned char *)buf, blen);
+		free(buf);
+		return ret;
 
 	} else {
 		*len = 0;
@@ -537,7 +597,7 @@
 						return (NULL);
 					goto line_read_done;
 				}
-				if (c == eols)
+				if ((wint_t)c == eols)
 					goto line_read_done;
 
 				if (*len + 1 >= rb->fgetwln_z_buffer_size) {
@@ -560,7 +620,7 @@
 						return (NULL);
 					goto line_read_done;
 				}
-				if (c == eols)
+				if ((wint_t)c == eols)
 					goto line_read_done;
 
 				if (*len + 1 >= rb->fgetwln_z_buffer_size) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/coll.c src.freebsd/coreutils/sort/coll.c
--- src.orig/coreutils/sort/coll.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/coll.c	2023-01-13 18:45:55.656361796 +0100
@@ -37,7 +37,6 @@
 #include <langinfo.h>
 #include <limits.h>
 #include <math.h>
-#include <md5.h>
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
@@ -60,7 +59,9 @@
 static int monthcoll(struct key_value*, struct key_value *, size_t offset);
 static int numcoll(struct key_value*, struct key_value *, size_t offset);
 static int hnumcoll(struct key_value*, struct key_value *, size_t offset);
+#ifndef WITHOUT_LIBCRYPTO
 static int randomcoll(struct key_value*, struct key_value *, size_t offset);
+#endif
 static int versioncoll(struct key_value*, struct key_value *, size_t offset);
 
 /*
@@ -473,8 +474,10 @@
 		return (gnumcoll);
 	else if (sm->Mflag)
 		return (monthcoll);
+#ifndef WITHOUT_LIBCRYPTO
 	else if (sm->Rflag)
 		return (randomcoll);
+#endif
 	else if (sm->Vflag)
 		return (versioncoll);
 	else
@@ -607,18 +610,18 @@
  * Compare two sort list items, according to the sort specs.
  */
 int
-list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll(const void *ss1, const void *ss2)
 {
 
-	return (list_coll_offset(ss1, ss2, 0));
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, 0));
 }
 
 #define	LSCDEF(N)							\
 static int 								\
-list_coll_##N(struct sort_list_item **ss1, struct sort_list_item **ss2)	\
+list_coll_##N(const void *ss1, const void *ss2)	\
 {									\
 									\
-	return (list_coll_offset(ss1, ss2, N));				\
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, N)); \
 }
 
 LSCDEF(1)
@@ -662,9 +665,10 @@
  * Compare two sort list items, only by their original string.
  */
 int
-list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll_by_str_only(const void *a1, const void *a2)
 {
-
+	struct sort_list_item **ss1 = (struct sort_list_item **)a1;
+	struct sort_list_item **ss2 = (struct sort_list_item **)a2;
 	return (top_level_str_coll(((*ss1)->str), ((*ss2)->str)));
 }
 
@@ -811,7 +815,7 @@
  */
 static int
 numcoll_impl(struct key_value *kv1, struct key_value *kv2,
-    size_t offset __unused, bool use_suffix)
+    size_t offset __attribute__((unused)), bool use_suffix)
 {
 	struct bwstring *s1, *s2;
 	wchar_t sfrac1[MAX_NUM_SIZE + 1], sfrac2[MAX_NUM_SIZE + 1];
@@ -981,6 +985,7 @@
 	return (numcoll_impl(kv1, kv2, offset, true));
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /* Use hint space to memoize md5 computations, at least. */
 static void
 randomcoll_init_hint(struct key_value *kv, void *hash)
@@ -995,7 +1000,7 @@
  */
 static int
 randomcoll(struct key_value *kv1, struct key_value *kv2,
-    size_t offset __unused)
+    size_t offset __attribute__((unused)))
 {
 	struct bwstring *s1, *s2;
 	MD5_CTX ctx1, ctx2;
@@ -1037,13 +1042,14 @@
 
 	return (memcmp(hash1, hash2, sizeof(hash1)));
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Implements version sort (-V).
  */
 static int
 versioncoll(struct key_value *kv1, struct key_value *kv2,
-    size_t offset __unused)
+    size_t offset __attribute__((unused)))
 {
 	struct bwstring *s1, *s2;
 
@@ -1118,7 +1124,7 @@
  */
 static int
 gnumcoll(struct key_value *kv1, struct key_value *kv2,
-    size_t offset __unused)
+    size_t offset __attribute__((unused)))
 {
 	double d1, d2;
 	int err1, err2;
@@ -1274,7 +1280,7 @@
  * Implements month sort (-M).
  */
 static int
-monthcoll(struct key_value *kv1, struct key_value *kv2, size_t offset __unused)
+monthcoll(struct key_value *kv1, struct key_value *kv2, size_t offset __attribute__((unused)))
 {
 	int val1, val2;
 	bool key1_read, key2_read;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/coll.h src.freebsd/coreutils/sort/coll.h
--- src.orig/coreutils/sort/coll.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/coll.h	2023-01-13 18:45:55.656361796 +0100
@@ -105,7 +105,7 @@
 {
 	struct bwstring		*k; /* key string */
 	struct key_hint		 hint[0]; /* key sort hint */
-} __packed;
+} __attribute__((packed));
 
 /*
  * Set of keys container object.
@@ -141,7 +141,7 @@
 /*
  * Function type, used to compare two list objects
  */
-typedef int (*listcoll_t)(struct sort_list_item **ss1, struct sort_list_item **ss2);
+typedef int (*listcoll_t)(const void *ss1, const void *ss2);
 
 extern struct key_specs *keys;
 extern size_t keys_num;
@@ -173,8 +173,8 @@
 int top_level_str_coll(const struct bwstring *, const struct bwstring *);
 int key_coll(struct keys_array *ks1, struct keys_array *ks2, size_t offset);
 int str_list_coll(struct bwstring *str1, struct sort_list_item **ss2);
-int list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2);
-int list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2);
+int list_coll_by_str_only(const void *ss1, const void *ss2);
+int list_coll(const void *ss1, const void *ss2);
 int list_coll_offset(struct sort_list_item **ss1, struct sort_list_item **ss2, size_t offset);
 
 listcoll_t get_list_call_func(size_t offset);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/file.c src.freebsd/coreutils/sort/file.c
--- src.orig/coreutils/sort/file.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/file.c	2023-01-13 18:21:52.673552299 +0100
@@ -39,6 +39,7 @@
 #include <fcntl.h>
 #if defined(SORT_THREADS)
 #include <pthread.h>
+#include <sched.h>
 #endif
 #include <semaphore.h>
 #include <stdio.h>
@@ -52,6 +53,8 @@
 #include "file.h"
 #include "radixsort.h"
 
+#include "compat.h"
+
 unsigned long long free_memory = 1000000;
 unsigned long long available_free_memory = 1000000;
 
@@ -632,7 +635,7 @@
 			size_t sz = 0;
 			int fd, flags;
 
-			flags = MAP_NOCORE | MAP_NOSYNC;
+			flags = MAP_PRIVATE;
 
 			fd = open(fsrc, O_RDONLY);
 			if (fd < 0)
@@ -654,6 +657,7 @@
 				close(fd);
 				break;
 			}
+			madvise(addr, sz, MADV_DONTDUMP);
 
 			ret->fd = fd;
 			ret->mmapaddr = addr;
@@ -1560,7 +1564,7 @@
 			pthread_attr_t attr;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -1569,7 +1573,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/radixsort.c src.freebsd/coreutils/sort/radixsort.c
--- src.orig/coreutils/sort/radixsort.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/radixsort.c	2023-01-13 18:21:52.677549907 +0100
@@ -37,6 +37,7 @@
 #if defined(SORT_THREADS)
 #include <pthread.h>
 #include <semaphore.h>
+#include <sched.h>
 #endif
 #include <stdlib.h>
 #include <string.h>
@@ -47,6 +48,8 @@
 #include "coll.h"
 #include "radixsort.h"
 
+#include "compat.h"
+
 #define DEFAULT_SORT_FUNC_RADIXSORT mergesort
 
 #define TINY_NODE(sl) ((sl)->tosort_num < 65)
@@ -647,7 +650,7 @@
 			pthread_t pth;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -655,7 +658,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
@@ -684,7 +687,9 @@
 		pthread_mutexattr_t mattr;
 
 		pthread_mutexattr_init(&mattr);
+#ifdef PTHREAD_MUTEX_ADAPTIVE_NP
 		pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ADAPTIVE_NP);
+#endif
 
 		pthread_mutex_init(&g_ls_mutex, &mattr);
 		pthread_cond_init(&g_ls_cond, NULL);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/sort.1 src.freebsd/coreutils/sort/sort.1
--- src.orig/coreutils/sort/sort.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/sort.1	2023-01-13 18:21:52.677549907 +0100
@@ -328,9 +328,9 @@
 .It Fl Fl debug
 Print some extra information about the sorting process to the
 standard output.
-%%THREADS%%.It Fl Fl parallel
-%%THREADS%%Set the maximum number of execution threads.
-%%THREADS%%Default number equals to the number of CPUs.
+.It Fl Fl parallel
+Set the maximum number of execution threads.
+Default number equals to the number of CPUs.
 .It Fl Fl files0-from Ns = Ns Ar filename
 Take the input file list from the file
 .Ar filename .
@@ -527,8 +527,6 @@
 behavior if neither the respective environment variable, nor
 .Ev LC_ALL
 are set.
-%%NLS%%.It Ev NLSPATH
-%%NLS%%Path to NLS catalogs.
 .It Ev TMPDIR
 Path to the directory in which temporary files will be stored.
 Note that
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/sort.c src.freebsd/coreutils/sort/sort.c
--- src.orig/coreutils/sort/sort.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/sort.c	2023-01-13 18:21:52.677549907 +0100
@@ -31,7 +31,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 #include <sys/types.h>
 
 #include <err.h>
@@ -40,7 +39,6 @@
 #include <getopt.h>
 #include <limits.h>
 #include <locale.h>
-#include <md5.h>
 #include <regex.h>
 #include <signal.h>
 #include <stdbool.h>
@@ -55,16 +53,44 @@
 #include "file.h"
 #include "sort.h"
 
+#ifndef WITHOUT_LIBCRYPTO
+void MD5Init(MD5_CTX *context)
+{
+	context->mdctx = EVP_MD_CTX_new();
+	if (!context)
+		errx(1, "could not init MD5 context");
+
+	if (!EVP_DigestInit_ex(context->mdctx, EVP_md5(), NULL))
+		errx(1, "could not init MD5 digest");
+}
+
+void MD5Update(MD5_CTX *context, const void *data, unsigned int len)
+{
+	if (!EVP_DigestUpdate(context->mdctx, data, len))
+		errx(1, "could not update MD5 digest");
+}
+
+void MD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *context)
+{
+	if (!EVP_DigestFinal(context->mdctx, digest, NULL))
+		errx(1, "could not finalize MD5 digest");
+}
+#endif /* WITHOUT_LIBCRYPTO */
+
 #ifndef WITHOUT_NLS
 #include <nl_types.h>
 nl_catd catalog = (nl_catd)-1;
 #endif
 
+extern const char *__progname;
+
 #define	OPTIONS	"bcCdfghik:Mmno:RrsS:t:T:uVz"
 
+#ifndef WITHOUT_LIBCRYPTO
 static bool need_random;
 
 MD5_CTX md5_ctx;
+#endif
 
 /*
  * Default messages to use when NLS is disabled or no catalogue
@@ -91,7 +117,11 @@
       "[--parallel thread_no] "
 #endif
       "[--human-numeric-sort] "
+#ifndef WITHOUT_LIBCRYPTO
+      "[--version-sort]] "
+#else
       "[--version-sort] [--random-sort [--random-source file]] "
+#endif
       "[--compress-program program] [file ...]\n" };
 
 struct sort_opts sort_opts_vals;
@@ -133,7 +163,9 @@
 #if defined(SORT_THREADS)
 	PARALLEL_OPT,
 #endif
+#ifndef WITHOUT_LIBCRYPTO
 	RANDOMSOURCE_OPT,
+#endif
 	COMPRESSPROGRAM_OPT,
 	QSORT_OPT,
 	MERGESORT_OPT,
@@ -174,8 +206,10 @@
 #endif
 				{ "qsort", no_argument, NULL, QSORT_OPT },
 				{ "radixsort", no_argument, NULL, RADIXSORT_OPT },
+#ifndef WITHOUT_LIBCRYPTO
 				{ "random-sort", no_argument, NULL, 'R' },
 				{ "random-source", required_argument, NULL, RANDOMSOURCE_OPT },
+#endif
 				{ "reverse", no_argument, NULL, 'r' },
 				{ "sort", required_argument, NULL, SORT_OPT },
 				{ "stable", no_argument, NULL, 's' },
@@ -212,7 +246,7 @@
 
 	out = opt_err ? stderr : stdout;
 
-	fprintf(out, getstr(12), getprogname());
+	fprintf(out, getstr(12), __progname);
 	if (opt_err)
 		exit(2);
 	exit(0);
@@ -329,16 +363,24 @@
 	lc = localeconv();
 
 	if (lc) {
+		wchar_t sym_decimal_point;
+		wchar_t sym_thousands_sep;
+		wchar_t sym_positive_sign;
+		wchar_t sym_negative_sign;
 		/* obtain LC_NUMERIC info */
 		/* Convert to wide char form */
-		conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
+		conv_mbtowc(&sym_decimal_point, lc->decimal_point,
 		    symbol_decimal_point);
-		conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
+		conv_mbtowc(&sym_thousands_sep, lc->thousands_sep,
 		    symbol_thousands_sep);
-		conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
+		conv_mbtowc(&sym_positive_sign, lc->positive_sign,
 		    symbol_positive_sign);
-		conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
+		conv_mbtowc(&sym_negative_sign, lc->negative_sign,
 		    symbol_negative_sign);
+		symbol_decimal_point = sym_decimal_point;
+		symbol_thousands_sep = sym_thousands_sep;
+		symbol_positive_sign = sym_positive_sign;
+		symbol_negative_sign = sym_negative_sign;
 	}
 
 	if (getenv("GNUSORT_NUMERIC_COMPATIBILITY"))
@@ -433,7 +475,8 @@
 				    100;
 				break;
 			default:
-				warnc(EINVAL, "%s", optarg);
+				errno = EINVAL;
+				warn("%s", optarg);
 				membuf = available_free_memory;
 			}
 		}
@@ -445,8 +488,8 @@
  * Signal handler that clears the temporary files.
  */
 static void
-sig_handler(int sig __unused, siginfo_t *siginfo __unused,
-    void *context __unused)
+sig_handler(int sig __attribute__((unused)), siginfo_t *siginfo __attribute__((unused)),
+    void *context __attribute__((unused)))
 {
 
 	clear_tmp_files();
@@ -585,11 +628,13 @@
 	case 'i':
 		sm->iflag = true;
 		break;
+#ifndef WITHOUT_LIBCRYPTO
 	case 'R':
 		sm->Rflag = true;
 		need_hint = true;
 		need_random = true;
 		break;
+#endif
 	case 'M':
 		initialise_months();
 		sm->Mflag = true;
@@ -855,7 +900,7 @@
 void
 fix_obsolete_keys(int *argc, char **argv)
 {
-	char sopt[129];
+	char sopt[304];
 
 	for (int i = 1; i < *argc; i++) {
 		char *arg1;
@@ -911,6 +956,7 @@
 	}
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * Seed random sort
  */
@@ -983,6 +1029,7 @@
 	MD5Init(&md5_ctx);
 	MD5Update(&md5_ctx, randseed, rd);
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Main function.
@@ -991,7 +1038,9 @@
 main(int argc, char **argv)
 {
 	char *outfile, *real_outfile;
+#ifndef WITHOUT_LIBCRYPTO
 	char *random_source = NULL;
+#endif
 	int c, result;
 	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
 	    { false, false, false, false, false, false };
@@ -1054,7 +1103,8 @@
 
 				if (parse_k(optarg, &(keys[keys_num - 1]))
 				    < 0) {
-					errc(2, EINVAL, "-k %s", optarg);
+					errno = EINVAL;
+					err(2, "-k %s", optarg);
 				}
 
 				break;
@@ -1079,7 +1129,8 @@
 			case 't':
 				while (strlen(optarg) > 1) {
 					if (optarg[0] != '\\') {
-						errc(2, EINVAL, "%s", optarg);
+						errno = EINVAL;
+						err(2, "%s", optarg);
 					}
 					optarg += 1;
 					if (*optarg == '0') {
@@ -1122,8 +1173,10 @@
 						set_sort_modifier(sm, 'n');
 					else if (!strcmp(optarg, "month"))
 						set_sort_modifier(sm, 'M');
+#ifndef WITHOUT_LIBCRYPTO
 					else if (!strcmp(optarg, "random"))
 						set_sort_modifier(sm, 'R');
+#endif
 					else
 						unknown(optarg);
 				}
@@ -1152,9 +1205,11 @@
 			case RADIXSORT_OPT:
 				sort_opts_vals.sort_method = SORT_RADIXSORT;
 				break;
+#ifndef WITHOUT_LIBCRYPTO
 			case RANDOMSOURCE_OPT:
 				random_source = strdup(optarg);
 				break;
+#endif
 			case COMPRESSPROGRAM_OPT:
 				compress_program = strdup(optarg);
 				break;
@@ -1247,8 +1302,10 @@
 		}
 	}
 
+#ifndef WITHOUT_LIBCRYPTO
 	if (need_random)
 		get_random_seed(random_source);
+#endif
 
 	/* Case when the outfile equals one of the input files: */
 	if (strcmp(outfile, "-")) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sort/sort.h src.freebsd/coreutils/sort/sort.h
--- src.orig/coreutils/sort/sort.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/sort/sort.h	2023-01-13 18:21:52.677549907 +0100
@@ -39,7 +39,10 @@
 #include <wchar.h>
 
 #include <sys/types.h>
-#include <md5.h>
+
+#ifndef WITHOUT_LIBCRYPTO
+#include <openssl/evp.h>
+#endif
 
 #define	VERSION	"2.3-FreeBSD"
 
@@ -61,15 +64,31 @@
 extern size_t nthreads;
 #endif
 
+/* bsdutils additions */
+
+#ifndef WITHOUT_LIBCRYPTO
+#define MD5_DIGEST_LENGTH 16
+
+typedef struct {
+	EVP_MD_CTX *mdctx;
+} MD5_CTX;
+
+void MD5Init(MD5_CTX *context);
+void MD5Update(MD5_CTX *context, const void *data, unsigned int len);
+void MD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *context);
+#endif
+
 /*
  * If true, we output some debug information.
  */
 extern bool debug_sort;
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * MD5 context for random hash function
  */
 extern MD5_CTX md5_ctx;
+#endif
 
 /*
  * sort.c
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/split/split.c src.freebsd/coreutils/split/split.c
--- src.orig/coreutils/split/split.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/split/split.c	2023-01-13 18:21:52.677549907 +0100
@@ -51,7 +51,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <libutil.h>
 #include <limits.h>
 #include <locale.h>
 #include <stdbool.h>
@@ -63,6 +62,12 @@
 #include <regex.h>
 #include <sysexits.h>
 
+#include "compat.h"
+
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 #define DEFLINE	1000			/* Default num lines per file. */
 
 static off_t	 bytecnt;		/* Byte count to split on. */
@@ -89,6 +94,7 @@
 	int ch;
 	int error;
 	char *ep, *p;
+	uint64_t ubytecnt;
 
 	setlocale(LC_ALL, "");
 
@@ -120,7 +126,8 @@
 			break;
 		case 'b':		/* Byte count. */
 			errno = 0;
-			error = expand_number(optarg, &bytecnt);
+			ubytecnt = bytecnt;
+			error = expand_number(optarg, &ubytecnt);
 			if (error == -1)
 				errx(EX_USAGE, "%s: offset too large", optarg);
 			break;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stat/stat.1 src.freebsd/coreutils/stat/stat.1
--- src.orig/coreutils/stat/stat.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/stat/stat.1	2023-01-13 18:21:52.677549907 +0100
@@ -38,7 +38,7 @@
 .Nd display file status
 .Sh SYNOPSIS
 .Nm
-.Op Fl FHLnq
+.Op Fl FLnq
 .Op Fl f Ar format | Fl l | r | s | x
 .Op Fl t Ar timefmt
 .Op Ar
@@ -90,11 +90,9 @@
 .Fa st_atime ,
 .Fa st_mtime ,
 .Fa st_ctime ,
-.Fa st_birthtime ,
 .Fa st_blksize ,
-.Fa st_blocks ,
 and
-.Fa st_flags
+.Fa st_blocks
 fields, in that order.
 .Pp
 The options are as follows:
@@ -124,13 +122,6 @@
 .Fl F
 implies
 .Fl l .
-.It Fl H
-Treat each argument as the hexadecimal representation of an NFS file handle,
-and use
-.Xr fhstat 2
-instead of
-.Xr lstat 2 .
-This requires root privileges.
 .It Fl L
 Use
 .Xr stat 2
@@ -273,11 +264,6 @@
 format.
 .It Cm dr
 Display actual device name.
-.It Cm f
-Display the flags of
-.Ar file
-as in
-.Nm ls Fl lTdo .
 .It Cm gu
 Display group or user name.
 .It Cm p
@@ -396,12 +382,11 @@
 .It Cm r
 Device number for character and block device special files
 .Pq Fa st_rdev .
-.It Cm a , m , c , B
+.It Cm a , m , c
 The time
 .Ar file
-was last accessed or modified, or when the inode was last changed, or
-the birth time of the inode
-.Pq Fa st_atime , st_mtime , st_ctime , st_birthtime .
+was last accessed or modified or when the inode was last changed
+.Pq Fa st_atime , st_mtime , st_ctime .
 .It Cm z
 The size of
 .Ar file
@@ -414,9 +399,6 @@
 .It Cm k
 Optimal file system I/O operation block size
 .Pq Fa st_blksize .
-.It Cm f
-User defined flags for
-.Ar file .
 .It Cm v
 Inode generation number
 .Pq Fa st_gen .
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stat/stat.c src.freebsd/coreutils/stat/stat.c
--- src.orig/coreutils/stat/stat.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/stat/stat.c	2023-01-13 18:21:52.677549907 +0100
@@ -42,17 +42,18 @@
 #if HAVE_CONFIG_H
 #include "config.h" 
 #else  /* HAVE_CONFIG_H */
-#define HAVE_STRUCT_STAT_ST_FLAGS 1
-#define HAVE_STRUCT_STAT_ST_GEN 1
-#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
+#define HAVE_STRUCT_STAT_ST_FLAGS 0
+#define HAVE_STRUCT_STAT_ST_GEN 0
+#define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
-#define HAVE_DEVNAME 1
+#define HAVE_DEVNAME 0
 #endif /* HAVE_CONFIG_H */
 
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -68,6 +69,10 @@
 #include <time.h>
 #include <unistd.h>
 
+#include "compat.h"
+
+extern char *__progname;
+
 #if HAVE_STRUCT_STAT_ST_FLAGS
 #define DEF_F "%#Xf "
 #define RAW_F "%f "
@@ -209,24 +214,21 @@
 {
 	struct stat st;
 	int ch, rc, errs, am_readlink;
-	int lsF, fmtchar, usestat, nfs_handle, fn, nonl, quiet;
+	int lsF, fmtchar, usestat, fn, nonl, quiet;
 	const char *statfmt, *options, *synopsis;
-	char dname[sizeof _PATH_DEV + SPECNAMELEN] = _PATH_DEV;
-	fhandle_t fhnd;
 	const char *file;
 
 	am_readlink = 0;
 	lsF = 0;
 	fmtchar = '\0';
 	usestat = 0;
-	nfs_handle = 0;
 	nonl = 0;
 	quiet = 0;
 	linkfail = 0;
 	statfmt = NULL;
 	timefmt = NULL;
 
-	if (strcmp(getprogname(), "readlink") == 0) {
+	if (strcmp(__progname, "readlink") == 0) {
 		am_readlink = 1;
 		options = "fn";
 		synopsis = "[-fn] [file ...]";
@@ -234,7 +236,7 @@
 		fmtchar = 'f';
 		quiet = 1;
 	} else {
-		options = "f:FHlLnqrst:x";
+		options = "f:FlLnqrst:x";
 		synopsis = "[-FLnq] [-f format | -l | -r | -s | -x] "
 		    "[-t timefmt] [file|handle ...]";
 	}
@@ -244,9 +246,6 @@
 		case 'F':
 			lsF = 1;
 			break;
-                case 'H':
-			nfs_handle = 1;
-			break;
 		case 'L':
 			usestat = 1;
 			break;
@@ -324,37 +323,11 @@
 	errs = 0;
 	do {
 		if (argc == 0) {
-			if (fdevname_r(STDIN_FILENO, dname +
-			    sizeof _PATH_DEV - 1, SPECNAMELEN) != NULL)
-				file = dname;
-			else
-				file = "(stdin)";
+			file = "(stdin)";
 			rc = fstat(STDIN_FILENO, &st);
 		} else {
-			int j;
-
 			file = argv[0];
-			if (nfs_handle) {
-				rc = 0;
-				bzero(&fhnd, sizeof(fhnd));
-				j = MIN(2 * sizeof(fhnd), strlen(file));
-				if ((j & 1) != 0) {
-					rc = -1;
-				} else {
-					while (j) {
-						rc = hex2byte(&file[j - 2]);
-						if (rc == -1)
-							break;
-						((char*) &fhnd)[j / 2 - 1] = rc;
-						j -= 2;
-					}
-				}
-				if (rc == -1)
-					errno = EINVAL;
-				else
-					rc = fhstat(&fhnd, &st);
-
-			} else if (usestat) {
+			if (usestat) {
 				/*
 				 * Try stat() and if it fails, fall back to
 				 * lstat() just in case we're examining a
@@ -409,7 +382,7 @@
 usage(const char *synopsis)
 {
 
-	(void)fprintf(stderr, "usage: %s %s\n", getprogname(), synopsis);
+	(void)fprintf(stderr, "usage: %s %s\n", __progname, synopsis);
 	exit(1);
 }
 
@@ -619,8 +592,10 @@
 {
 	u_int64_t data;
 	char *stmp, lfmt[24], tmp[20];
-	const char *sdata;
-	char smode[12], sid[12], path[PATH_MAX + 4];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	const char *sdata = NULL;
+	char smode[12], sid[13], path[PATH_MAX + 4];
 	const struct timespec *tsp;
 	struct timespec ts;
 	struct tm *tm;
@@ -717,10 +692,12 @@
 	case SHOW_st_uid:
 		small = (sizeof(st->st_uid) == 4);
 		data = st->st_uid;
-		sdata = user_from_uid(st->st_uid, 1);
-		if (sdata == NULL) {
+		pw = getpwuid(st->st_uid);
+		if (pw == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_uid);
 			sdata = sid;
+		} else {
+			sdata = pw->pw_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -730,10 +707,12 @@
 	case SHOW_st_gid:
 		small = (sizeof(st->st_gid) == 4);
 		data = st->st_gid;
-		sdata = group_from_gid(st->st_gid, 1);
-		if (sdata == NULL) {
+		gr = getgrgid(st->st_gid);
+		if (gr == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_gid);
 			sdata = sid;
+		} else {
+			sdata = gr->gr_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -741,15 +720,15 @@
 			ofmt = FMTF_UNSIGNED;
 		break;
 	case SHOW_st_atime:
-		tsp = &st->st_atimespec;
+		tsp = &st->st_atim;
 		/* FALLTHROUGH */
 	case SHOW_st_mtime:
 		if (tsp == NULL)
-			tsp = &st->st_mtimespec;
+			tsp = &st->st_mtim;
 		/* FALLTHROUGH */
 	case SHOW_st_ctime:
 		if (tsp == NULL)
-			tsp = &st->st_ctimespec;
+			tsp = &st->st_ctim;
 		/* FALLTHROUGH */
 #if HAVE_STRUCT_STAT_ST_BIRTHTIME
 	case SHOW_st_btime:
@@ -1093,7 +1072,7 @@
 #define hex2nibble(c) (c <= '9' ? c - '0' : toupper(c) - 'A' + 10)
 int
 hex2byte(const char c[2]) {
-	if (!(ishexnumber(c[0]) && ishexnumber(c[1])))
+	if (!(isxdigit(c[0]) && isxdigit(c[1])))
 		return -1;
 	return (hex2nibble(c[0]) << 4) + hex2nibble(c[1]);
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/cchar.c src.freebsd/coreutils/stty/cchar.c
--- src.orig/coreutils/stty/cchar.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/cchar.c	2023-01-13 18:21:52.677549907 +0100
@@ -36,11 +36,14 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -56,12 +59,11 @@
  */
 struct cchar cchars1[] = {
 	{ "discard",	VDISCARD, 	CDISCARD },
-	{ "dsusp", 	VDSUSP,		CDSUSP },
+	{ "dsusp", 	CDSUSP,		CDSUSP },
 	{ "eof",	VEOF,		CEOF },
 	{ "eol",	VEOL,		CEOL },
 	{ "eol2",	VEOL2,		CEOL },
 	{ "erase",	VERASE,		CERASE },
-	{ "erase2",	VERASE2,	CERASE2 },
 	{ "intr",	VINTR,		CINTR },
 	{ "kill",	VKILL,		CKILL },
 	{ "lnext",	VLNEXT,		CLNEXT },
@@ -69,7 +71,7 @@
 	{ "quit",	VQUIT,		CQUIT },
 	{ "reprint",	VREPRINT, 	CREPRINT },
 	{ "start",	VSTART,		CSTART },
-	{ "status",	VSTATUS, 	CSTATUS },
+	{ "status",	CSTATUS, 	CSTATUS },
 	{ "stop",	VSTOP,		CSTOP },
 	{ "susp",	VSUSP,		CSUSP },
 	{ "time",	VTIME,		CTIME },
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/extern.h src.freebsd/coreutils/stty/extern.h
--- src.orig/coreutils/stty/extern.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/extern.h	2023-01-13 18:21:52.677549907 +0100
@@ -42,4 +42,7 @@
 void	print(struct termios *, struct winsize *, int, enum FMT);
 void	usage(void) __dead2;
 
+int get_baud(speed_t s);
+speed_t get_speed(unsigned long b);
+
 extern struct cchar cchars1[], cchars2[];
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/gfmt.c src.freebsd/coreutils/stty/gfmt.c
--- src.orig/coreutils/stty/gfmt.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/gfmt.c	2023-01-13 18:21:52.677549907 +0100
@@ -40,7 +40,9 @@
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -57,7 +59,7 @@
 }
 
 void
-gprint(struct termios *tp, struct winsize *wp __unused, int ldisc __unused)
+gprint(struct termios *tp, struct winsize *wp __attribute__((unused)), int ldisc __attribute__((unused)))
 {
 	struct cchar *cp;
 
@@ -67,7 +69,7 @@
 	for (cp = cchars1; cp->name; ++cp)
 		(void)printf("%s=%x:", cp->name, tp->c_cc[cp->sub]);
 	(void)printf("ispeed=%lu:ospeed=%lu\n",
-	    (u_long)cfgetispeed(tp), (u_long)cfgetospeed(tp));
+	    (u_long)get_baud(cfgetispeed(tp)), (u_long)get_baud(cfgetospeed(tp)));
 }
 
 void
@@ -99,7 +101,7 @@
 		}
 		if (CHK("ispeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ispeed = tmp;
+			cfsetispeed(tp, tmp);
 			continue;
 		}
 		if (CHK("lflag")) {
@@ -112,7 +114,7 @@
 		}
 		if (CHK("ospeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ospeed = tmp;
+			cfsetospeed(tp, tmp);
 			continue;
 		}
 		for (cp = cchars1; cp->name != NULL; ++cp)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/key.c src.freebsd/coreutils/stty/key.c
--- src.orig/coreutils/stty/key.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/key.c	2023-01-13 18:21:52.677549907 +0100
@@ -36,11 +36,15 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
+#include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -191,13 +195,23 @@
 void
 f_extproc(struct info *ip)
 {
+	struct termios tio;
+	errno = 0;
+
+	if (tcgetattr(ip->fd, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
 
 	if (ip->off) {
-		int tmp = 0;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag &= ~EXTPROC;
 	} else {
-		int tmp = 1;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag |= EXTPROC;
+	}
+
+	if (tcsetattr(ip->fd, TCSANOW, &tio) == -1) {
+		err(1, "extproc");
+		return;
 	}
 }
 
@@ -258,11 +272,16 @@
 {
 	struct termios def;
 
-	cfmakesane(&def);
+	def.c_cflag = TTYDEF_CFLAG;
+	def.c_iflag = TTYDEF_IFLAG;
+	def.c_lflag = TTYDEF_LFLAG;
+	def.c_oflag = TTYDEF_OFLAG;
+	cfsetispeed(&def, TTYDEF_SPEED);
+	cfsetospeed(&def, TTYDEF_SPEED);
 	ip->t.c_cflag = def.c_cflag | (ip->t.c_cflag & CLOCAL);
 	ip->t.c_iflag = def.c_iflag;
 	/* preserve user-preference flags in lflag */
-#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|ALTWERASE|TOSTOP|NOFLSH)
+#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|VWERASE|TOSTOP|NOFLSH)
 	ip->t.c_lflag = def.c_lflag | (ip->t.c_lflag & LKEEP);
 	ip->t.c_oflag = def.c_oflag;
 	ip->set = 1;
@@ -279,7 +298,7 @@
 f_speed(struct info *ip)
 {
 
-	(void)printf("%lu\n", (u_long)cfgetospeed(&ip->t));
+	(void)printf("%lu\n", (u_long)get_baud(cfgetospeed(&ip->t)));
 }
 
 void
@@ -287,7 +306,7 @@
 {
 	int tmp;
 
-	tmp = TTYDISC;
+	tmp = N_TTY;
 	if (ioctl(ip->fd, TIOCSETD, &tmp) < 0)
 		err(1, "TIOCSETD");
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/modes.c src.freebsd/coreutils/stty/modes.c
--- src.orig/coreutils/stty/modes.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/modes.c	2023-01-13 18:21:52.677549907 +0100
@@ -36,7 +36,9 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 #include "stty.h"
 
 int msearch(char ***, struct info *);
@@ -80,18 +82,6 @@
 	{ "-clocal",	0, CLOCAL },
 	{ "crtscts",	CRTSCTS, 0 },
 	{ "-crtscts",	0, CRTSCTS },
-	{ "ctsflow",	CCTS_OFLOW, 0 },
-	{ "-ctsflow",	0, CCTS_OFLOW },
-	{ "dsrflow",	CDSR_OFLOW, 0 },
-	{ "-dsrflow",	0, CDSR_OFLOW },
-	{ "dtrflow",	CDTR_IFLOW, 0 },
-	{ "-dtrflow",	0, CDTR_IFLOW },
-	{ "rtsflow",	CRTS_IFLOW, 0 },
-	{ "-rtsflow",	0, CRTS_IFLOW },
-	{ "mdmbuf",	MDMBUF, 0 },
-	{ "-mdmbuf",	0, MDMBUF },
-	{ "rtsdtr",	0, CNO_RTSDTR },
-	{ "-rtsdtr",	CNO_RTSDTR, 0 },
 	{ NULL,		0, 0 },
 };
 
@@ -146,8 +136,8 @@
 	{ "-echoke",	0, ECHOKE },
 	{ "crtkill",	ECHOKE, 0 },
 	{ "-crtkill",	0, ECHOKE },
-	{ "altwerase",	ALTWERASE, 0 },
-	{ "-altwerase",	0, ALTWERASE },
+	{ "altwerase",	VWERASE, 0 },
+	{ "-altwerase",	0, VWERASE },
 	{ "iexten",	IEXTEN, 0 },
 	{ "-iexten",	0, IEXTEN },
 	{ "echonl",	ECHONL, 0 },
@@ -176,10 +166,6 @@
 	{ "-crt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
 	{ "newcrt",	ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT },
 	{ "-newcrt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
-	{ "nokerninfo",	NOKERNINFO, 0 },
-	{ "-nokerninfo",0, NOKERNINFO },
-	{ "kerninfo",	0, NOKERNINFO },
-	{ "-kerninfo",	NOKERNINFO, 0 },
 	{ NULL,		0, 0 },
 };
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/print.c src.freebsd/coreutils/stty/print.c
--- src.orig/coreutils/stty/print.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/print.c	2023-01-13 18:21:52.681547516 +0100
@@ -40,6 +40,8 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -60,12 +62,12 @@
 	cnt = 0;
 
 	/* Line discipline. */
-	if (ldisc != TTYDISC) {
+	if (ldisc != N_TTY) {
 		switch(ldisc) {
-		case SLIPDISC:
+		case N_SLIP:
 			cnt += printf("slip disc; ");
 			break;
-		case PPPDISC:
+		case N_PPP:
 			cnt += printf("ppp disc; ");
 			break;
 		default:
@@ -79,9 +81,9 @@
 	ospeed = cfgetospeed(tp);
 	if (ispeed != ospeed)
 		cnt +=
-		    printf("ispeed %d baud; ospeed %d baud;", ispeed, ospeed);
+		    printf("ispeed %d baud; ospeed %d baud;", get_baud(ispeed), get_baud(ospeed));
 	else
-		cnt += printf("speed %d baud;", ispeed);
+		cnt += printf("speed %d baud;", get_baud(ispeed));
 	if (fmt >= BSD)
 		cnt += printf(" %d rows; %d columns;", wp->ws_row, wp->ws_col);
 	if (cnt)
@@ -105,12 +107,11 @@
 	put("-echonl", ECHONL, 0);
 	put("-echoctl", ECHOCTL, 0);
 	put("-echoprt", ECHOPRT, 0);
-	put("-altwerase", ALTWERASE, 0);
+	put("-altwerase", VWERASE, 0);
 	put("-noflsh", NOFLSH, 0);
 	put("-tostop", TOSTOP, 0);
 	put("-flusho", FLUSHO, 0);
 	put("-pendin", PENDIN, 0);
-	put("-nokerninfo", NOKERNINFO, 0);
 	put("-extproc", EXTPROC, 0);
 
 	/* input flags */
@@ -170,26 +171,7 @@
 	put("-hupcl", HUPCL, 1);
 	put("-clocal", CLOCAL, 0);
 	put("-cstopb", CSTOPB, 0);
-	switch(tmp & (CCTS_OFLOW | CRTS_IFLOW)) {
-	case CCTS_OFLOW:
-		bput("ctsflow");
-		break;
-	case CRTS_IFLOW:
-		bput("rtsflow");
-		break;
-	default:
-		put("-crtscts", CCTS_OFLOW | CRTS_IFLOW, 0);
-		break;
-	}
-	put("-dsrflow", CDSR_OFLOW, 0);
-	put("-dtrflow", CDTR_IFLOW, 0);
-	put("-mdmbuf", MDMBUF, 0);	/* XXX mdmbuf ==  dtrflow */
-	if (on(CNO_RTSDTR))
-		bput("-rtsdtr");
-	else {
-		if (fmt >= BSD)
-			bput("rtsdtr");
-	}
+	put("-crtscts", CRTSCTS, 0);
 
 	/* special control characters */
 	cc = tp->c_cc;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/stty.1 src.freebsd/coreutils/stty/stty.1
--- src.orig/coreutils/stty/stty.1	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/stty.1	2023-01-13 18:21:52.681547516 +0100
@@ -353,13 +353,6 @@
 erased with simply an
 .Dv ERASE
 character.)
-.It Cm mdmbuf Pq Fl mdmbuf
-If set, flow control output based on condition of Carrier Detect.
-Otherwise
-writes return an error if Carrier Detect is low (and Carrier is not being
-ignored with the
-.Dv CLOCAL
-flag.)
 .It Cm flusho Pq Fl flusho
 Indicates output is (is not) being discarded.
 .It Cm pendin Pq Fl pendin
@@ -393,7 +386,6 @@
 .It eol Ta Tn VEOL Ta EOL No character
 .It eol2 Ta Tn VEOL2 Ta EOL2 No character
 .It erase Ta Tn VERASE Ta ERASE No character
-.It erase2 Ta Tn VERASE2 Ta ERASE2 No character
 .It werase Ta Tn VWERASE Ta WERASE No character
 .It intr Ta Tn VINTR Ta INTR No character
 .It kill Ta Tn VKILL Ta KILL No character
@@ -401,10 +393,10 @@
 .It susp Ta Tn VSUSP Ta SUSP No character
 .It start Ta Tn VSTART Ta START No character
 .It stop Ta Tn VSTOP Ta STOP No character
-.It dsusp Ta Tn VDSUSP Ta DSUSP No character
+.It dsusp Ta Tn CDSUSP Ta DSUSP No character
 .It lnext Ta Tn VLNEXT Ta LNEXT No character
 .It reprint Ta Tn VREPRINT Ta REPRINT No character
-.It status Ta Tn VSTATUS Ta STATUS No character
+.It status Ta Tn CSTATUS Ta STATUS No character
 .El
 .Ed
 .It Cm min Ar number
@@ -452,22 +444,6 @@
 .Dv TTYDISC .
 .It Cm crt Pq Fl crt
 Set (disable) all modes suitable for a CRT display device.
-.It Cm kerninfo Pq Fl kerninfo
-Enable (disable) the system generated status line associated with
-processing a
-.Dv STATUS
-character (usually set to ^T).
-The status line consists of the
-system load average, the current command name, its process ID, the
-event the process is waiting on (or the status of the process), the user
-and system times, percent cpu, and current memory usage.
-.Pp
-If the
-.Xr sysctl 8
-variable
-.Va kern.tty_info_kstacks
-is set to a non-zero value, the status message also includes the kernel program
-stack of the foreground thread.
 .It Cm columns Ar number
 The terminal size is recorded as having
 .Ar number
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/stty.c src.freebsd/coreutils/stty/stty.c
--- src.orig/coreutils/stty/stty.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/stty.c	2023-01-13 18:21:52.681547516 +0100
@@ -51,9 +51,12 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
+#include "compat.h"
 
 int
 main(int argc, char *argv[])
@@ -129,10 +132,11 @@
 
 		if (isdigit(**argv)) {
 			speed_t speed;
-
-			speed = strtonum(*argv, 0, UINT_MAX, &errstr);
+			unsigned int baud;
+			baud = (unsigned int)strtonum(*argv, 0, UINT_MAX, &errstr);
 			if (errstr)
 				err(1, "speed");
+			speed = get_speed(baud);
 			cfsetospeed(&i.t, speed);
 			cfsetispeed(&i.t, speed);
 			i.set = 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/stty/util.c src.freebsd/coreutils/stty/util.c
--- src.orig/coreutils/stty/util.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/stty/util.c	2023-01-13 18:21:52.681547516 +0100
@@ -40,6 +40,7 @@
 
 #include <err.h>
 #include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -60,3 +61,24 @@
 	    (sb1.st_rdev != sb2.st_rdev))
 warnx("stdout appears redirected, but stdin is the control descriptor");
 }
+
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
+	19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600,
+	1000000, 1152000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000,
+};
+
+int get_baud(speed_t s) {
+	if (s & CBAUDEX)
+		s = (s & ~CBAUDEX) + 16;
+	return baudlist[s];
+}
+
+speed_t get_speed(unsigned long b) {
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if ((unsigned long)baudlist[i] != b)
+			continue;
+		return i;
+	}
+	errx(1, "unknown speed for baud %lu", b);
+}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/sync/sync.c src.freebsd/coreutils/sync/sync.c
--- src.orig/coreutils/sync/sync.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/coreutils/sync/sync.c	2023-01-13 18:21:52.681547516 +0100
@@ -45,7 +45,7 @@
 #include <unistd.h>
 
 int
-main(int argc __unused, char *argv[] __unused)
+main(int argc __attribute__((unused)), char *argv[] __attribute__((unused)))
 {
 	sync();
 	exit(0);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/extern.h src.freebsd/coreutils/tail/extern.h
--- src.orig/coreutils/tail/extern.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/extern.h	2023-01-13 18:21:52.681547516 +0100
@@ -78,4 +78,3 @@
 void printfn(const char *, int);
 
 extern int Fflag, fflag, qflag, rflag, rval, no_files;
-extern fileargs_t *fa;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/forward.c src.freebsd/coreutils/tail/forward.c
--- src.orig/coreutils/tail/forward.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/forward.c	2023-01-13 18:21:52.681547516 +0100
@@ -46,20 +46,21 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/mman.h>
-#include <sys/event.h>
+#include <sys/inotify.h>
+#include <sys/vfs.h>
+
+#include <linux/magic.h>
 
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <poll.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 #include "extern.h"
 
 static void rlines(FILE *, const char *fn, off_t, struct stat *);
@@ -68,12 +69,12 @@
 
 /* defines for inner loop actions */
 #define USE_SLEEP	0
-#define USE_KQUEUE	1
+#define USE_INOTIFY	1
 #define ADD_EVENTS	2
 
-static struct kevent *ev;
+static int *ev;
 static int action = USE_SLEEP;
-static int kq;
+static int ifd;
 
 static const file_info_t *last;
 
@@ -265,41 +266,118 @@
 	return 1;
 }
 
+/* a rather ugly list of filesystems from linux/magic.h specifying whether
+ * we can watch them with inotify; explicitly specify them as we can still
+ * fall back to sleep for the other filesystems, while the opposite would
+ * cause actual practical problems
+ */
+static int
+fs_is_local(unsigned long magic)
+{
+	switch (magic) {
+	case ADFS_SUPER_MAGIC:
+	case AFFS_SUPER_MAGIC:
+	case ANON_INODE_FS_MAGIC:
+	case BDEVFS_MAGIC:
+	case BINFMTFS_MAGIC:
+	case BPF_FS_MAGIC:
+	case BTRFS_SUPER_MAGIC:
+	case BTRFS_TEST_MAGIC:
+	case CGROUP_SUPER_MAGIC:
+	case CGROUP2_SUPER_MAGIC:
+	case CRAMFS_MAGIC:
+	case DEBUGFS_MAGIC:
+	case DEVPTS_SUPER_MAGIC:
+	case ECRYPTFS_SUPER_MAGIC:
+	case EFS_SUPER_MAGIC:
+	case EXT2_SUPER_MAGIC:
+	case F2FS_SUPER_MAGIC:
+	case FUTEXFS_SUPER_MAGIC:
+	case HOSTFS_SUPER_MAGIC:
+	case HPFS_SUPER_MAGIC:
+	case HUGETLBFS_MAGIC:
+	case ISOFS_SUPER_MAGIC:
+	case JFFS2_SUPER_MAGIC:
+	case MINIX_SUPER_MAGIC:
+	case MINIX_SUPER_MAGIC2:
+	case MINIX2_SUPER_MAGIC:
+	case MINIX2_SUPER_MAGIC2:
+	case MINIX3_SUPER_MAGIC:
+	case MSDOS_SUPER_MAGIC:
+	case MTD_INODE_FS_MAGIC:
+	case NILFS_SUPER_MAGIC:
+	case NSFS_MAGIC:
+	case OPENPROM_SUPER_MAGIC:
+	case OVERLAYFS_SUPER_MAGIC:
+	case PROC_SUPER_MAGIC:
+	case PSTOREFS_MAGIC:
+	case QNX4_SUPER_MAGIC:
+	case QNX6_SUPER_MAGIC:
+	case RAMFS_MAGIC:
+	case REISERFS_SUPER_MAGIC:
+	case SECURITYFS_MAGIC:
+	case SELINUX_MAGIC:
+	case SMACK_MAGIC:
+	case SOCKFS_MAGIC:
+	case SQUASHFS_MAGIC:
+	case SYSFS_MAGIC:
+	case TMPFS_MAGIC:
+	case TRACEFS_MAGIC:
+	case UDF_SUPER_MAGIC:
+	case USBDEVICE_SUPER_MAGIC:
+	case V9FS_MAGIC:
+	case XENFS_SUPER_MAGIC:
+	case XFS_SUPER_MAGIC:
+		return 1;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* in addition to handling the watches, this also keeps a mapping of inotify
+ * watches to the actual file descriptors, it does so by keeping fixed indexes
+ * for each file; watches are registered so that they do not replace each other
+ */
 static void
 set_events(file_info_t *files)
 {
-	int i, n = 0;
+	int i;
 	file_info_t *file;
-	struct timespec ts;
 	struct statfs sf;
 
-	ts.tv_sec = 0;
-	ts.tv_nsec = 0;
-
-	action = USE_KQUEUE;
+	action = USE_INOTIFY;
 	for (i = 0, file = files; i < no_files; i++, file++) {
 		if (! file->fp)
 			continue;
 
-		if (fstatfs(fileno(file->fp), &sf) == 0 &&
-		    (sf.f_flags & MNT_LOCAL) == 0) {
+		if (fstatfs(fileno(file->fp), &sf) == 0 && !fs_is_local(sf.f_type)) {
 			action = USE_SLEEP;
 			return;
 		}
 
-		if (Fflag && fileno(file->fp) != STDIN_FILENO) {
-			EV_SET(&ev[n], fileno(file->fp), EVFILT_VNODE,
-			    EV_ADD | EV_ENABLE | EV_CLEAR,
-			    NOTE_DELETE | NOTE_RENAME, 0, 0);
-			n++;
+		if (fileno(file->fp) == STDIN_FILENO) {
+			action = USE_SLEEP;
+			return;
 		}
-		EV_SET(&ev[n], fileno(file->fp), EVFILT_READ,
-		    EV_ADD | EV_ENABLE | EV_CLEAR, 0, 0, 0);
-		n++;
 	}
 
-	if (kevent(kq, ev, n, NULL, 0, &ts) < 0) {
-		action = USE_SLEEP;
+	for (i = 0, file = files; i < no_files; i++, file++) {
+		uint32_t mask = IN_MODIFY | IN_MASK_ADD;
+
+		if (! file->fp) {
+			ev[i * 2 + 1] = 0;
+			continue;
+		}
+
+		ev[i * 2 + 1] = fileno(file->fp);
+
+		if (Fflag)
+			mask |= IN_DELETE_SELF | IN_MOVE_SELF;
+
+		ev[i * 2] = inotify_add_watch(ifd, file->file_name, mask);
+		if (ev[i * 2] < 0)
+			err(1, "inotify_add_watch");
 	}
 }
 
@@ -314,7 +392,7 @@
 	struct stat sb2;
 	file_info_t *file;
 	FILE *ftmp;
-	struct timespec ts;
+	struct pollfd fd;
 
 	/* Position each of the files */
 
@@ -337,22 +415,26 @@
 
 	last = --file;
 
-	kq = kqueue();
-	if (kq < 0)
-		err(1, "kqueue");
-	ev = malloc(n * sizeof(struct kevent));
+	ifd = inotify_init1(IN_NONBLOCK);
+	if (ifd < 0)
+		err(1, "inotify");
+
+	ev = calloc(no_files * 2, sizeof(int));
 	if (! ev)
-	    err(1, "Couldn't allocate memory for kevents.");
+		err(1, "Couldn't allocate memory for watch descriptors.");
+
 	set_events(files);
 
+	fd.fd = ifd;
+	fd.events = POLLIN;
+
 	for (;;) {
 		ev_change = 0;
 		if (Fflag) {
 			for (i = 0, file = files; i < no_files; i++, file++) {
 				if (!file->fp) {
 					file->fp =
-					    fileargs_fopen(fa, file->file_name,
-					    "r");
+					    fopen(file->file_name, "r");
 					if (file->fp != NULL &&
 					    fstat(fileno(file->fp), &file->st)
 					    == -1) {
@@ -365,7 +447,7 @@
 				}
 				if (fileno(file->fp) == STDIN_FILENO)
 					continue;
-				ftmp = fileargs_fopen(fa, file->file_name, "r");
+				ftmp = fopen(file->file_name, "r");
 				if (ftmp == NULL ||
 				    fstat(fileno(ftmp), &sb2) == -1) {
 					if (errno != ENOENT)
@@ -405,28 +487,61 @@
 			set_events(files);
 
 		switch (action) {
-		case USE_KQUEUE:
-			ts.tv_sec = 1;
-			ts.tv_nsec = 0;
+		case USE_INOTIFY: {
 			/*
 			 * In the -F case we set a timeout to ensure that
 			 * we re-stat the file at least once every second.
 			 */
-			n = kevent(kq, NULL, 0, ev, 1, Fflag ? &ts : NULL);
+			n = poll(&fd, 1, Fflag ? 1000 : -1);
 			if (n < 0)
-				err(1, "kevent");
+				err(1, "poll");
 			if (n == 0) {
 				/* timeout */
 				break;
-			} else if (ev->filter == EVFILT_READ && ev->data < 0) {
-				/* file shrank, reposition to end */
-				if (lseek(ev->ident, (off_t)0, SEEK_END) == -1) {
-					ierr(file->file_name);
-					continue;
+			} else if (fd.revents & POLLIN) {
+				struct inotify_event iev;
+				ssize_t len = read(ifd, &iev, sizeof(iev));
+
+				if (len < 0 && errno != EAGAIN)
+					err(1, "read");
+
+				if (len != sizeof(iev))
+					break;
+
+				/* skip name field */
+				for (; iev.len > 0; --iev.len) {
+					char c;
+					if (read(ifd, &c, 1) != 1)
+						err(1, "read");
+				}
+
+				/* we only care about the file shrinking here */
+				if (!(iev.mask & IN_MODIFY))
+					break;
+
+				/* locate the event source */
+				for (i = 0; i < n; ++i) {
+					struct stat st;
+					if (ev[i * 2] != iev.wd)
+						continue;
+					/* ignore watches with a cleared file descriptor */
+					if (ev[i * 2 + 1] == 0)
+						continue;
+					/* located a file, re-stat it and if it's smaller
+					 * than its current position, reposition to end */
+					if (fstat(ev[i * 2 + 1], &st) < 0)
+						err(1, "stat");
+					/* all is ok */
+					if (st.st_size > lseek(ev[i * 2 + 1], 0, SEEK_CUR))
+						break;
+					/* reposition */
+					if (lseek(ev[i * 2 + 1], 0, SEEK_END) < 0)
+						err(1, "lseek");
+					break;
 				}
 			}
 			break;
-
+		}
 		case USE_SLEEP:
 			(void) usleep(250000);
 			break;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/misc.c src.freebsd/coreutils/tail/misc.c
--- src.orig/coreutils/tail/misc.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/misc.c	2023-01-13 18:21:52.681547516 +0100
@@ -51,9 +51,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 #include "extern.h"
 
 void
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/read.c src.freebsd/coreutils/tail/read.c
--- src.orig/coreutils/tail/read.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/read.c	2023-01-13 18:21:52.681547516 +0100
@@ -51,9 +51,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 #include "extern.h"
 
 /*
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/reverse.c src.freebsd/coreutils/tail/reverse.c
--- src.orig/coreutils/tail/reverse.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/reverse.c	2023-01-13 18:21:52.681547516 +0100
@@ -55,11 +55,16 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 #include "extern.h"
 
+/* some versions of queue.h don't come with this */
+#ifndef TAILQ_FOREACH_FROM_SAFE
+#define TAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)                 \
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));             \
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);            \
+	    (var) = (tvar))
+#endif
+
 static void r_buf(FILE *, const char *);
 static void r_reg(FILE *, const char *, enum STYLE, off_t, struct stat *);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tail/tail.c src.freebsd/coreutils/tail/tail.c
--- src.orig/coreutils/tail/tail.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tail/tail.c	2023-01-13 18:21:52.681547516 +0100
@@ -46,11 +46,9 @@
 static const char sccsid[] = "@(#)tail.c	8.1 (Berkeley) 6/6/93";
 #endif
 
-#include <sys/capsicum.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <getopt.h>
@@ -59,13 +57,9 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
-
 #include "extern.h"
 
 int Fflag, fflag, qflag, rflag, rval, no_files;
-fileargs_t *fa;
 
 static void obsolete(char **);
 static void usage(void);
@@ -89,7 +83,6 @@
 	int ch, first;
 	file_info_t file, *filep, *files;
 	char *p;
-	cap_rights_t rights;
 
 	/*
 	 * Tail's options are weird.  First, -n10 is the same as -n-10, not
@@ -113,7 +106,7 @@
 	case '+':							\
 		if (off)						\
 			off -= (units);					\
-			style = (forward);				\
+		style = (forward);				\
 		break;							\
 	case '-':							\
 		off = -off;						\
@@ -160,22 +153,6 @@
 
 	no_files = argc ? argc : 1;
 
-	cap_rights_init(&rights, CAP_FSTAT, CAP_FSTATFS, CAP_FCNTL,
-	    CAP_MMAP_R);
-	if (fflag)
-		cap_rights_set(&rights, CAP_EVENT);
-	if (caph_rights_limit(STDIN_FILENO, &rights) < 0 ||
-	    caph_limit_stderr() < 0 || caph_limit_stdout() < 0)
-		err(1, "can't limit stdio rights");
-
-	fa = fileargs_init(argc, argv, O_RDONLY, 0, &rights, FA_OPEN);
-	if (fa == NULL)
-		err(1, "unable to init casper");
-
-	caph_cache_catpages();
-	if (caph_enter_casper() < 0)
-		err(1, "unable to enter capability mode");
-
 	/*
 	 * If displaying in reverse, don't permit follow option, and convert
 	 * style values.
@@ -210,7 +187,7 @@
 
 		for (filep = files; (fn = *argv++); filep++) {
 			filep->file_name = fn;
-			filep->fp = fileargs_fopen(fa, filep->file_name, "r");
+			filep->fp = fopen(filep->file_name, "r");
 			if (filep->fp == NULL ||
 			    fstat(fileno(filep->fp), &filep->st)) {
 				if (filep->fp != NULL) {
@@ -225,7 +202,7 @@
 		free(files);
 	} else if (*argv) {
 		for (first = 1; (fn = *argv++);) {
-			if ((fp = fileargs_fopen(fa, fn, "r")) == NULL ||
+			if ((fp = fopen(fn, "r")) == NULL ||
 			    fstat(fileno(fp), &sb)) {
 				ierr(fn);
 				continue;
@@ -268,7 +245,6 @@
 			forward(stdin, fn, style, off, &sb);
 		}
 	}
-	fileargs_free(fa);
 	exit(rval);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tee/tee.c src.freebsd/coreutils/tee/tee.c
--- src.orig/coreutils/tee/tee.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tee/tee.c	2023-01-13 18:21:52.681547516 +0100
@@ -43,11 +43,9 @@
   "$FreeBSD$";
 #endif /* not lint */
 
-#include <sys/capsicum.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -96,9 +94,6 @@
 	if ((buf = malloc(BSIZE)) == NULL)
 		err(1, "malloc");
 
-	if (caph_limit_stdin() == -1 || caph_limit_stderr() == -1)
-		err(EXIT_FAILURE, "unable to limit stdio");
-
 	add(STDOUT_FILENO, "stdout");
 
 	for (exitval = 0; *argv; ++argv)
@@ -109,8 +104,6 @@
 		} else
 			add(fd, *argv);
 
-	if (caph_enter() < 0)
-		err(EXIT_FAILURE, "unable to enter capability mode");
 	while ((rval = read(STDIN_FILENO, buf, BSIZE)) > 0)
 		for (p = head; p; p = p->next) {
 			n = rval;
@@ -140,16 +133,6 @@
 add(int fd, const char *name)
 {
 	LIST *p;
-	cap_rights_t rights;
-
-	if (fd == STDOUT_FILENO) {
-		if (caph_limit_stdout() == -1)
-			err(EXIT_FAILURE, "unable to limit stdout");
-	} else {
-		cap_rights_init(&rights, CAP_WRITE, CAP_FSTAT);
-		if (caph_rights_limit(fd, &rights) < 0)
-			err(EXIT_FAILURE, "unable to limit rights");
-	}
 
 	if ((p = malloc(sizeof(LIST))) == NULL)
 		err(1, "malloc");
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/timeout/timeout.c src.freebsd/coreutils/timeout/timeout.c
--- src.orig/coreutils/timeout/timeout.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/timeout/timeout.c	2023-01-13 18:21:52.681547516 +0100
@@ -28,7 +28,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/procctl.h>
+#include <sys/prctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
@@ -43,8 +43,12 @@
 #include <sysexits.h>
 #include <unistd.h>
 
+#include "compat.h"
+
 #define EXIT_TIMEOUT 124
 
+extern char *__progname;
+
 static sig_atomic_t sig_chld = 0;
 static sig_atomic_t sig_term = 0;
 static sig_atomic_t sig_alrm = 0;
@@ -56,7 +60,7 @@
 
 	fprintf(stderr, "Usage: %s [--signal sig | -s sig] [--preserve-status]"
 	    " [--kill-after time | -k time] [--foreground] <duration> <command>"
-	    " <arg ...>\n", getprogname());
+	    " <arg ...>\n", __progname);
 
 	exit(EX_USAGE);
 }
@@ -104,16 +108,19 @@
 {
 	int sig, i;
 	const char *errstr;
+	const char *signame;
 
-	sig = strtonum(str, 1, sys_nsig - 1, &errstr);
+	sig = strtonum(str, 1, NSIG, &errstr);
 
 	if (errstr == NULL)
 		return (sig);
+
 	if (strncasecmp(str, "SIG", 3) == 0)
 		str += 3;
 
-	for (i = 1; i < sys_nsig; i++) {
-		if (strcasecmp(str, sys_signame[i]) == 0)
+	for (i = 1; i < NSIG; i++) {
+		signame = signum_to_signame(i);
+		if (signame && strcasecmp(str, signame) == 0)
 			return (i);
 	}
 
@@ -174,8 +181,7 @@
 	bool do_second_kill = false;
 	bool child_done = false;
 	struct sigaction signals;
-	struct procctl_reaper_status info;
-	struct procctl_reaper_kill killemall;
+	unsigned long info;
 	int signums[] = {
 		-1,
 		SIGTERM,
@@ -228,8 +234,8 @@
 
 	if (!foreground) {
 		/* Acquire a reaper */
-		if (procctl(P_PID, getpid(), PROC_REAP_ACQUIRE, NULL) == -1)
-			err(EX_OSERR, "Fail to acquire the reaper");
+		if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0) == -1)
+			err(EX_OSERR, "Fail to set the reaper");
 	}
 
 	memset(&signals, 0, sizeof(signals));
@@ -297,9 +303,8 @@
 				if (foreground) {
 					break;
 				} else {
-					procctl(P_PID, getpid(),
-					    PROC_REAP_STATUS, &info);
-					if (info.rs_children == 0)
+					prctl(PR_GET_CHILD_SUBREAPER, &info, 0, 0);
+					if (info == 0)
 						break;
 				}
 			}
@@ -308,10 +313,8 @@
 
 			timedout = true;
 			if (!foreground) {
-				killemall.rk_sig = killsig;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGKILL) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, killsig);
 
@@ -325,10 +328,8 @@
 
 		} else if (sig_term) {
 			if (!foreground) {
-				killemall.rk_sig = sig_term;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGTERM) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, sig_term);
 
@@ -348,7 +349,7 @@
 	}
 
 	if (!foreground)
-		procctl(P_PID, getpid(), PROC_REAP_RELEASE, NULL);
+		prctl(PR_SET_CHILD_SUBREAPER, 0, 0, 0);
 
 	if (WEXITSTATUS(pstat))
 		pstat = WEXITSTATUS(pstat);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tr/cmap.h src.freebsd/coreutils/tr/cmap.h
--- src.orig/coreutils/tr/cmap.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tr/cmap.h	2023-01-13 18:21:52.681547516 +0100
@@ -47,7 +47,7 @@
 	wint_t		cm_cache[CM_CACHE_SIZE];
 	bool		cm_havecache;
 	struct cmapnode	*cm_root;
-#define	CM_DEF_SELF	-2
+#define	CM_DEF_SELF	(wint_t)(-2)
 	wint_t		cm_def;
 	wint_t		cm_min;
 	wint_t		cm_max;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tr/extern.h src.freebsd/coreutils/tr/extern.h
--- src.orig/coreutils/tr/extern.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tr/extern.h	2023-01-13 18:21:52.681547516 +0100
@@ -35,7 +35,7 @@
 #include <limits.h>
 
 #define	NCHARS_SB	(UCHAR_MAX + 1)	/* Number of single-byte characters. */
-#define	OOBCH		-1		/* Out of band character value. */
+#define	OOBCH		(wint_t)(-1)		/* Out of band character value. */
 
 typedef struct {
 	enum { STRING1, STRING2 } which;
@@ -51,3 +51,5 @@
 
 wint_t	 next(STR *);
 int charcoll(const void *, const void *);
+
+#define iswrune(v) (iswprint(v) || iswcntrl(v))
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tr/str.c src.freebsd/coreutils/tr/str.c
--- src.orig/coreutils/tr/str.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tr/str.c	2023-01-13 18:21:52.681547516 +0100
@@ -51,6 +51,8 @@
 
 #include "extern.h"
 
+#include "compat.h"
+
 static int      backslash(STR *, int *);
 static int	bracket(STR *);
 static void	genclass(STR *);
@@ -58,6 +60,44 @@
 static int      genrange(STR *, int);
 static void	genseq(STR *);
 
+static wint_t
+findwchar(wctype_t wct, wchar_t min, wchar_t max)
+{
+	for (; min <= max; ++min) {
+		if (iswctype(min, wct))
+			return min;
+	}
+	return (wint_t)-1;
+}
+
+/* we cannot reasonably implement this for wide characters/unicode, since
+ * the standard posix api has no way to find out the actual ranges, and
+ * doing binary search on the entire wchar range is inefficient (especially
+ * considering the character range does not have to be contiguous, which
+ * means doing a new search after we get to the end of the current part
+ * of the range)
+ *
+ * therefore, stick with what is representable in the C locale and do a
+ * simple linear search instead, this should always get us reliable results
+ */
+
+static wint_t
+nextwctype(wint_t ch, wctype_t wct)
+{
+	if (ch == (wint_t)-1) {
+		/* locate first character in the class */
+		return findwchar(wct, 0, UCHAR_MAX);
+	}
+
+	if ((ch == (wint_t)-1) || (ch >= UCHAR_MAX))
+		return (wint_t)-1;
+
+	if (!iswctype(++ch, wct))
+		return findwchar(wct, ch, UCHAR_MAX);
+
+	return ch;
+}
+
 wint_t
 next(STR *s)
 {
@@ -86,8 +126,10 @@
 		default:
 			clen = mbrtowc(&wch, s->str, MB_LEN_MAX, NULL);
 			if (clen == (size_t)-1 || clen == (size_t)-2 ||
-			    clen == 0)
-				errc(1, EILSEQ, NULL);
+			    clen == 0) {
+				errno = EILSEQ;
+				err(1, NULL);
+			}
 			is_octal = 0;
 			s->lastch = wch;
 			s->str += clen;
@@ -116,7 +158,7 @@
 	case CCLASS_LOWER:
 		s->cnt++;
 		ch = nextwctype(s->lastch, s->cclass);
-		if (ch == -1) {
+		if (ch == (wint_t)-1) {
 			s->state = NORMAL;
 			return (next(s));
 		}
@@ -203,8 +245,10 @@
 		s->str += 2;
 	} else {
 		clen = mbrtowc(&wc, s->str, MB_LEN_MAX, NULL);
-		if (clen == (size_t)-1 || clen == (size_t)-2 || clen == 0)
-			errc(1, EILSEQ, NULL);
+		if (clen == (size_t)-1 || clen == (size_t)-2 || clen == 0) {
+			errno = EILSEQ;
+			err(1, NULL);
+		}
 		s->equiv[0] = wc;
 		if (s->str[clen] != '=')
 			errx(1, "misplaced equivalence equals sign");
@@ -241,9 +285,10 @@
 static int
 genrange(STR *s, int was_octal)
 {
-	int stopval, octal;
+	wint_t stopval;
+	int octal;
 	char *savestart;
-	int n, cnt, *p;
+	wint_t n, cnt, *p;
 	size_t clen;
 	wchar_t wc;
 
@@ -253,8 +298,10 @@
 		stopval = backslash(s, &octal);
 	else {
 		clen = mbrtowc(&wc, s->str, MB_LEN_MAX, NULL);
-		if (clen == (size_t)-1 || clen == (size_t)-2)
-			errc(1, EILSEQ, NULL);
+		if (clen == (size_t)-1 || clen == (size_t)-2) {
+			errno = EILSEQ;
+			err(1, NULL);
+		}
 		stopval = wc;
 		s->str += clen;
 	}
@@ -306,8 +353,10 @@
 		s->lastch = backslash(s, NULL);
 	else {
 		clen = mbrtowc(&wc, s->str, MB_LEN_MAX, NULL);
-		if (clen == (size_t)-1 || clen == (size_t)-2)
-			errc(1, EILSEQ, NULL);
+		if (clen == (size_t)-1 || clen == (size_t)-2) {
+			errno = EILSEQ;
+			err(1, NULL);
+		}
 		s->lastch = wc;
 		s->str += clen;
 	}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tr/tr.c src.freebsd/coreutils/tr/tr.c
--- src.orig/coreutils/tr/tr.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tr/tr.c	2023-01-13 18:21:52.685545124 +0100
@@ -44,9 +44,7 @@
 #endif
 
 #include <sys/types.h>
-#include <sys/capsicum.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <limits.h>
@@ -62,6 +60,7 @@
 #include "cmap.h"
 #include "cset.h"
 #include "extern.h"
+#include "compat.h"
 
 static STR s1 = { STRING1, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
 static STR s2 = { STRING2, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
@@ -78,18 +77,13 @@
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+	int optc;
 
 	(void)setlocale(LC_ALL, "");
 
-	if (caph_limit_stdio() == -1)
-		err(1, "unable to limit stdio");
-
-	if (caph_enter() < 0)
-		err(1, "unable to enter capability mode");
-
 	Cflag = cflag = dflag = sflag = 0;
-	while ((ch = getopt(argc, argv, "Ccdsu")) != -1)
-		switch((char)ch) {
+	while ((optc = getopt(argc, argv, "Ccdsu")) != -1)
+		switch(optc) {
 		case 'C':
 			Cflag = 1;
 			cflag = 0;
@@ -119,6 +113,7 @@
 	default:
 		usage();
 		/* NOTREACHED */
+		return 1;
 	case 1:
 		isstring2 = 0;
 		break;
@@ -307,7 +302,7 @@
 
 		s2.str = argv[1];
 		s2.state = NORMAL;
-		for (cnt = 0; cnt < n; cnt++) {
+		for (cnt = 0; cnt < (wint_t)n; cnt++) {
 			(void)next(&s2);
 			cmap_add(map, carray[cnt], s2.lastch);
 			/*
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/truncate/truncate.c src.freebsd/coreutils/truncate/truncate.c
--- src.orig/coreutils/truncate/truncate.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/truncate/truncate.c	2023-01-13 18:21:52.685545124 +0100
@@ -27,7 +27,7 @@
  *
  */
 
-static const char rcsid[] =
+__attribute__((unused)) static const char rcsid[] =
     "$FreeBSD$";
 
 #include <sys/stat.h>
@@ -39,8 +39,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdint.h>
 
-#include <libutil.h>
+#include "compat.h"
 
 static void	usage(void);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tsort/tsort.c src.freebsd/coreutils/tsort/tsort.c
--- src.orig/coreutils/tsort/tsort.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tsort/tsort.c	2023-01-13 18:21:52.685545124 +0100
@@ -48,7 +48,6 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <db.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -98,7 +97,83 @@
 	int b_bsize;
 } BUF;
 
-static DB *db;
+#define HASH_CHUNK_SIZE 64
+#define HASH_BUCKET_COUNT 1024
+
+struct hash_elem {
+	NODE *elem;
+	struct hash_elem *next;
+};
+
+struct hash_chunk {
+	struct hash_elem elems[HASH_CHUNK_SIZE];
+	struct hash_chunk *next;
+};
+
+struct hash {
+	struct hash_elem **elems;
+	struct hash_chunk *chunks;
+	struct hash_elem *top;
+};
+
+static void hash_init(struct hash *h) {
+	h->chunks = NULL;
+	h->top = NULL;
+	h->elems = calloc(1024, sizeof(struct hash_elem *));
+}
+
+static void hash_destroy(struct hash *h) {
+	for (size_t i = 0; i < HASH_BUCKET_COUNT; ++i) {
+		struct hash_elem *e = h->elems[i];
+		while (e) {
+			free(e->elem->n_arcs);
+			free(e->elem);
+			e = e->next;
+		}
+	}
+	free(h->elems);
+	while (h->chunks) {
+		struct hash_chunk *c = h->chunks;
+		h->chunks = h->chunks->next;
+		free(c);
+	}
+}
+
+static size_t hash_key(char *key) {
+	size_t h = 5381;
+	for (size_t i = 0, k; (k = key[i]); ++i)
+		h = ((h << 5) + h) ^ k;
+	return h;
+}
+
+static NODE *hash_find(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	for (struct hash_elem *c = h->elems[hash]; c; c = c->next) {
+		if (!strcmp(key, c->elem->n_name))
+			return c->elem;
+	}
+	return NULL;
+}
+
+static struct hash_elem *hash_insert(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	if (!h->top) {
+		struct hash_chunk *c = calloc(1, sizeof(struct hash_chunk));
+		c->next = h->chunks;
+		h->chunks = c;
+		for (size_t i = 0; i < (HASH_CHUNK_SIZE - 1); ++i) 
+			c->elems[i].next = &c->elems[i + 1];
+		c->elems[HASH_CHUNK_SIZE - 1].next = h->top;
+		h->top = c->elems;
+	}
+	struct hash_elem *hc = h->top;
+	h->top = h->top->next;
+	hc->next = h->elems[hash];
+	h->elems[hash] = hc;
+	return hc;
+}
+
+static struct hash db;
 static NODE *graph, **cycle_buf, **longest_cycle;
 static int debug, longest, quiet;
 
@@ -154,6 +229,8 @@
 	for (b = bufs, n = 2; --n >= 0; b++)
 		b->b_buf = grow_buf(NULL, b->b_bsize = 1024);
 
+	hash_init(&db);
+
 	/* parse input and build the graph */
 	for (n = 0, c = getc(fp);;) {
 		while (c != EOF && isspace(c))
@@ -183,6 +260,7 @@
 
 	/* do the sort */
 	tsort();
+	hash_destroy(&db);
 	exit(0);
 }
 
@@ -237,28 +315,15 @@
 static NODE *
 get_node(char *name)
 {
-	DBT data, key;
-	NODE *n;
+	NODE *n = hash_find(&db, name);
+	size_t nlen;
 
-	if (db == NULL &&
-	    (db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == NULL)
-		err(1, "db: %s", name);
-
-	key.data = name;
-	key.size = strlen(name) + 1;
+	if (n)
+		return n;
 
-	switch ((*db->get)(db, &key, &data, 0)) {
-	case 0:
-		bcopy(data.data, &n, sizeof(n));
-		return (n);
-	case 1:
-		break;
-	default:
-	case -1:
-		err(1, "db: %s", name);
-	}
+	nlen = strlen(name) + 1;
 
-	if ((n = malloc(sizeof(NODE) + key.size)) == NULL)
+	if ((n = malloc(sizeof(NODE) + nlen)) == NULL)
 		err(1, NULL);
 
 	n->n_narcs = 0;
@@ -266,7 +331,7 @@
 	n->n_arcs = NULL;
 	n->n_refcnt = 0;
 	n->n_flags = 0;
-	bcopy(name, n->n_name, key.size);
+	bcopy(name, n->n_name, nlen);
 
 	/* Add to linked list. */
 	if ((n->n_next = graph) != NULL)
@@ -275,10 +340,7 @@
 	graph = n;
 
 	/* Add to hash table. */
-	data.data = &n;
-	data.size = sizeof(n);
-	if ((*db->put)(db, &key, &data, 0))
-		err(1, "db: %s", name);
+	hash_insert(&db, name)->elem = n;
 	return (n);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/tty/tty.c src.freebsd/coreutils/tty/tty.c
--- src.orig/coreutils/tty/tty.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/tty/tty.c	2023-01-13 18:21:52.685545124 +0100
@@ -48,6 +48,8 @@
 #include <stdlib.h>
 #include <unistd.h>
 
+extern char *__progname;
+
 static void usage(void);
 
 int
@@ -77,6 +79,6 @@
 static void
 usage(void)
 {
-	fprintf(stderr, "usage: %s [-s]\n", getprogname());
+	fprintf(stderr, "usage: %s [-s]\n", __progname);
 	exit(2);
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/uname/uname.c src.freebsd/coreutils/uname/uname.c
--- src.orig/coreutils/uname/uname.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/uname/uname.c	2023-01-13 18:21:52.685545124 +0100
@@ -49,15 +49,14 @@
 #endif
 
 #include <sys/param.h>
-#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 
-#include <osreldate.h>
-
 #define	MFLAG	0x01
 #define	NFLAG	0x02
 #define	PFLAG	0x04
@@ -205,95 +204,39 @@
 	printf("\n");
 }
 
-#define	NATIVE_SYSCTL2_GET(var,mib0,mib1)	\
-static void					\
-native_##var(void)				\
-{						\
-	int mib[] = { (mib0), (mib1) };		\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctl(mib, sizeof mib / sizeof mib[0],	\
-	   &buf, &len, NULL, 0) == -1)		\
-		err(1, "sysctl");
-
-#define	NATIVE_SYSCTLNAME_GET(var,name)		\
-static void					\
-native_##var(void)				\
-{						\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctlbyname(name, &buf, &len, NULL,\
-	    0) == -1)				\
-		err(1, "sysctlbyname");
-
-#define	NATIVE_SET				\
-	*varp = buf;				\
-	return;					\
-}	struct __hack
-
-#define	NATIVE_BUFFER	(buf)
-#define	NATIVE_LENGTH	(len)
-
-NATIVE_SYSCTL2_GET(sysname, CTL_KERN, KERN_OSTYPE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(hostname, CTL_KERN, KERN_HOSTNAME) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(release, CTL_KERN, KERN_OSRELEASE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(version, CTL_KERN, KERN_VERSION) {
-	size_t n;
-	char *p;
-
-	p = NATIVE_BUFFER;
-	n = NATIVE_LENGTH;
-	for (; n--; ++p)
-		if (*p == '\n' || *p == '\t') {
-			if (n > 1)
-				*p = ' ';
-			else
-				*p = '\0';
-		}
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(platform, CTL_HW, HW_MACHINE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(arch, CTL_HW, HW_MACHINE_ARCH) {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(ident, "kern.ident") {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(buildid, "kern.build_id") {
-} NATIVE_SET;
-
-static void
-native_uservers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", __FreeBSD_version);
-	uservers = buf;
+#define NATIVE_UNAME_GET(var,field) \
+static void \
+native_##var(void) \
+{ \
+	static char buf[1024]; \
+	struct utsname u; \
+ \
+	if (uname(&u) != 0) \
+		err(1, "uname"); \
+\
+	snprintf(buf, sizeof(buf), "%s", u.field); \
+	var = buf; \
 }
 
-static void
-native_kernvers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", getosreldate());
-	kernvers = buf;
+NATIVE_UNAME_GET(sysname, sysname)
+NATIVE_UNAME_GET(hostname, nodename)
+NATIVE_UNAME_GET(release, release)
+NATIVE_UNAME_GET(version, version)
+NATIVE_UNAME_GET(platform, machine)
+
+#define UNKNOWN_GET(var) \
+static void \
+native_##var(void) \
+{ \
+	var = "unknown"; \
 }
 
+UNKNOWN_GET(arch)
+UNKNOWN_GET(ident)
+UNKNOWN_GET(buildid)
+UNKNOWN_GET(uservers)
+UNKNOWN_GET(kernvers)
+
 static void
 usage(void)
 {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/uniq/uniq.c src.freebsd/coreutils/uniq/uniq.c
--- src.orig/coreutils/uniq/uniq.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/uniq/uniq.c	2023-01-13 18:21:52.685545124 +0100
@@ -46,9 +46,6 @@
   "$FreeBSD$";
 #endif /* not lint */
 
-#include <sys/capsicum.h>
-
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -103,7 +100,6 @@
 	size_t prevbuflen, thisbuflen, b1;
 	char *prevline, *thisline, *p;
 	const char *ifn;
-	cap_rights_t rights;
 
 	(void) setlocale(LC_ALL, "");
 
@@ -159,32 +155,8 @@
 	ofp = stdout;
 	if (argc > 0 && strcmp(argv[0], "-") != 0)
 		ifp = file(ifn = argv[0], "r");
-	cap_rights_init(&rights, CAP_FSTAT, CAP_READ);
-	if (caph_rights_limit(fileno(ifp), &rights) < 0)
-		err(1, "unable to limit rights for %s", ifn);
-	cap_rights_init(&rights, CAP_FSTAT, CAP_WRITE);
 	if (argc > 1)
 		ofp = file(argv[1], "w");
-	else
-		cap_rights_set(&rights, CAP_IOCTL);
-	if (caph_rights_limit(fileno(ofp), &rights) < 0) {
-		err(1, "unable to limit rights for %s",
-		    argc > 1 ? argv[1] : "stdout");
-	}
-	if (cap_rights_is_set(&rights, CAP_IOCTL)) {
-		unsigned long cmd;
-
-		cmd = TIOCGETA; /* required by isatty(3) in printf(3) */
-
-		if (caph_ioctls_limit(fileno(ofp), &cmd, 1) < 0) {
-			err(1, "unable to limit ioctls for %s",
-			    argc > 1 ? argv[1] : "stdout");
-		}
-	}
-
-	caph_cache_catpages();
-	if (caph_enter() < 0)
-		err(1, "unable to enter capability mode");
 
 	prevbuflen = thisbuflen = 0;
 	prevline = thisline = NULL;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/users/users.cc src.freebsd/coreutils/users/users.cc
--- src.orig/coreutils/users/users.cc	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/users/users.cc	2023-01-13 18:21:52.685545124 +0100
@@ -30,9 +30,6 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
-
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <utmpx.h>
@@ -57,9 +54,6 @@
 
 	setutxent();
 
-	if (caph_enter())
-		err(1, "Failed to enter capability mode.");
-
 	while ((ut = getutxent()) != NULL)
 		if (ut->ut_type == USER_PROCESS)
 			names.insert(ut->ut_user);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/wc/wc.1 src.freebsd/coreutils/wc/wc.1
--- src.orig/coreutils/wc/wc.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/wc/wc.1	2023-01-13 18:21:52.685545124 +0100
@@ -130,7 +130,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/wc/wc.c src.freebsd/coreutils/wc/wc.c
--- src.orig/coreutils/wc/wc.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/wc/wc.c	2023-01-13 18:21:52.685545124 +0100
@@ -44,16 +44,16 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,10 +63,8 @@
 #include <wctype.h>
 #include <libxo/xo.h>
 
-#include <libcasper.h>
-#include <casper/cap_fileargs.h>
+#include "compat.h"
 
-static fileargs_t *fa;
 static uintmax_t tlinect, twordct, tcharct, tlongline;
 static int doline, doword, dochar, domulti, dolongline;
 static volatile sig_atomic_t siginfo;
@@ -78,7 +76,7 @@
 static void	usage(void);
 
 static void
-siginfo_handler(int sig __unused)
+siginfo_handler(int sig __attribute__((unused)))
 {
 
 	siginfo = 1;
@@ -96,7 +94,6 @@
 main(int argc, char *argv[])
 {
 	int ch, errors, total;
-	cap_rights_t rights;
 
 	(void) setlocale(LC_CTYPE, "");
 
@@ -132,26 +129,6 @@
 
 	(void)signal(SIGINFO, siginfo_handler);
 
-	fa = fileargs_init(argc, argv, O_RDONLY, 0,
-	    cap_rights_init(&rights, CAP_READ, CAP_FSTAT), FA_OPEN);
-	if (fa == NULL) {
-		xo_warn("Unable to init casper");
-		exit(1);
-	}
-
-	caph_cache_catpages();
-	if (caph_limit_stdio() < 0) {
-		xo_warn("Unable to limit stdio");
-		fileargs_free(fa);
-		exit(1);
-	}
-
-	if (caph_enter_casper() < 0) {
-		xo_warn("Unable to enter capability mode");
-		fileargs_free(fa);
-		exit(1);
-	}
-
 	/* Wc's flags are on by default. */
 	if (doline + doword + dochar + domulti + dolongline == 0)
 		doline = doword = dochar = 1;
@@ -185,7 +162,6 @@
 		xo_close_container("total");
 	}
 
-	fileargs_free(fa);
 	xo_close_container("wc");
 	xo_finish();
 	exit(errors == 0 ? 0 : 1);
@@ -234,7 +210,7 @@
 	linect = wordct = charct = llct = tmpll = 0;
 	if (file == NULL)
 		fd = STDIN_FILENO;
-	else if ((fd = fileargs_open(fa, file)) < 0) {
+	else if ((fd = open(file, O_RDONLY, 0)) < 0) {
 		xo_warn("%s: open", file);
 		return (1);
 	}
@@ -313,7 +289,7 @@
 			if (!domulti || MB_CUR_MAX == 1) {
 				clen = 1;
 				wch = (unsigned char)*p;
-			} else if ((clen = mbrtowc(&wch, p, len, &mbs)) ==
+			} else if ((clen = mbrtowc(&wch, (char *)p, len, &mbs)) ==
 			    (size_t)-1) {
 				if (!warned) {
 					errno = EILSEQ;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/who/who.c src.freebsd/coreutils/who/who.c
--- src.orig/coreutils/who/who.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/who/who.c	2023-01-13 18:21:52.685545124 +0100
@@ -45,10 +45,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
-#include <timeconv.h>
 #include <unistd.h>
 #include <utmpx.h>
 
+#include "compat.h"
+
 static void	heading(void);
 static void	process_utmp(void);
 static void	quick(void);
@@ -118,7 +119,7 @@
 		usage();
 
 	if (*argv != NULL) {
-		if (setutxdb(UTXDB_ACTIVE, *argv) != 0)
+		if (utmpxname(*argv) == 0)
 			err(1, "%s", *argv);
 	}
 
@@ -171,8 +172,10 @@
 	struct tm *tm;
 	char state;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		char *s = nl_langinfo(D_FMT);
+		d_first = (strchr(s, 'd') < strchr(s, 'm'));
+	}
 
 	state = '?';
 	idle = 0;
@@ -288,7 +291,7 @@
 	else
 		name = "?";
 	strlcpy(ut.ut_user, name, sizeof ut.ut_user);
-	gettimeofday(&ut.ut_tv, NULL);
+	gettimeofday((struct timeval *)&ut.ut_tv, NULL);
 	row(&ut);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/xinstall/install.1 src.freebsd/coreutils/xinstall/install.1
--- src.orig/coreutils/xinstall/install.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/xinstall/install.1	2023-01-13 18:21:52.685545124 +0100
@@ -39,7 +39,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -53,7 +52,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -116,7 +114,7 @@
 Copy the file.
 If the target file already exists and the files are the same,
 then do not change the modification time of the target.
-If the target's file flags and mode need not to be changed,
+If the target's mode needs not to be changed,
 the target's inode change time is also unchanged.
 .It Fl c
 Copy the file.
@@ -138,10 +136,6 @@
 .It Fl d
 Create directories.
 Missing parent directories are created as required.
-.It Fl f Ar flags
-Specify the target's file flags; see
-.Xr chflags 1
-for a list of possible flags and their meanings.
 .It Fl g Ar group
 Specify a group.
 A numeric GID is allowed.
@@ -198,7 +192,7 @@
 .Dq full path
 specification line.
 The metadata includes: the file name and file type, and depending upon
-other options, the owner, group, file flags, modification time, and tags.
+other options, the owner, group, modification time, and tags.
 .It Fl m Ar mode
 Specify an alternate mode.
 The default mode is set to rwxr-xr-x (0755).
@@ -256,7 +250,7 @@
 .Fl M Ar metalog .
 .It Fl U
 Indicate that install is running unprivileged, and that it should not
-try to change the owner, the group, or the file flags of the destination.
+try to change the owner or the group of the destination.
 The information that would have been updated can be stored in a log
 file with
 .Fl M Ar metalog .
@@ -267,12 +261,6 @@
 showing files as they are installed or backed up.
 .El
 .Pp
-By default,
-.Nm
-preserves all file flags, with the exception of the
-.Dq nodump
-flag.
-.Pp
 The
 .Nm
 utility attempts to prevent moving a file onto itself.
@@ -328,7 +316,6 @@
 The default was changed to copy in
 .Fx 4.4 .
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chgrp 1 ,
 .Xr chmod 1 ,
 .Xr cp 1 ,
@@ -358,15 +345,6 @@
 .Nm
 exits abnormally.
 .Pp
-File flags cannot be set by
-.Xr fchflags 2
-over a NFS file system.
-Other file systems do not have a concept of flags.
-The
-.Nm
-utility will only warn when flags could not be set on a file system
-that does not support them.
-.Pp
 The
 .Nm
 utility with
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/xinstall/xinstall.c src.freebsd/coreutils/xinstall/xinstall.c
--- src.orig/coreutils/xinstall/xinstall.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/xinstall/xinstall.c	2023-01-13 18:21:52.685545124 +0100
@@ -57,13 +57,8 @@
 #include <fcntl.h>
 #include <grp.h>
 #include <libgen.h>
-#include <md5.h>
 #include <paths.h>
 #include <pwd.h>
-#include <ripemd.h>
-#include <sha.h>
-#include <sha256.h>
-#include <sha512.h>
 #include <spawn.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -73,7 +68,9 @@
 #include <unistd.h>
 #include <vis.h>
 
-#include "mtree.h"
+#include <openssl/evp.h>
+
+#include "compat.h"
 
 /*
  * We need to build xinstall during the bootstrap stage when building on a
@@ -99,13 +96,7 @@
 #define	NOCHANGEBITS	(UF_IMMUTABLE | UF_APPEND | SF_IMMUTABLE | SF_APPEND)
 #define	BACKUP_SUFFIX	".old"
 
-typedef union {
-	MD5_CTX		MD5;
-	RIPEMD160_CTX	RIPEMD160;
-	SHA1_CTX	SHA1;
-	SHA256_CTX	SHA256;
-	SHA512_CTX	SHA512;
-}	DIGEST_CTX;
+typedef EVP_MD_CTX *DIGEST_CTX;
 
 static enum {
 	DIGEST_NONE = 0,
@@ -165,7 +156,7 @@
 	fset = 0;
 	iflags = 0;
 	group = owner = NULL;
-	while ((ch = getopt(argc, argv, "B:bCcD:df:g:h:l:M:m:N:o:pSsT:Uv")) !=
+	while ((ch = getopt(argc, argv, "B:bCcD:dg:h:l:M:m:o:pSsT:Uv")) !=
 	     -1)
 		switch((char)ch) {
 		case 'B':
@@ -186,10 +177,12 @@
 		case 'd':
 			dodir = 1;
 			break;
+#if 0
 		case 'f':
 			haveopt_f = 1;
 			fflags = optarg;
 			break;
+#endif
 		case 'g':
 			haveopt_g = 1;
 			group = optarg;
@@ -236,11 +229,13 @@
 			mode = getmode(set, 0);
 			free(set);
 			break;
+#if 0
 		case 'N':
 			if (!setup_getid(optarg))
 				err(EX_OSERR, "Unable to use user and group "
 				    "databases in `%s'", optarg);
 			break;
+#endif
 		case 'o':
 			haveopt_o = 1;
 			owner = optarg;
@@ -310,30 +305,38 @@
 
 	/* get group and owner id's */
 	if (group != NULL && !dounpriv) {
-		if (gid_from_group(group, &gid) == -1) {
+		struct group *gr = getgrnam(group);
+		if (!gr) {
 			id_t id;
 			if (!parseid(group, &id))
 				errx(1, "unknown group %s", group);
 			gid = id;
+		} else {
+			gid = gr->gr_gid;
 		}
 	} else
 		gid = (gid_t)-1;
 
 	if (owner != NULL && !dounpriv) {
-		if (uid_from_user(owner, &uid) == -1) {
+		struct passwd *pw = getpwnam(owner);
+		if (!pw) {
 			id_t id;
 			if (!parseid(owner, &id))
 				errx(1, "unknown user %s", owner);
 			uid = id;
+		} else {
+			uid = pw->pw_uid;
 		}
 	} else
 		uid = (uid_t)-1;
 
+#if 0
 	if (fflags != NULL && !dounpriv) {
 		if (strtofflags(&fflags, &fset, NULL))
 			errx(EX_USAGE, "%s: invalid flag", fflags);
 		iflags |= SETFLAGS;
 	}
+#endif
 
 	if (metafile != NULL) {
 		if ((metafp = fopen(metafile, "a")) == NULL)
@@ -384,8 +387,7 @@
 		if (stat(*argv, &from_sb))
 			err(EX_OSERR, "%s", *argv);
 		if (!S_ISREG(to_sb.st_mode)) {
-			errno = EFTYPE;
-			err(EX_OSERR, "%s", to_name);
+			errx(EX_OSERR, "%s: not a regular file", to_name);
 		}
 		if (to_sb.st_dev == from_sb.st_dev &&
 		    to_sb.st_ino == from_sb.st_ino)
@@ -400,91 +402,106 @@
 static char *
 digest_file(const char *name)
 {
+	DIGEST_CTX ctx;
+	FILE *f;
+	char *buf;
 
-	switch (digesttype) {
-	case DIGEST_MD5:
-		return (MD5File(name, NULL));
-	case DIGEST_RIPEMD160:
-		return (RIPEMD160_File(name, NULL));
-	case DIGEST_SHA1:
-		return (SHA1_File(name, NULL));
-	case DIGEST_SHA256:
-		return (SHA256_File(name, NULL));
-	case DIGEST_SHA512:
-		return (SHA512_File(name, NULL));
-	default:
-		return (NULL);
+	if (digesttype == DIGEST_NONE)
+		return NULL;
+
+	f = fopen(name, "rb");
+	if (!f)
+		errx(1, "unable to open file %s", name);
+
+	buf = malloc(16 * 1024);
+	if (!buf) {
+		fclose(f);
+		errx(1, "unable to allocate buffer");
+	}
+
+	digest_init(&ctx);
+	for (;;) {
+		size_t n = fread(buf, 1, 16 * 1024, f);
+		digest_update(&ctx, buf, n);
+		if (n != (16 * 1024)) {
+			if (feof(f))
+				break;
+			if (ferror(f)) {
+				free(buf);
+				fclose(f);
+				errx(1, "unable to read file %s", name);
+			}
+		}
 	}
+
+	fclose(f);
+	return digest_end(&ctx, NULL);
 }
 
 static void
 digest_init(DIGEST_CTX *c)
 {
+	const EVP_MD *digestmd = NULL;
 
 	switch (digesttype) {
 	case DIGEST_NONE:
 		break;
 	case DIGEST_MD5:
-		MD5Init(&(c->MD5));
+		digestmd = EVP_md5();
 		break;
 	case DIGEST_RIPEMD160:
-		RIPEMD160_Init(&(c->RIPEMD160));
+		digestmd = EVP_ripemd160();
 		break;
 	case DIGEST_SHA1:
-		SHA1_Init(&(c->SHA1));
+		digestmd = EVP_sha1();
 		break;
 	case DIGEST_SHA256:
-		SHA256_Init(&(c->SHA256));
+		digestmd = EVP_sha256();
 		break;
 	case DIGEST_SHA512:
-		SHA512_Init(&(c->SHA512));
+		digestmd = EVP_sha512();
 		break;
 	}
+
+	if (digestmd) {
+		*c = EVP_MD_CTX_new();
+		if (!c || !EVP_DigestInit_ex(*c, digestmd, NULL))
+			errx(1, "failed to initialize digest");
+	}
 }
 
 static void
 digest_update(DIGEST_CTX *c, const char *data, size_t len)
 {
+	if (digesttype == DIGEST_NONE)
+		return;
 
-	switch (digesttype) {
-	case DIGEST_NONE:
-		break;
-	case DIGEST_MD5:
-		MD5Update(&(c->MD5), data, len);
-		break;
-	case DIGEST_RIPEMD160:
-		RIPEMD160_Update(&(c->RIPEMD160), data, len);
-		break;
-	case DIGEST_SHA1:
-		SHA1_Update(&(c->SHA1), data, len);
-		break;
-	case DIGEST_SHA256:
-		SHA256_Update(&(c->SHA256), data, len);
-		break;
-	case DIGEST_SHA512:
-		SHA512_Update(&(c->SHA512), data, len);
-		break;
-	}
+	EVP_DigestUpdate(*c, data, len);
 }
 
 static char *
 digest_end(DIGEST_CTX *c, char *buf)
 {
+	unsigned char digbuf[EVP_MAX_MD_SIZE + 1];
 
-	switch (digesttype) {
-	case DIGEST_MD5:
-		return (MD5End(&(c->MD5), buf));
-	case DIGEST_RIPEMD160:
-		return (RIPEMD160_End(&(c->RIPEMD160), buf));
-	case DIGEST_SHA1:
-		return (SHA1_End(&(c->SHA1), buf));
-	case DIGEST_SHA256:
-		return (SHA256_End(&(c->SHA256), buf));
-	case DIGEST_SHA512:
-		return (SHA512_End(&(c->SHA512), buf));
-	default:
-		return (NULL);
+	if ((digesttype == DIGEST_NONE) || !*c)
+		return NULL;
+
+	unsigned int mdlen = 0;
+	if (!EVP_DigestFinal(*c, digbuf, &mdlen))
+		errx(1, "failed to finalize digest");
+
+	if (!buf) {
+		buf = malloc(mdlen * 2 + 1);
+		if (!buf)
+			errx(1, "unable to allocate buffer");
 	}
+
+	for (unsigned int i = 0; i < mdlen; ++i) {
+	    sprintf(buf + (i * 2), "%02x", digbuf[i]);
+	}
+
+	return buf;
 }
 
 /*
@@ -529,7 +546,7 @@
 do_link(const char *from_name, const char *to_name,
     const struct stat *target_sb)
 {
-	char tmpl[MAXPATHLEN];
+	char tmpl[MAXPATHLEN + 12];
 	int ret;
 
 	if (safecopy && target_sb != NULL) {
@@ -714,7 +731,6 @@
 				errx(1, "resolved pathname too long");
 		}
 		strcpy(to_name_copy, to_name);
-		cp = basename(to_name_copy);
 		if (strlcat(dst, cp, sizeof(dst)) > sizeof(dst))
 			errx(1, "resolved pathname too long");
 		free(to_name_copy);
@@ -763,7 +779,7 @@
  *	build a path name and install the file
  */
 static void
-install(const char *from_name, const char *to_name, u_long fset, u_int flags)
+install(const char *from_name, const char *to_name, u_long fset __attribute__((unused)), u_int flags)
 {
 	struct stat from_sb, temp_sb, to_sb;
 	struct timespec tsb[2];
@@ -783,8 +799,7 @@
 			if (stat(from_name, &from_sb))
 				err(EX_OSERR, "%s", from_name);
 			if (!S_ISREG(from_sb.st_mode)) {
-				errno = EFTYPE;
-				err(EX_OSERR, "%s", from_name);
+				errx(EX_OSERR, "%s: not a regular file", from_name);
 			}
 		}
 		/* Build the target path. */
@@ -818,8 +833,7 @@
 	}
 
 	if (target && !S_ISREG(to_sb.st_mode) && !S_ISLNK(to_sb.st_mode)) {
-		errno = EFTYPE;
-		warn("%s", to_name);
+		warnx("%s: not a regular file or a symlink", to_name);
 		return;
 	}
 
@@ -1068,14 +1082,14 @@
  *	unless it points to pre-computed digest.
  */
 static int
-compare(int from_fd, const char *from_name __unused, size_t from_len,
-	int to_fd, const char *to_name __unused, size_t to_len,
+compare(int from_fd, const char *from_name __attribute__((unused)), size_t from_len,
+	int to_fd, const char *to_name __attribute__((unused)), size_t to_len,
 	char **dresp)
 {
 	char *p, *q;
 	int rv;
 	int do_digest, done_compare;
-	DIGEST_CTX ctx;
+	DIGEST_CTX ctx = NULL;
 
 	rv = 0;
 	if (from_len != to_len)
@@ -1171,7 +1185,7 @@
  *	create a new file, overwriting an existing one if necessary
  */
 static int
-create_newfile(const char *path, int target, struct stat *sbp)
+create_newfile(const char *path, int target, struct stat *sbp __attribute__((unused)))
 {
 	char backup[MAXPATHLEN];
 	int saved_errno = 0;
@@ -1336,13 +1350,14 @@
 	    __DECONST(char **, args), environ);
 	if (error != 0) {
 		(void)unlink(to_name);
-		errc(error == EAGAIN || error == EPROCLIM || error == ENOMEM ?
-		    EX_TEMPFAIL : EX_OSERR, error, "spawn %s", stripbin);
+		errno = error;
+		err(EX_OSERR, "spawn %s", stripbin);
 	}
 	if (waitpid(pid, &status, 0) == -1) {
 		error = errno;
 		(void)unlink(to_name);
-		errc(EX_SOFTWARE, error, "wait");
+		errno = error;
+		err(EX_SOFTWARE, "wait");
 		/* NOTREACHED */
 	}
 	if (status != 0) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/coreutils/yes/yes.c src.freebsd/coreutils/yes/yes.c
--- src.orig/coreutils/yes/yes.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/coreutils/yes/yes.c	2023-01-13 18:21:52.689542732 +0100
@@ -43,7 +43,6 @@
 #endif
 #endif /* not lint */
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <stdio.h>
 #include <string.h>
@@ -60,9 +59,6 @@
 	size_t more;
 	ssize_t ret;
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	if (argc > 1) {
 		exp = argv[1];
 		explen = strlen(exp) + 1;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/cmp/cmp.c src.freebsd/diffutils/cmp/cmp.c
--- src.orig/diffutils/cmp/cmp.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/cmp/cmp.c	2023-01-13 18:21:52.689542732 +0100
@@ -47,7 +47,6 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -58,9 +57,8 @@
 #include <string.h>
 #include <unistd.h>
 
-#include <libutil.h>
-
 #include "extern.h"
+#include "compat.h"
 
 bool	bflag, lflag, sflag, xflag, zflag;
 
@@ -78,7 +76,7 @@
 static void usage(void);
 
 static bool
-parse_iskipspec(char *spec, off_t *skip1, off_t *skip2)
+parse_iskipspec(char *spec, uint64_t *skip1, uint64_t *skip2)
 {
 	char *colon;
 
@@ -100,7 +98,7 @@
 main(int argc, char *argv[])
 {
 	struct stat sb1, sb2;
-	off_t skip1, skip2, limit;
+	uint64_t skip1, skip2, limit;
 	int ch, fd1, fd2, oflag;
 	bool special;
 	const char *file1, *file2;
@@ -127,7 +125,7 @@
 			lflag = true;
 			break;
 		case 'n':		/* Limit */
-			if (expand_number(optarg, &limit) < 0 || limit < 0) {
+			if (expand_number(optarg, &limit) < 0) {
 				fprintf(stderr, "Invalid --bytes: %s\n",
 				    optarg);
 				usage();
@@ -156,12 +154,6 @@
 	if (argc < 2 || argc > 4)
 		usage();
 
-	/* Don't limit rights on stdin since it may be one of the inputs. */
-	if (caph_limit_stream(STDOUT_FILENO, CAPH_WRITE | CAPH_IGNORE_EBADF))
-		err(ERR_EXIT, "unable to limit rights on stdout");
-	if (caph_limit_stream(STDERR_FILENO, CAPH_WRITE | CAPH_IGNORE_EBADF))
-		err(ERR_EXIT, "unable to limit rights on stderr");
-
 	/* Backward compatibility -- handle "-" meaning stdin. */
 	special = false;
 	if (strcmp(file1 = argv[0], "-") == 0) {
@@ -216,9 +208,6 @@
 			exit(ERR_EXIT);
 	}
 
-	/* FD rights are limited in c_special() and c_regular(). */
-	caph_cache_catpages();
-
 	if (!special) {
 		if (fstat(fd1, &sb1)) {
 			if (!sflag)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/cmp/extern.h src.freebsd/diffutils/cmp/extern.h
--- src.orig/diffutils/cmp/extern.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/cmp/extern.h	2023-01-13 18:21:52.689542732 +0100
@@ -34,6 +34,8 @@
  *
  */
 
+#include <stdbool.h>
+
 #define OK_EXIT		0
 #define DIFF_EXIT	1
 #define ERR_EXIT	2	/* error exit code */
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/cmp/regular.c src.freebsd/diffutils/cmp/regular.c
--- src.orig/diffutils/cmp/regular.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/cmp/regular.c	2023-01-13 18:21:52.689542732 +0100
@@ -41,8 +41,8 @@
 #include <sys/param.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <limits.h>
 #include <signal.h>
@@ -63,7 +63,6 @@
     int fd2, const char *file2, off_t skip2, off_t len2, off_t limit)
 {
 	struct sigaction act, oact;
-	cap_rights_t rights;
 	u_char ch, *p1, *p2, *m1, *m2, *e1, *e2;
 	off_t byte, length, line;
 	off_t pagemask, off1, off2;
@@ -100,13 +99,6 @@
 		return;
 	}
 
-	if (caph_rights_limit(fd1, cap_rights_init(&rights, CAP_MMAP_R)) < 0)
-		err(1, "unable to limit rights for %s", file1);
-	if (caph_rights_limit(fd2, cap_rights_init(&rights, CAP_MMAP_R)) < 0)
-		err(1, "unable to limit rights for %s", file2);
-	if (caph_enter() < 0)
-		err(ERR_EXIT, "unable to enter capability mode");
-
 	sigemptyset(&act.sa_mask);
 	act.sa_flags = SA_NODEFER;
 	act.sa_handler = segv_handler;
@@ -181,7 +173,7 @@
 }
 
 static void
-segv_handler(int sig __unused) {
+segv_handler(int sig __attribute__((unused))) {
 	static const char msg[] = "cmp: Input/output error (caught SIGSEGV)\n";
 
 	write(STDERR_FILENO, msg, sizeof(msg));
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/cmp/special.c src.freebsd/diffutils/cmp/special.c
--- src.orig/diffutils/cmp/special.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/cmp/special.c	2023-01-13 18:21:52.689542732 +0100
@@ -40,7 +40,6 @@
 
 #include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -56,13 +55,6 @@
 	FILE *fp1, *fp2;
 	int dfound;
 
-	if (caph_limit_stream(fd1, CAPH_READ) < 0)
-		err(ERR_EXIT, "caph_limit_stream(%s)", file1);
-	if (caph_limit_stream(fd2, CAPH_READ) < 0)
-		err(ERR_EXIT, "caph_limit_stream(%s)", file2);
-	if (caph_enter() < 0)
-		err(ERR_EXIT, "unable to enter capability mode");
-
 	if ((fp1 = fdopen(fd1, "r")) == NULL)
 		err(ERR_EXIT, "%s", file1);
 	if ((fp2 = fdopen(fd2, "r")) == NULL)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/diff/diff.1 src.freebsd/diffutils/diff/diff.1
--- src.orig/diffutils/diff/diff.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/diff/diff.1	2023-01-13 18:21:52.689542732 +0100
@@ -82,7 +82,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -107,7 +106,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -133,7 +131,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -163,7 +160,6 @@
 .Op Fl -new-file
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -recursive
 .Op Fl -report-identical-files
@@ -354,10 +350,6 @@
 .Dq A
 will compare equal to
 .Dq a .
-.It Fl l -paginate
-Pass the output through
-.Xr pr 1
-to paginate it.
 .It Fl L Ar label Fl -label Ar label
 Print
 .Ar label
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/diff/diff.c src.freebsd/diffutils/diff/diff.c
--- src.orig/diffutils/diff/diff.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/diff/diff.c	2023-01-13 18:21:52.689542732 +0100
@@ -37,8 +37,9 @@
 
 #include "diff.h"
 #include "xmalloc.h"
+#include "compat.h"
 
-int	 lflag, Nflag, Pflag, rflag, sflag, Tflag, cflag, Wflag;
+int	 Nflag, Pflag, rflag, sflag, Tflag, cflag, Wflag;
 int	 diff_format, diff_context, status, ignore_file_case, suppress_common;
 int	 tabsize = 8, width = 130;
 char	*start, *ifdefname, *diffargs, *label[2], *ignore_pats;
@@ -47,7 +48,7 @@
 struct excludes *excludes_list;
 regex_t	 ignore_re;
 
-#define	OPTIONS	"0123456789aBbC:cdD:efHhI:iL:lnNPpqrS:sTtU:uwW:X:x:y"
+#define	OPTIONS	"0123456789aBbC:cdD:efHhI:iL:nNPpqrS:sTtU:uwW:X:x:y"
 enum {
 	OPT_TSIZE = CHAR_MAX + 1,
 	OPT_STRIPCR,
@@ -71,7 +72,6 @@
 	{ "ignore-blank-lines",		no_argument,		0,	'B' },
 	{ "ignore-matching-lines",	required_argument,	0,	'I' },
 	{ "ignore-case",		no_argument,		0,	'i' },
-	{ "paginate",			no_argument,		NULL,	'l' },
 	{ "label",			required_argument,	0,	'L' },
 	{ "new-file",			no_argument,		0,	'N' },
 	{ "rcs",			no_argument,		0,	'n' },
@@ -198,9 +198,6 @@
 			else
 				usage();
 			break;
-		case 'l':
-			lflag = 1;
-			break;
 		case 'N':
 			Nflag = 1;
 			break;
@@ -379,12 +376,12 @@
 		diffdir(argv[0], argv[1], dflags);
 	} else {
 		if (S_ISDIR(stb1.st_mode)) {
-			argv[0] = splice(argv[0], argv[1]);
+			argv[0] = dsplice(argv[0], argv[1]);
 			if (stat(argv[0], &stb1) == -1)
 				err(2, "%s", argv[0]);
 		}
 		if (S_ISDIR(stb2.st_mode)) {
-			argv[1] = splice(argv[1], argv[0]);
+			argv[1] = dsplice(argv[1], argv[0]);
 			if (stat(argv[1], &stb2) == -1)
 				err(2, "%s", argv[1]);
 		}
@@ -418,20 +415,23 @@
 read_excludes_file(char *file)
 {
 	FILE *fp;
-	char *buf, *pattern;
-	size_t len;
+	char *pattern = NULL;
+	size_t blen = 0;
+	ssize_t len;
 
 	if (strcmp(file, "-") == 0)
 		fp = stdin;
 	else if ((fp = fopen(file, "r")) == NULL)
 		err(2, "%s", file);
-	while ((buf = fgetln(fp, &len)) != NULL) {
-		if (buf[len - 1] == '\n')
-			len--;
-		if ((pattern = strndup(buf, len)) == NULL)
-			err(2, "xstrndup");
+	while ((len = getline(&pattern, &blen, fp)) >= 0) {
+		if ((len > 0) && (pattern[len - 1] == '\n'))
+			pattern[len - 1] = '\0';
 		push_excludes(pattern);
+		/* we allocate a new string per line */
+		pattern = NULL;
+		blen = 0;
 	}
+	free(pattern);
 	if (strcmp(file, "-") != 0)
 		fclose(fp);
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/diff/diff.h src.freebsd/diffutils/diff/diff.h
--- src.orig/diffutils/diff/diff.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/diff/diff.h	2023-01-13 18:21:52.689542732 +0100
@@ -100,8 +100,16 @@
 extern struct	excludes *excludes_list;
 extern regex_t	ignore_re;
 
-char	*splice(char *, char *);
+char	*dsplice(char *, char *);
 int	diffreg(char *, char *, int, int);
 void	diffdir(char *, char *, int);
 void	print_only(const char *, size_t, const char *);
 void	print_status(int, char *, char *, const char *);
+
+#ifndef MIN
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
+#endif
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/diff/diffdir.c src.freebsd/diffutils/diff/diffdir.c
--- src.orig/diffutils/diff/diffdir.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/diff/diffdir.c	2023-01-13 18:21:52.689542732 +0100
@@ -35,6 +35,7 @@
 #include <limits.h>
 
 #include "diff.h"
+#include "compat.h"
 
 static int selectfile(const struct dirent *);
 static void diffit(struct dirent *, char *, size_t, char *, size_t, int);
@@ -57,7 +58,8 @@
 
 	dirlen1 = strlcpy(path1, *p1 ? p1 : ".", sizeof(path1));
 	if (dirlen1 >= sizeof(path1) - 1) {
-		warnc(ENAMETOOLONG, "%s", p1);
+		errno = ENAMETOOLONG;
+		warn("%s", p1);
 		status |= 2;
 		return;
 	}
@@ -67,7 +69,8 @@
 	}
 	dirlen2 = strlcpy(path2, *p2 ? p2 : ".", sizeof(path2));
 	if (dirlen2 >= sizeof(path2) - 1) {
-		warnc(ENAMETOOLONG, "%s", p2);
+		errno = ENAMETOOLONG;
+		warn("%s", p2);
 		status |= 2;
 		return;
 	}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/diff/diffreg.c src.freebsd/diffutils/diff/diffreg.c
--- src.orig/diffutils/diff/diffreg.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/diff/diffreg.c	2023-01-13 18:58:03.732562451 +0100
@@ -69,10 +69,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
 #include <sys/stat.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -85,10 +83,13 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <time.h>
 
-#include "pr.h"
 #include "diff.h"
 #include "xmalloc.h"
+#include "compat.h"
 
 /*
  * diff - compare two files.
@@ -259,8 +260,6 @@
 {
 	FILE *f1, *f2;
 	int i, rval;
-	struct pr *pr = NULL;
-	cap_rights_t rights_ro;
 
 	f1 = f2 = NULL;
 	rval = D_SAME;
@@ -339,29 +338,7 @@
 		goto closem;
 	}
 
-	if (lflag)
-		pr = start_pr(file1, file2);
-
-	if (capsicum) {
-		cap_rights_init(&rights_ro, CAP_READ, CAP_FSTAT, CAP_SEEK);
-		if (caph_rights_limit(fileno(f1), &rights_ro) < 0)
-			err(2, "unable to limit rights on: %s", file1);
-		if (caph_rights_limit(fileno(f2), &rights_ro) < 0)
-			err(2, "unable to limit rights on: %s", file2);
-		if (fileno(f1) == STDIN_FILENO || fileno(f2) == STDIN_FILENO) {
-			/* stdin has already been limited */
-			if (caph_limit_stderr() == -1)
-				err(2, "unable to limit stderr");
-			if (caph_limit_stdout() == -1)
-				err(2, "unable to limit stdout");
-		} else if (caph_limit_stdio() == -1)
-				err(2, "unable to limit stdio");
-
-		caph_cache_catpages();
-		caph_cache_tzdata();
-		if (caph_enter() < 0)
-			err(2, "unable to enter capability mode");
-	}
+	(void)capsicum;
 
 	switch (files_differ(f1, f2, flags)) {
 	case 0:
@@ -424,8 +401,6 @@
 	output(file1, f1, file2, f2, flags);
 
 closem:
-	if (pr != NULL)
-		stop_pr(pr);
 	if (anychange) {
 		status |= 1;
 		if (rval == D_SAME)
@@ -499,7 +474,7 @@
 }
 
 char *
-splice(char *dir, char *path)
+dsplice(char *dir, char *path)
 {
 	char *tail, *buf;
 	size_t dirlen;
@@ -1035,7 +1010,6 @@
 	int ret;
 
 	ret = regexec(&ignore_re, line, 0, NULL, 0);
-	free(line);
 	return (ret == 0);	/* if it matched, it should be ignored. */
 }
 
@@ -1043,13 +1017,10 @@
 ignoreline(char *line, bool skip_blanks)
 {
 
-	if (ignore_pats != NULL && skip_blanks)
-		return (ignoreline_pattern(line) || *line == '\0');
-	if (ignore_pats != NULL)
-		return (ignoreline_pattern(line));
-	if (skip_blanks)
-		return (*line == '\0');
-	/* No ignore criteria specified */
+	if (skip_blanks && *line == '\0')
+		return (true);
+	if (ignore_pats != NULL && ignoreline_pattern(line))
+		return (true);
 	return (false);
 }
 
@@ -1068,7 +1039,7 @@
 	long curpos;
 	int i, nc;
 	const char *walk;
-	bool skip_blanks;
+	bool skip_blanks, ignore;
 
 	skip_blanks = (*pflags & D_SKIPBLANKLINES);
 restart:
@@ -1086,7 +1057,9 @@
 			for (i = a; i <= b; i++) {
 				line = preadline(fileno(f1),
 				    ixold[i] - ixold[i - 1], ixold[i - 1]);
-				if (!ignoreline(line, skip_blanks))
+				ignore = ignoreline(line, skip_blanks);
+				free(line);
+				if (!ignore)
 					goto proceed;
 			}
 		}
@@ -1094,7 +1067,9 @@
 			for (i = c; i <= d; i++) {
 				line = preadline(fileno(f2),
 				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
-				if (!ignoreline(line, skip_blanks))
+				ignore = ignoreline(line, skip_blanks);
+				free(line);
+				if (!ignore)
 					goto proceed;
 			}
 		}
@@ -1376,6 +1351,7 @@
 		case '\0':
 			if ((flags & D_FORCEASCII) == 0)
 				return (RH_BINARY);
+			/* FALLTHROUGH */
 		case '\r':
 			if (flags & D_STRIPCR) {
 				t = getc(f);
@@ -1433,7 +1409,7 @@
 static char *
 match_function(const long *f, int pos, FILE *fp)
 {
-	unsigned char buf[FUNCTION_CONTEXT_SIZE];
+	char buf[FUNCTION_CONTEXT_SIZE];
 	size_t nc;
 	int last = lastline;
 	const char *state = NULL;
@@ -1652,41 +1628,18 @@
 static void
 print_header(const char *file1, const char *file2)
 {
-	const char *time_format;
-	char buf1[256];
-	char buf2[256];
-	char end1[10];
-	char end2[10];
-	struct tm tm1, tm2, *tm_ptr1, *tm_ptr2;
-	int nsec1 = stb1.st_mtim.tv_nsec;
-	int nsec2 = stb2.st_mtim.tv_nsec;
-
-	time_format = "%Y-%m-%d %H:%M:%S";
-
-	if (cflag)
-		time_format = "%c";
-	tm_ptr1 = localtime_r(&stb1.st_mtime, &tm1);
-	tm_ptr2 = localtime_r(&stb2.st_mtime, &tm2);
-	strftime(buf1, 256, time_format, tm_ptr1);
-	strftime(buf2, 256, time_format, tm_ptr2);
-	if (!cflag) {
-		strftime(end1, 10, "%z", tm_ptr1);
-		strftime(end2, 10, "%z", tm_ptr2);
-		sprintf(buf1, "%s.%.9d %s", buf1, nsec1, end1);
-		sprintf(buf2, "%s.%.9d %s", buf2, nsec2, end2);
-	}
 	if (label[0] != NULL)
 		printf("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
 		    label[0]);
 	else
-		printf("%s %s\t%s\n", diff_format == D_CONTEXT ? "***" : "---",
-		    file1, buf1);
+		printf("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
+		    file1, ctime(&stb1.st_mtime));
 	if (label[1] != NULL)
 		printf("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
 		    label[1]);
 	else
-		printf("%s %s\t%s\n", diff_format == D_CONTEXT ? "---" : "+++",
-		    file2, buf2);
+		printf("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
+		    file2, ctime(&stb2.st_mtime));
 }
 
 /*
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/diffutils/sdiff/sdiff.c src.freebsd/diffutils/sdiff/sdiff.c
--- src.orig/diffutils/sdiff/sdiff.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/diffutils/sdiff/sdiff.c	2023-01-13 18:21:52.689542732 +0100
@@ -28,6 +28,7 @@
 #include <unistd.h>
 
 #include "extern.h"
+#include "compat.h"
 
 static char diff_path[] = "/usr/bin/diff";
 
@@ -260,16 +261,19 @@
 		case 'E':
 		case 'i':
 		case 't':
-		case 'W':
-			diffargv[1]  = realloc(diffargv[1], sizeof(char) * strlen(diffargv[1]) + 2);
+		case 'W': {
+			int alen = strlen(diffargv[1]);
+			diffargv[1] = realloc(diffargv[1], sizeof(char) * alen + 2);
 			/*
 			 * In diff, the 'W' option is 'w' and the 'w' is 'W'.
 			 */
 			if (ch == 'W')
-				sprintf(diffargv[1], "%sw", diffargv[1]);
+				diffargv[1][alen] = 'w';
 			else
-				sprintf(diffargv[1], "%s%c", diffargv[1], ch);
+				diffargv[1][alen] = ch;
+			diffargv[1][alen + 1] = '\0';
 			break;
+		}
 		case 'H':
 			diffargv[diffargc++] = speed_lf;
 			break;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/ed/main.c src.freebsd/ed/main.c
--- src.orig/ed/main.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/ed/main.c	2023-01-13 18:21:52.689542732 +0100
@@ -59,6 +59,7 @@
 #include <setjmp.h>
 
 #include "ed.h"
+#include "compat.h"
 
 
 #ifdef _POSIX_SOURCE
@@ -212,6 +213,7 @@
 		switch (status) {
 		case EOF:
 			quit(0);
+			break; /* unreachable */
 		case EMOD:
 			modified = 0;
 			fputs("?\n", stderr);		/* give warning */
@@ -231,6 +233,7 @@
 			} else if (garrulous)
 				fprintf(stderr, "%s\n", errmsg);
 			quit(3);
+			break; /* unreachable */
 		default:
 			fputs("?\n", stderr);
 			if (!isatty(0)) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/extern.h src.freebsd/findutils/find/extern.h
--- src.orig/findutils/find/extern.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/extern.h	2023-01-13 18:21:52.693540340 +0100
@@ -33,6 +33,7 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
 
 void	 brace_subst(char *, char **, char *, size_t);
 PLAN	*find_create(char ***);
@@ -47,6 +48,7 @@
 int	 queryuser(char **);
 OPTION	*lookup_option(const char *);
 void	 finish_execplus(void);
+const char *f_fstypename(dev_t);
 
 creat_f	c_Xmin;
 creat_f	c_Xtime;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/find.1 src.freebsd/findutils/find/find.1
--- src.orig/findutils/find/find.1	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/find.1	2023-01-13 18:21:52.693540340 +0100
@@ -181,35 +181,6 @@
 and neither means
 .Dq exactly n .
 .Bl -tag -width indent
-.It Ic -Bmin Ar n
-True if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full minute, is
-.Ar n
-minutes.
-.It Ic -Bnewer Ar file
-Same as
-.Ic -newerBm .
-.It Ic -Btime Ar n Ns Op Cm smhdw
-If no units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full 24-hour period, is
-.Ar n
-24-hour periods.
-.Pp
-If units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started is exactly
-.Ar n
-units.
-Please refer to the
-.Ic -atime
-primary description for information on supported time units.
 .It Ic -acl
 May be used in conjunction with other primaries to locate
 files with extended ACLs.
@@ -431,50 +402,6 @@
 returns a non-zero exit status,
 .Nm
 will return a non-zero exit status.
-.It Ic -flags Oo Cm - Ns | Ns Cm + Oc Ns Ar flags , Ns Ar notflags
-The flags are specified using symbolic names (see
-.Xr chflags 1 ) .
-Those with the
-.Qq Li no
-prefix (except
-.Qq Li nodump )
-are said to be
-.Ar notflags .
-Flags in
-.Ar flags
-are checked to be set, and flags in
-.Ar notflags
-are checked to be not set.
-Note that this is different from
-.Ic -perm ,
-which only allows the user to specify mode bits that are set.
-.Pp
-If flags are preceded by a dash
-.Pq Dq Li - ,
-this primary evaluates to true
-if at least all of the bits in
-.Ar flags
-and none of the bits in
-.Ar notflags
-are set in the file's flags bits.
-If flags are preceded by a plus
-.Pq Dq Li + ,
-this primary evaluates to true
-if any of the bits in
-.Ar flags
-is set in the file's flags bits,
-or any of the bits in
-.Ar notflags
-is not set in the file's flags bits.
-Otherwise,
-this primary evaluates to true
-if the bits in
-.Ar flags
-exactly match the file's flags bits,
-and none of the
-.Ar flags
-bits match those of
-.Ar notflags .
 .It Ic -fstype Ar type
 True if the file is contained in a file system of type
 .Ar type .
@@ -482,15 +409,9 @@
 .Xr lsvfs 1
 command can be used to find out the types of file systems
 that are available on the system.
-In addition, there are two pseudo-types,
-.Dq Li local
-and
-.Dq Li rdonly .
-The former matches any file system physically mounted on the system where
-the
-.Nm
-is being executed and the latter matches any file system which is
-mounted read-only.
+In addition, there is a pseudotype
+.Dq Li rdonly
+that matches any file system which is mounted read-only.
 .It Ic -gid Ar gname
 The same thing as
 .Ic -group Ar gname
@@ -998,7 +919,6 @@
 .Sx STANDARDS
 section below for details.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr locate 1 ,
 .Xr lsvfs 1 ,
@@ -1028,9 +948,7 @@
 .Ic -amin , -anewer , -cmin , -cnewer , -delete , -empty , -fstype ,
 .Ic -iname , -inum , -iregex , -ls , -maxdepth , -mindepth , -mmin ,
 .Ic -not , -path , -print0 , -regex , -sparse
-and all of the
-.Fl B*
-birthtime related primaries are extensions to
+are extensions to
 .St -p1003.1-2001 .
 .Pp
 Historically, the
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/find.c src.freebsd/findutils/find/find.c
--- src.orig/findutils/find/find.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/find.c	2023-01-13 18:21:52.693540340 +0100
@@ -52,7 +52,7 @@
 
 #include "find.h"
 
-static int find_compare(const FTSENT * const *s1, const FTSENT * const *s2);
+static int find_compare(const FTSENT **s1, const FTSENT **s2);
 
 /*
  * find_compare --
@@ -61,7 +61,7 @@
  *	order within each directory.
  */
 static int
-find_compare(const FTSENT * const *s1, const FTSENT * const *s2)
+find_compare(const FTSENT **s1, const FTSENT **s2)
 {
 
 	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
@@ -235,7 +235,10 @@
 	}
 	e = errno;
 	finish_execplus();
-	if (e && (!ignore_readdir_race || e != ENOENT))
-		errc(1, e, "fts_read");
+	if (e && (!ignore_readdir_race || e != ENOENT)) {
+		errno = e;
+		err(1, "fts_read");
+	}
+	f_fstypename(0); /* free allocated filesystem type resources */
 	return (exitstatus);
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/find.h src.freebsd/findutils/find/find.h
--- src.orig/findutils/find/find.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/find.h	2023-01-13 18:21:52.693540340 +0100
@@ -56,11 +56,7 @@
 #else
 #define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #endif
-#if defined(MFSNAMELEN) || defined(MFSTYPENAMELEN)
 #define HAVE_STRUCT_STATFS_F_FSTYPENAME 1
-#else
-#define HAVE_STRUCT_STATFS_F_FSTYPENAME 0
-#endif
 
 /* forward declarations */
 struct _plandata;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/function.c src.freebsd/findutils/find/function.c
--- src.orig/findutils/find/function.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/function.c	2023-01-13 18:21:52.693540340 +0100
@@ -40,12 +40,12 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
-#include <sys/ucred.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
+#include <sys/statvfs.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -64,6 +64,12 @@
 
 #include "find.h"
 
+#include "compat.h"
+
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 static PLAN *palloc(OPTION *);
 static long long find_parsenum(PLAN *, const char *, char *, char *);
 static long long find_parsetime(PLAN *, const char *, char *);
@@ -371,7 +377,7 @@
  *	Show files with EXTENDED ACL attributes.
  */
 int
-f_acl(PLAN *plan __unused, FTSENT *entry)
+f_acl(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	acl_t facl;
 	acl_type_t acl_type;
@@ -418,7 +424,7 @@
 #endif
 
 PLAN *
-c_acl(OPTION *option, char ***argvp __unused)
+c_acl(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 	return (palloc(option));
@@ -430,7 +436,7 @@
  *	True always.  Makes its best shot and continues on regardless.
  */
 int
-f_delete(PLAN *plan __unused, FTSENT *entry)
+f_delete(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	/* ignore these from fts */
 	if (strcmp(entry->fts_accpath, ".") == 0 ||
@@ -475,7 +481,7 @@
 }
 
 PLAN *
-c_delete(OPTION *option, char ***argvp __unused)
+c_delete(OPTION *option, char ***argvp __attribute__((unused)))
 {
 
 	ftsoptions &= ~FTS_NOSTAT;	/* no optimise */
@@ -500,7 +506,7 @@
  *	Always true, used for -maxdepth, -mindepth, -xdev, -follow, and -true
  */
 int
-f_always_true(PLAN *plan __unused, FTSENT *entry __unused)
+f_always_true(PLAN *plan __attribute__((unused)), FTSENT *entry __attribute__((unused)))
 {
 	return 1;
 }
@@ -560,7 +566,7 @@
  *	True if the file or directory is empty
  */
 int
-f_empty(PLAN *plan __unused, FTSENT *entry)
+f_empty(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	if (S_ISREG(entry->fts_statp->st_mode) &&
 	    entry->fts_statp->st_size == 0)
@@ -588,7 +594,7 @@
 }
 
 PLAN *
-c_empty(OPTION *option, char ***argvp __unused)
+c_empty(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 
@@ -865,7 +871,7 @@
  *	basis.
  */
 PLAN *
-c_follow(OPTION *option, char ***argvp __unused)
+c_follow(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_PHYSICAL;
 	ftsoptions |= FTS_LOGICAL;
@@ -874,6 +880,64 @@
 }
 
 #if HAVE_STRUCT_STATFS_F_FSTYPENAME
+struct mntinfo {
+    dev_t devn;
+    char fstype[64];
+};
+
+const char *
+f_fstypename(dev_t curdev)
+{
+	static struct mntinfo *minfo = NULL;
+	static size_t ninfos = 0;
+	char curfstype[64];
+	/* to be freed */
+	if (!curdev) {
+		free(minfo);
+		minfo = NULL;
+		ninfos = 0;
+		return NULL;
+	}
+	if (!minfo) {
+		FILE *f = fopen("/proc/self/mountinfo", "rb");
+		if (!f)
+			return NULL;
+		char *lbuf = NULL;
+		size_t lsize = 0, ncap = 64;
+		minfo = malloc(ncap * sizeof(struct mntinfo));
+		if (!minfo)
+			err(1, "malloc");
+		const char *rfs = NULL;
+		while (getline(&lbuf, &lsize, f) > 0) {
+			unsigned int maj, min;
+			if (sscanf(
+			    lbuf, "%*d %*d %u:%u %*s %*s %*s %*s - %63s %*s %*s",
+			    &maj, &min, curfstype
+			) <= 0)
+				continue;
+			if (ninfos == ncap) {
+				ncap *= 2;
+				minfo = realloc(minfo, ncap * sizeof(struct mntinfo));
+				if (!minfo)
+					err(1, "realloc");
+			}
+			minfo[ninfos].devn = makedev(maj, min);
+			memcpy(minfo[ninfos].fstype, curfstype, sizeof(curfstype));
+			if (minfo[ninfos].devn == curdev)
+				rfs = minfo[ninfos].fstype;
+			++ninfos;
+		}
+		free(lbuf);
+		fclose(f);
+		return rfs;
+	}
+	for (size_t i = 0; i < ninfos; ++i) {
+		if (minfo[i].devn == curdev)
+			return minfo[i].fstype;
+	}
+	return NULL;
+}
+
 /*
  * -fstype functions --
  *
@@ -884,9 +948,9 @@
 {
 	static dev_t curdev;	/* need a guaranteed illegal dev value */
 	static int first = 1;
-	struct statfs sb;
-	static int val_flags;
-	static char fstype[sizeof(sb.f_fstypename)];
+	struct statvfs sb;
+	static unsigned long val_flags;
+	static const char *fstype;
 	char *p, save[2] = {0,0};
 
 	if ((plan->flags & F_MTMASK) == F_MTUNKNOWN)
@@ -897,7 +961,7 @@
 		curdev = entry->fts_statp->st_dev;
 
 		/*
-		 * Statfs follows symlinks; find wants the link's filesystem,
+		 * Statvfs follows symlinks; find wants the link's filesystem,
 		 * not where it points.
 		 */
 		if (entry->fts_info == FTS_SL ||
@@ -913,7 +977,7 @@
 		} else
 			p = NULL;
 
-		if (statfs(entry->fts_accpath, &sb)) {
+		if (statvfs(entry->fts_accpath, &sb)) {
 			if (!ignore_readdir_race || errno != ENOENT) {
 				warn("statfs: %s", entry->fts_accpath);
 				exitstatus = 1;
@@ -932,14 +996,14 @@
 		 * Further tests may need both of these values, so
 		 * always copy both of them.
 		 */
-		val_flags = sb.f_flags;
-		strlcpy(fstype, sb.f_fstypename, sizeof(fstype));
+		val_flags = sb.f_flag;
+		fstype = f_fstypename(curdev);
 	}
 	switch (plan->flags & F_MTMASK) {
 	case F_MTFLAG:
 		return val_flags & plan->mt_data;
 	case F_MTTYPE:
-		return (strncmp(fstype, plan->c_data, sizeof(fstype)) == 0);
+		return fstype && (strcmp(fstype, plan->c_data) == 0);
 	default:
 		abort();
 	}
@@ -956,17 +1020,10 @@
 
 	new = palloc(option);
 	switch (*fsname) {
-	case 'l':
-		if (!strcmp(fsname, "local")) {
-			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_LOCAL;
-			return new;
-		}
-		break;
 	case 'r':
 		if (!strcmp(fsname, "rdonly")) {
 			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_RDONLY;
+			new->mt_data = ST_RDONLY;
 			return new;
 		}
 		break;
@@ -1028,7 +1085,7 @@
  */
 
 PLAN *
-c_ignore_readdir_race(OPTION *option, char ***argvp __unused)
+c_ignore_readdir_race(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	if (strcmp(option->name, "-ignore_readdir_race") == 0)
 		ignore_readdir_race = 1;
@@ -1123,14 +1180,14 @@
  *	Always true - prints the current entry to stdout in "ls" format.
  */
 int
-f_ls(PLAN *plan __unused, FTSENT *entry)
+f_ls(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	printlong(entry->fts_path, entry->fts_accpath, entry->fts_statp);
 	return 1;
 }
 
 PLAN *
-c_ls(OPTION *option, char ***argvp __unused)
+c_ls(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 	isoutput = 1;
@@ -1259,13 +1316,15 @@
  *	of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.
  */
 int
-f_nogroup(PLAN *plan __unused, FTSENT *entry)
+f_nogroup(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
-	return group_from_gid(entry->fts_statp->st_gid, 1) == NULL;
+	struct group *gr;
+	gr = getgrgid(entry->fts_statp->st_gid);
+	return gr == NULL;
 }
 
 PLAN *
-c_nogroup(OPTION *option, char ***argvp __unused)
+c_nogroup(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 
@@ -1279,13 +1338,15 @@
  *	of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.
  */
 int
-f_nouser(PLAN *plan __unused, FTSENT *entry)
+f_nouser(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
-	return user_from_uid(entry->fts_statp->st_uid, 1) == NULL;
+	struct passwd *pw;
+	pw = getpwuid(entry->fts_statp->st_uid);
+	return pw == NULL;
 }
 
 PLAN *
-c_nouser(OPTION *option, char ***argvp __unused)
+c_nouser(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 
@@ -1320,7 +1381,7 @@
 	mode_t mode;
 
 	mode = entry->fts_statp->st_mode &
-	    (S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO);
+	    (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO);
 	if (plan->flags & F_ATLEAST)
 		return (plan->m_data | mode) == mode;
 	else if (plan->flags & F_ANY)
@@ -1365,14 +1426,14 @@
  *	standard output.
  */
 int
-f_print(PLAN *plan __unused, FTSENT *entry)
+f_print(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	(void)puts(entry->fts_path);
 	return 1;
 }
 
 PLAN *
-c_print(OPTION *option, char ***argvp __unused)
+c_print(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	isoutput = 1;
 
@@ -1386,7 +1447,7 @@
  *	standard output followed by a NUL character
  */
 int
-f_print0(PLAN *plan __unused, FTSENT *entry)
+f_print0(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	fputs(entry->fts_path, stdout);
 	fputc('\0', stdout);
@@ -1401,7 +1462,7 @@
  *	Prune a portion of the hierarchy.
  */
 int
-f_prune(PLAN *plan __unused, FTSENT *entry)
+f_prune(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	if (fts_set(tree, entry, FTS_SKIP))
 		err(1, "%s", entry->fts_path);
@@ -1480,7 +1541,7 @@
 /* c_simple covers c_prune, c_openparen, c_closeparen, c_not, c_or, c_true, c_false */
 
 PLAN *
-c_simple(OPTION *option, char ***argvp __unused)
+c_simple(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	return palloc(option);
 }
@@ -1562,7 +1623,7 @@
  *      than we expect based on its size.
  */
 int
-f_sparse(PLAN *plan __unused, FTSENT *entry)
+f_sparse(PLAN *plan __attribute__((unused)), FTSENT *entry)
 {
 	off_t expected_blocks;
 
@@ -1571,7 +1632,7 @@
 }
 
 PLAN *
-c_sparse(OPTION *option, char ***argvp __unused)
+c_sparse(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions &= ~FTS_NOSTAT;
 
@@ -1692,7 +1753,7 @@
  *	different device ID (st_dev, see stat() S5.6.2 [POSIX.1])
  */
 PLAN *
-c_xdev(OPTION *option, char ***argvp __unused)
+c_xdev(OPTION *option, char ***argvp __attribute__((unused)))
 {
 	ftsoptions |= FTS_XDEV;
 
@@ -1723,13 +1784,13 @@
  */
 
 int
-f_openparen(PLAN *plan __unused, FTSENT *entry __unused)
+f_openparen(PLAN *plan __attribute__((unused)), FTSENT *entry __attribute__((unused)))
 {
 	abort();
 }
 
 int
-f_closeparen(PLAN *plan __unused, FTSENT *entry __unused)
+f_closeparen(PLAN *plan __attribute__((unused)), FTSENT *entry __attribute__((unused)))
 {
 	abort();
 }
@@ -1741,7 +1802,7 @@
  * AND operator. Since AND is implicit, no node is allocated.
  */
 PLAN *
-c_and(OPTION *option __unused, char ***argvp __unused)
+c_and(OPTION *option __attribute__((unused)), char ***argvp __attribute__((unused)))
 {
 	return NULL;
 }
@@ -1795,7 +1856,7 @@
  *	Always false.
  */
 int
-f_false(PLAN *plan __unused, FTSENT *entry __unused)
+f_false(PLAN *plan __attribute__((unused)), FTSENT *entry __attribute__((unused)))
 {
 	return 0;
 }
@@ -1808,7 +1869,7 @@
  *	Exits the program
  */
 int
-f_quit(PLAN *plan __unused, FTSENT *entry __unused)
+f_quit(PLAN *plan __attribute__((unused)), FTSENT *entry __attribute__((unused)))
 {
 	finish_execplus();
 	exit(exitstatus);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/getdate.y src.freebsd/findutils/find/getdate.y
--- src.orig/findutils/find/getdate.y	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/getdate.y	2023-01-13 18:21:52.693540340 +0100
@@ -524,7 +524,7 @@
 
 /* ARGSUSED */
 static int
-yyerror(const char *s __unused)
+yyerror(const char *s __attribute__((unused)))
 {
   return 0;
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/ls.c src.freebsd/findutils/find/ls.c
--- src.orig/findutils/find/ls.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/ls.c	2023-01-13 18:21:52.693540340 +0100
@@ -38,6 +38,7 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -53,6 +54,8 @@
 
 #include "find.h"
 
+#include "compat.h"
+
 /* Derived from the print routines in the ls(1) source code. */
 
 static void printlink(char *);
@@ -62,13 +65,29 @@
 printlong(char *name, char *accpath, struct stat *sb)
 {
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	char *uname = NULL;
+	char *gname = NULL;
+
+	pw = getpwuid(sb->st_uid);
+	if (pw == NULL)
+		uname = "root";
+	else
+		uname = pw->pw_name;
+
+	gr = getgrgid(sb->st_gid);
+	if (gr == NULL)
+		gname = "root";
+	else
+		gname = gr->gr_name;
 
 	(void)printf("%6ju %8"PRId64" ", (uintmax_t)sb->st_ino, sb->st_blocks);
 	(void)strmode(sb->st_mode, modep);
 	(void)printf("%s %3ju %-*s %-*s ", modep, (uintmax_t)sb->st_nlink,
 	    MAXLOGNAME - 1,
-	    user_from_uid(sb->st_uid, 0), MAXLOGNAME - 1,
-	    group_from_gid(sb->st_gid, 0));
+	    uname, MAXLOGNAME - 1,
+	    gname);
 
 	if (S_ISCHR(sb->st_mode) || S_ISBLK(sb->st_mode))
 		(void)printf("%#8jx ", (uintmax_t)sb->st_rdev);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/main.c src.freebsd/findutils/find/main.c
--- src.orig/findutils/find/main.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/main.c	2023-01-13 18:21:52.693540340 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-static const char copyright[] =
+__attribute__((unused)) static const char copyright[] =
 "@(#) Copyright (c) 1990, 1993, 1994\n\
 	The Regents of the University of California.  All rights reserved.\n";
 
@@ -68,7 +68,7 @@
 int issort;         		/* do hierarchies in lexicographical order */
 int isxargs;			/* don't permit xargs delimiting chars */
 int mindepth = -1, maxdepth = -1; /* minimum and maximum depth */
-int regexp_flags = REG_BASIC;	/* use the "basic" regexp by default*/
+int regexp_flags = 0;	/* use the "basic" regexp by default*/
 int exitstatus;
 
 static void usage(void);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/find/misc.c src.freebsd/findutils/find/misc.c
--- src.orig/findutils/find/misc.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/find/misc.c	2023-01-14 03:25:13.772797610 +0100
@@ -50,6 +50,11 @@
 #include <string.h>
 
 #include "find.h"
+#include "compat.h"
+
+#if defined(__linux__) && !defined(__GLIBC__)
+#include <rpmatch.h>
+#endif
 
 /*
  * brace_subst --
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/xargs/strnsubst.c src.freebsd/findutils/xargs/strnsubst.c
--- src.orig/findutils/xargs/strnsubst.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/xargs/strnsubst.c	2023-01-13 18:21:52.693540340 +0100
@@ -15,6 +15,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdint.h>
+
+#include "compat.h"
 
 void	strnsubst(char **, const char *, const char *, size_t);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/findutils/xargs/xargs.c src.freebsd/findutils/xargs/xargs.c
--- src.orig/findutils/xargs/xargs.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/findutils/xargs/xargs.c	2023-01-13 18:21:52.693540340 +0100
@@ -51,8 +51,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/time.h>
-#include <sys/limits.h>
 #include <sys/resource.h>
+#include <limits.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -67,6 +67,7 @@
 #include <unistd.h>
 
 #include "pathnames.h"
+#include "compat.h"
 
 static void	parse_input(int, char *[]);
 static void	prerun(int, char *[]);
@@ -92,7 +93,7 @@
 static const char *eofstr;
 static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
 static int cnt, Iflag, jfound, Lflag, Sflag, wasquoted, xflag;
-static int curprocs, maxprocs;
+static long unsigned int curprocs, maxprocs;
 static pid_t *childpids;
 
 static volatile int childerr;
@@ -597,6 +598,7 @@
 	case -1:
 		warn("vfork");
 		xexit(*argv, 1);
+		break;
 	case 0:
 		if (oflag) {
 			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1)
@@ -691,7 +693,7 @@
 static void
 pids_init(void)
 {
-	int i;
+	long unsigned int i;
 
 	if ((childpids = malloc(maxprocs * sizeof(*childpids))) == NULL)
 		errx(1, "malloc failed");
@@ -750,7 +752,7 @@
 static int
 findslot(pid_t pid)
 {
-	int slot;
+	long unsigned int slot;
 
 	for (slot = 0; slot < maxprocs; slot++)
 		if (childpids[slot] == pid)
@@ -772,22 +774,22 @@
 prompt(void)
 {
 	regex_t cre;
-	size_t rsize;
+	size_t rsize = 0;
 	int match;
-	char *response;
+	char *response = NULL;
 	FILE *ttyfp;
 
 	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
 		return (2);	/* Indicate that the TTY failed to open. */
 	(void)fprintf(stderr, "?...");
 	(void)fflush(stderr);
-	if ((response = fgetln(ttyfp, &rsize)) == NULL ||
+	if (getline(&response, &rsize, ttyfp) < 0 ||
 	    regcomp(&cre, nl_langinfo(YESEXPR), REG_EXTENDED) != 0) {
 		(void)fclose(ttyfp);
 		return (0);
 	}
-	response[rsize - 1] = '\0';
 	match = regexec(&cre, response, 0, NULL, 0);
+	free(response);
 	(void)fclose(ttyfp);
 	regfree(&cre);
 	return (match == 0);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/grep/file.c src.freebsd/grep/file.c
--- src.orig/grep/file.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/grep/file.c	2023-01-13 18:21:52.697537949 +0100
@@ -43,6 +43,7 @@
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
@@ -52,6 +53,10 @@
 
 #include "grep.h"
 
+#ifndef OFF_MAX
+#define OFF_MAX ((off_t)(((1ULL << (sizeof(off_t) * CHAR_BIT - 2)) - 1) * 2 + 1))
+#endif
+
 #define	MAXBUFSIZ	(32 * 1024)
 #define	LNBUFBUMP	80
 
@@ -190,7 +195,7 @@
 		    (!S_ISREG(st.st_mode)))
 			filebehave = FILE_STDIO;
 		else {
-			int flags = MAP_PRIVATE | MAP_NOCORE | MAP_NOSYNC;
+			int flags = MAP_PRIVATE;
 #ifdef MAP_PREFAULT_READ
 			flags |= MAP_PREFAULT_READ;
 #endif
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/grep/grep.c src.freebsd/grep/grep.c
--- src.orig/grep/grep.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/grep/grep.c	2023-01-13 18:21:52.697537949 +0100
@@ -53,6 +53,8 @@
 
 #include "grep.h"
 
+extern char *__progname;
+
 const char	*errstr[] = {
 	"",
 /* 1*/	"(standard input)",
@@ -67,7 +69,11 @@
 
 /* Flags passed to regcomp() and regexec() */
 int		 cflags = REG_NOSUB | REG_NEWLINE;
+#ifdef REG_STARTEND
 int		 eflags = REG_STARTEND;
+#else
+int		 eflags = 0;
+#endif
 
 bool		 matchall;
 
@@ -145,7 +151,7 @@
 static void
 usage(void)
 {
-	fprintf(stderr, errstr[3], getprogname());
+	fprintf(stderr, errstr[3], __progname);
 	fprintf(stderr, "%s", errstr[4]);
 	fprintf(stderr, "%s", errstr[5]);
 	fprintf(stderr, "%s", errstr[6]);
@@ -329,7 +335,7 @@
 	 * exhibit. In this way we can have all the functionalities in one
 	 * binary without the need of scripting and using ugly hacks.
 	 */
-	pn = getprogname();
+	pn = __progname;
 	switch (pn[0]) {
 	case 'e':
 		grepbehave = GREP_EXTENDED;
@@ -547,7 +553,7 @@
 			filebehave = FILE_MMAP;
 			break;
 		case 'V':
-			printf(errstr[8], getprogname(), VERSION);
+			printf(errstr[8], __progname, VERSION);
 			exit(0);
 		case 'v':
 			vflag = true;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/grep/grep.h src.freebsd/grep/grep.h
--- src.orig/grep/grep.h	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/grep/grep.h	2023-01-13 18:21:52.697537949 +0100
@@ -31,12 +31,10 @@
  * SUCH DAMAGE.
  */
 
-#include <bzlib.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdbool.h>
 #include <stdio.h>
-#include <zlib.h>
 
 extern const char		*errstr[];
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/grep/util.c src.freebsd/grep/util.c
--- src.orig/grep/util.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/grep/util.c	2023-01-13 18:21:52.697537949 +0100
@@ -469,6 +469,31 @@
 
 #define iswword(x)	(iswalnum((x)) || (x) == L'_')
 
+#ifndef REG_STARTEND
+static int regexec_startend(
+    const regex_t *restrict preg, const char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	regoff_t so = pmatch[0].rm_so;
+	regoff_t eo = pmatch[0].rm_eo;
+	char *buf = malloc(eo - so + 1);
+	memcpy(buf, str + pmatch[0].rm_so, eo - so);
+	buf[eo - so] = '\0';
+	int ret = regexec(preg, buf, nmatch, pmatch, eflags);
+	pmatch[0].rm_so += so;
+	pmatch[0].rm_eo += so;
+	free(buf);
+	return ret;
+}
+#else
+static int regexec_startend(
+    const regex_t *restrict preg, const char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	return regexec(preg, str, nmatch, pmatch, eflags);
+}
+#endif
+
 /*
  * Processes a line comparing it with the specified patterns.  Each pattern
  * is looped to be compared along with the full string, saving each and every
@@ -536,7 +561,7 @@
 				r = litexec(&pattern[i], pc->ln.dat, 1, &pmatch);
 			else
 #endif
-			r = regexec(&r_pattern[i], pc->ln.dat, 1, &pmatch,
+			r = regexec_startend(&r_pattern[i], pc->ln.dat, 1, &pmatch,
 			    leflags);
 			if (r != 0)
 				continue;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/gzip/gzip.c src.freebsd/gzip/gzip.c
--- src.orig/gzip/gzip.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/gzip/gzip.c	2023-01-13 18:21:52.697537949 +0100
@@ -49,13 +49,23 @@
  *	- make bzip2/compress -v/-t/-l support work as well as possible
  */
 
-#include <sys/endian.h>
+static inline unsigned le32dec(const void *s) {
+	const unsigned char *p = (const unsigned char *)s;
+	return (((unsigned)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+extern const char *__progname;
+
+#define nitems(x) (sizeof((x)) / sizeof((x)[0]))
+
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <sys/types.h>
 
 #include <inttypes.h>
 #include <unistd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -69,6 +79,8 @@
 #include <getopt.h>
 #include <time.h>
 
+#include "compat.h"
+
 /* what type of file are we dealing with */
 enum filetype {
 	FT_GZIP,
@@ -339,7 +351,7 @@
 int
 main(int argc, char **argv)
 {
-	const char *progname = getprogname();
+	const char *progname = __progname;
 #ifndef SMALL
 	char *gzip;
 	int len;
@@ -388,7 +400,7 @@
 			break;
 		case 'V':
 			display_version();
-			/* NOTREACHED */
+			break; /* NOTREACHED */
 #ifndef SMALL
 		case 'a':
 			fprintf(stderr, "%s: option --ascii ignored on this system\n", progname);
@@ -401,7 +413,7 @@
 			break;
 		case 'L':
 			display_license();
-			/* NOT REACHED */
+			break; /* NOT REACHED */
 		case 'N':
 			nflag = 0;
 			Nflag = 1;
@@ -1140,9 +1152,11 @@
 	if (futimens(fd, times) < 0)
 		maybe_warn("couldn't futimens: %s", file);
 
+#if 0
 	/* only try flags if they exist already */
         if (sb.st_flags != 0 && fchflags(fd, sb.st_flags) < 0)
 		maybe_warn("couldn't fchflags: %s", file);
+#endif
 }
 #endif
 
@@ -1231,7 +1245,7 @@
 }
 
 static void
-got_sigint(int signo __unused)
+got_sigint(int signo __attribute__((unused)))
 {
 
 	if (remove_file != NULL)
@@ -1240,7 +1254,7 @@
 }
 
 static void
-got_siginfo(int signo __unused)
+got_siginfo(int signo __attribute__((unused)))
 {
 
 	print_info = 1;
@@ -1250,7 +1264,7 @@
 setup_signals(void)
 {
 
-	signal(SIGINFO, got_siginfo);
+	signal(SIGUSR1, got_siginfo);
 	signal(SIGINT, got_sigint);
 }
 
@@ -2279,7 +2293,7 @@
     " -V --version         display program version\n"
     " -v --verbose         print extra statistics\n",
 #endif
-	    getprogname());
+	    __progname);
 	exit(0);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/gzip/unxz.c src.freebsd/gzip/unxz.c
--- src.orig/gzip/unxz.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/gzip/unxz.c	2023-01-13 18:21:52.697537949 +0100
@@ -38,6 +38,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <lzma.h>
+#include <sys/stat.h>
 
 static off_t
 unxz(int i, int o, char *pre, size_t prelen, off_t *bytes_in)
@@ -82,7 +83,7 @@
 			switch (strm.avail_in) {
 			case (size_t)-1:
 				maybe_err("read failed");
-				/*NOTREACHED*/
+				break; /*NOTREACHED*/
 			case 0:
 				action = LZMA_FINISH;
 				break;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/gzip/zuncompress.c src.freebsd/gzip/zuncompress.c
--- src.orig/gzip/zuncompress.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/gzip/zuncompress.c	2023-01-13 18:21:52.697537949 +0100
@@ -40,7 +40,12 @@
 
 /* This file is #included by gzip.c */
 
-static int	zread(void *, char *, int);
+static ssize_t
+zread(void *cookie, char *rbp, size_t num);
+
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
 
 #define	tab_prefixof(i)	(zs->zs_codetab[i])
 #define	tab_suffixof(i)	((char_type *)(zs->zs_htab))[i]
@@ -174,6 +179,7 @@
 zdopen(int fd)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
 		return (NULL);
@@ -201,7 +207,12 @@
 		return NULL;
 	}
 
-	return funopen(zs, zread, NULL, NULL, zclose);
+	zfuncs.read = zread;
+	zfuncs.write = NULL;
+	zfuncs.seek = NULL;
+	zfuncs.close = zclose;
+
+	return fopencookie(zs, "r", zfuncs);
 }
 
 /*
@@ -210,8 +221,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count, i;
 	struct s_zstate *zs;
File src.orig/include is a regular file while file src.freebsd/include is a directory
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/m4/eval.c src.freebsd/m4/eval.c
--- src.orig/m4/eval.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/m4/eval.c	2023-01-13 18:21:52.697537949 +0100
@@ -60,6 +60,7 @@
 #include "stdd.h"
 #include "extern.h"
 #include "pathnames.h"
+#include "compat.h"
 
 static void	dodefn(const char *);
 static void	dopushdef(const char *, const char *);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/m4/look.c src.freebsd/m4/look.c
--- src.orig/m4/look.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/m4/look.c	2023-01-13 18:21:52.697537949 +0100
@@ -70,20 +70,20 @@
 
 /* Support routines for hash tables.  */
 void *
-hash_calloc(size_t n, size_t s, void *u __unused)
+hash_calloc(size_t n, size_t s, void *u UNUSED)
 {
 	void *storage = xcalloc(n, s, "hash alloc");
 	return storage;
 }
 
 void
-hash_free(void *p, void *u __unused)
+hash_free(void *p, void *u UNUSED)
 {
 	free(p);
 }
 
 void *
-element_alloc(size_t s, void *u __unused)
+element_alloc(size_t s, void *u UNUSED)
 {
 	return xalloc(s, "element alloc");
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/m4/misc.c src.freebsd/m4/misc.c
--- src.orig/m4/misc.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/m4/misc.c	2023-01-13 18:21:52.697537949 +0100
@@ -243,7 +243,7 @@
 }
 
 void
-onintr(int signo __unused)
+onintr(int signo UNUSED)
 {
 #define intrmessage	"m4: interrupted.\n"
 	write(STDERR_FILENO, intrmessage, sizeof(intrmessage)-1);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/m4/parser.y src.freebsd/m4/parser.y
--- src.orig/m4/parser.y	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/m4/parser.y	2023-01-13 18:21:52.697537949 +0100
@@ -20,6 +20,7 @@
 
 #include <math.h>
 #include <stdint.h>
+#include <stdlib.h>
 #define YYSTYPE	int32_t
 extern int32_t end_result;
 extern int yylex(void);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/col/col.c src.freebsd/miscutils/col/col.c
--- src.orig/miscutils/col/col.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/col/col.c	2023-01-13 18:21:52.697537949 +0100
@@ -47,11 +47,9 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/capsicum.h>
-
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -61,6 +59,8 @@
 #include <wchar.h>
 #include <wctype.h>
 
+#include "compat.h"
+
 #define	BS	'\b'		/* backspace */
 #define	TAB	'\t'		/* tab */
 #define	SPACE	' '		/* space */
@@ -141,12 +141,6 @@
 
 	(void)setlocale(LC_CTYPE, "");
 
-	if (caph_limit_stdio() == -1)
-		err(1, "unable to limit stdio");
-
-	if (caph_enter() < 0)
-		err(1, "unable to enter capability mode");
-
 	max_bufd_lines = 256;
 	compress_spaces = 1;		/* compress spaces into tabs */
 	while ((opt = getopt(argc, argv, "bfhl:px")) != -1)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/getopt/getopt.c src.freebsd/miscutils/getopt/getopt.c
--- src.orig/miscutils/getopt/getopt.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/getopt/getopt.c	2023-01-13 18:21:52.701535557 +0100
@@ -6,7 +6,6 @@
  * into the public domain and is thus not subject to any copyright.
  */
 
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
 #include <stdio.h>
@@ -19,9 +18,6 @@
 	int c;
 	int status = 0;
 
-	if (caph_limit_stdio() < 0 || caph_enter() < 0)
-		err(1, "capsicum");
-
 	optind = 2;	/* Past the program name and the option letters. */
 	while ((c = getopt(argc, argv, argv[1])) != -1)
 		switch (c) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/hexdump/conv.c src.freebsd/miscutils/hexdump/conv.c
--- src.orig/miscutils/hexdump/conv.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/hexdump/conv.c	2023-01-13 18:21:52.701535557 +0100
@@ -104,7 +104,7 @@
 	if (odmode && MB_CUR_MAX > 1) {
 		oclen = 0;
 retry:
-		clen = mbrtowc(&wc, p, bufsize, &pr->mbstate);
+		clen = mbrtowc(&wc, (const char *)p, bufsize, &pr->mbstate);
 		if (clen == 0)
 			clen = 1;
 		else if (clen == (size_t)-1 || (clen == (size_t)-2 &&
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/hexdump/display.c src.freebsd/miscutils/hexdump/display.c
--- src.orig/miscutils/hexdump/display.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/hexdump/display.c	2023-01-13 18:21:52.701535557 +0100
@@ -38,12 +38,10 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
-#include <sys/capsicum.h>
-#include <sys/conf.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -107,7 +105,7 @@
 		for (pr = endfu->nextpr; pr; pr = pr->nextpr)
 			switch(pr->flags) {
 			case F_ADDRESS:
-				(void)printf(pr->fmt, (quad_t)eaddress);
+				(void)printf(pr->fmt, (long long)eaddress);
 				break;
 			case F_TEXT:
 				(void)printf("%s", pr->fmt);
@@ -131,7 +129,7 @@
 
 	switch(pr->flags) {
 	case F_ADDRESS:
-		(void)printf(pr->fmt, (quad_t)address);
+		(void)printf(pr->fmt, (long long)address);
 		break;
 	case F_BPAD:
 		(void)printf(pr->fmt, "");
@@ -164,15 +162,15 @@
 	case F_INT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (quad_t)(signed char)*bp);
+			(void)printf(pr->fmt, (long long)(signed char)*bp);
 			break;
 		case 2:
 			bcopy(bp, &s2, sizeof(s2));
-			(void)printf(pr->fmt, (quad_t)s2);
+			(void)printf(pr->fmt, (long long)s2);
 			break;
 		case 4:
 			bcopy(bp, &s4, sizeof(s4));
-			(void)printf(pr->fmt, (quad_t)s4);
+			(void)printf(pr->fmt, (long long)s4);
 			break;
 		case 8:
 			bcopy(bp, &s8, sizeof(s8));
@@ -195,15 +193,15 @@
 	case F_UINT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (u_quad_t)*bp);
+			(void)printf(pr->fmt, (unsigned long long)*bp);
 			break;
 		case 2:
 			bcopy(bp, &u2, sizeof(u2));
-			(void)printf(pr->fmt, (u_quad_t)u2);
+			(void)printf(pr->fmt, (unsigned long long)u2);
 			break;
 		case 4:
 			bcopy(bp, &u4, sizeof(u4));
-			(void)printf(pr->fmt, (u_quad_t)u4);
+			(void)printf(pr->fmt, (unsigned long long)u4);
 			break;
 		case 8:
 			bcopy(bp, &u8, sizeof(u8));
@@ -364,18 +362,6 @@
 			statok = 0;
 		}
 
-		if (caph_limit_stream(fileno(stdin), CAPH_READ) < 0)
-			err(1, "unable to restrict %s",
-			    statok ? *_argv : "stdin");
-
-		/*
-		 * We've opened our last input file; enter capsicum sandbox.
-		 */
-		if (statok == 0 || *(_argv + 1) == NULL) {
-			if (caph_enter() < 0)
-				err(1, "unable to enter capability mode");
-		}
-
 		if (skip)
 			doskip(statok ? *_argv : "stdin", statok);
 		if (*_argv)
@@ -389,7 +375,6 @@
 void
 doskip(const char *fname, int statok)
 {
-	int type;
 	struct stat sb;
 
 	if (statok) {
@@ -406,16 +391,8 @@
 		return;
 	}
 	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
-		if (ioctl(fileno(stdin), FIODTYPE, &type))
-			err(1, "%s", fname);
-		/*
-		 * Most tape drives don't support seeking,
-		 * yet fseek() would succeed.
-		 */
-		if (type & D_TAPE) {
-			noseek();
-			return;
-		}
+		noseek();
+		return;
 	}
 	if (fseeko(stdin, skip, SEEK_SET)) {
 		noseek();
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/hexdump/hexdump.c src.freebsd/miscutils/hexdump/hexdump.c
--- src.orig/miscutils/hexdump/hexdump.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/hexdump/hexdump.c	2023-01-13 18:21:52.701535557 +0100
@@ -44,8 +44,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/capsicum.h>
-#include <capsicum_helpers.h>
 #include <err.h>
 #include <locale.h>
 #include <stdlib.h>
@@ -81,14 +79,6 @@
 	for (tfs = fshead; tfs; tfs = tfs->nextfs)
 		rewrite(tfs);
 
-	/*
-	 * Cache NLS data, for strerror, for err(3), before entering capability
-	 * mode.
-	 */
-	caph_cache_catpages();
-	if (caph_limit_stdio() < 0)
-		err(1, "capsicum");
-
 	(void)next(argv);
 	display();
 	exit(exitval);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/hexdump/odsyntax.c src.freebsd/miscutils/hexdump/odsyntax.c
--- src.orig/miscutils/hexdump/odsyntax.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/hexdump/odsyntax.c	2023-01-13 18:21:52.701535557 +0100
@@ -309,7 +309,7 @@
 }
 
 static const char *
-odformatfp(char fchar __unused, const char *fmt)
+odformatfp(char fchar __attribute__((unused)), const char *fmt)
 {
 	size_t isize;
 	int digits;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/hexdump/parse.c src.freebsd/miscutils/hexdump/parse.c
--- src.orig/miscutils/hexdump/parse.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/hexdump/parse.c	2023-01-13 18:21:52.701535557 +0100
@@ -46,13 +46,14 @@
 #include <ctype.h>
 #include <string.h>
 #include "hexdump.h"
+#include "compat.h"
 
 FU *endfu;					/* format at end-of-data */
 
 void
 addfile(const char *name)
 {
-	unsigned char *p;
+	char *p;
 	FILE *fp;
 	int ch;
 	char buf[2048 + 1];
@@ -77,7 +78,7 @@
 void
 add(const char *fmt)
 {
-	unsigned const char *p, *savep;
+	const char *p, *savep;
 	static FS **nextfs;
 	FS *tfs;
 	FU *tfu, **nextfu;
@@ -153,7 +154,7 @@
 {
 	FU *fu;
 	int bcnt, cursize;
-	unsigned char *fmt;
+	char *fmt;
 	int prec;
 
 	/* figure out the data block size needed for each format unit */
@@ -210,8 +211,8 @@
 	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	PR *pr, **nextpr;
 	FU *fu;
-	unsigned char *p1, *p2, *fmtp;
-	char savech, cs[3];
+	char *p1, *p2, *fmtp;
+	char savech, cs[4];
 	int nconv, prec;
 
 	prec = 0;
@@ -290,9 +291,10 @@
 				goto isint;
 			case 'o': case 'u': case 'x': case 'X':
 				pr->flags = F_UINT;
-isint:				cs[2] = '\0';
-				cs[1] = cs[0];
-				cs[0] = 'q';
+isint:				cs[3] = '\0';
+				cs[2] = cs[0];
+				cs[1] = 'l';
+				cs[0] = 'l';
 				switch(fu->bcnt) {
 				case 0: case 4:
 					pr->bcnt = 4;
@@ -334,6 +336,7 @@
 				switch(sokay) {
 				case NOTOKAY:
 					badsfmt();
+					return;
 				case USEBCNT:
 					pr->bcnt = fu->bcnt;
 					break;
@@ -354,9 +357,10 @@
 					++p2;
 					switch(p1[2]) {
 					case 'd': case 'o': case'x':
-						cs[0] = 'q';
-						cs[1] = p1[2];
-						cs[2] = '\0';
+						cs[0] = 'l';
+						cs[1] = 'l';
+						cs[2] = p1[2];
+						cs[3] = '\0';
 						break;
 					default:
 						p1[3] = '\0';
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/kill/kill.c src.freebsd/miscutils/kill/kill.c
--- src.orig/miscutils/kill/kill.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/miscutils/kill/kill.c	2023-01-13 18:21:52.701535557 +0100
@@ -60,9 +60,10 @@
 #include "bltin/bltin.h"
 #endif
 
+#include "compat.h"
+
 static void nosig(const char *);
 static void printsignals(FILE *);
-static int signame_to_signum(const char *);
 static void usage(void);
 
 int
@@ -91,9 +92,9 @@
 				errx(2, "illegal signal number: %s", *argv);
 			if (numsig >= 128)
 				numsig -= 128;
-			if (numsig <= 0 || numsig >= sys_nsig)
+			if (numsig <= 0 || numsig >= NSIG)
 				nosig(*argv);
-			printf("%s\n", sys_signame[numsig]);
+			printf("%s\n", signum_to_signame(numsig));
 			return (0);
 		}
 		printsignals(stdout);
@@ -157,20 +158,6 @@
 	return (errors);
 }
 
-static int
-signame_to_signum(const char *sig)
-{
-	int n;
-
-	if (strncasecmp(sig, "SIG", 3) == 0)
-		sig += 3;
-	for (n = 1; n < sys_nsig; n++) {
-		if (!strcasecmp(sys_signame[n], sig))
-			return (n);
-	}
-	return (-1);
-}
-
 static void
 nosig(const char *name)
 {
@@ -189,9 +176,9 @@
 {
 	int n;
 
-	for (n = 1; n < sys_nsig; n++) {
-		(void)fprintf(fp, "%s", sys_signame[n]);
-		if (n == (sys_nsig / 2) || n == (sys_nsig - 1))
+	for (n = 1; n < NSIG; n++) {
+		(void)fprintf(fp, "%s", signum_to_signame(n));
+		if (n == (NSIG / 2) || n == (NSIG - 1))
 			(void)fprintf(fp, "\n");
 		else
 			(void)fprintf(fp, " ");
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/look/look.c src.freebsd/miscutils/look/look.c
--- src.orig/miscutils/look/look.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/look/look.c	2023-01-13 18:21:52.701535557 +0100
@@ -82,12 +82,12 @@
 
 static int dflag, fflag;
 
-static char	*binary_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 compare(wchar_t *, unsigned char *, unsigned char *);
-static char	*linear_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 look(wchar_t *, unsigned char *, unsigned char *);
+static char	*binary_search(wchar_t *, char *, char *);
+static int	 compare(wchar_t *, char *, char *);
+static char	*linear_search(wchar_t *, char *, char *);
+static int	 look(wchar_t *, char *, char *);
 static wchar_t	*prepkey(const char *, wchar_t);
-static void	 print_from(wchar_t *, unsigned char *, unsigned char *);
+static void	 print_from(wchar_t *, char *, char *);
 
 static void usage(void);
 
@@ -105,8 +105,8 @@
 	struct stat sb;
 	int ch, fd, match;
 	wchar_t termchar;
-	unsigned char *back, *front;
-	unsigned const char *file;
+	char *back, *front;
+	const char *file;
 	wchar_t *key;
 
 	(void) setlocale(LC_CTYPE, "");
@@ -149,7 +149,7 @@
 	do {
 		if ((fd = open(file, O_RDONLY, 0)) < 0 || fstat(fd, &sb))
 			err(2, "%s", file);
-		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_T_MAX)
+		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_MAX)
 			errx(2, "%s: %s", file, strerror(EFBIG));
 		if (sb.st_size == 0) {
 			close(fd);
@@ -182,8 +182,10 @@
 	readp = string;
 	writep = key;
 	while ((clen = mbrtowc(&ch, readp, MB_LEN_MAX, NULL)) != 0) {
-		if (clen == (size_t)-1 || clen == (size_t)-2)
-			errc(2, EILSEQ, NULL);
+		if (clen == (size_t)-1 || clen == (size_t)-2) {
+			errno = EILSEQ;
+			err(2, NULL);
+		}
 		if (fflag)
 			ch = towlower(ch);
 		if (!dflag || iswalnum(ch))
@@ -197,7 +199,7 @@
 }
 
 static int
-look(wchar_t *string, unsigned char *front, unsigned char *back)
+look(wchar_t *string, char *front, char *back)
 {
 
 	front = binary_search(string, front, back);
@@ -251,9 +253,9 @@
 	while (p < back && *p++ != '\n');
 
 static char *
-binary_search(wchar_t *string, unsigned char *front, unsigned char *back)
+binary_search(wchar_t *string, char *front, char *back)
 {
-	unsigned char *p;
+	char *p;
 
 	p = front + (back - front) / 2;
 	SKIP_PAST_NEWLINE(p, back);
@@ -285,7 +287,7 @@
  *	o front is before or at the first line to be printed.
  */
 static char *
-linear_search(wchar_t *string, unsigned char *front, unsigned char *back)
+linear_search(wchar_t *string, char *front, char *back)
 {
 	while (front < back) {
 		switch (compare(string, front, back)) {
@@ -305,7 +307,7 @@
  * Print as many lines as match string, starting at front.
  */
 static void
-print_from(wchar_t *string, unsigned char *front, unsigned char *back)
+print_from(wchar_t *string, char *front, char *back)
 {
 	for (; front < back && compare(string, front, back) == EQUAL; ++front) {
 		for (; front < back && *front != '\n'; ++front)
@@ -330,7 +332,7 @@
  * "back" terminated).
  */
 static int
-compare(wchar_t *s1, unsigned char *s2, unsigned char *back)
+compare(wchar_t *s1, char *s2, char *back)
 {
 	wchar_t ch1, ch2;
 	size_t len2;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/rev/rev.c src.freebsd/miscutils/rev/rev.c
--- src.orig/miscutils/rev/rev.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/rev/rev.c	2023-01-13 18:21:52.701535557 +0100
@@ -57,6 +57,46 @@
 
 static void usage(void);
 
+#define BUF_PIECE 1024
+
+static wchar_t *get_wln(FILE *f, size_t *len, wchar_t **sbuf, size_t *blen) {
+	wchar_t *wptr;
+	size_t wlen;
+
+	wptr = fgetws(*sbuf, *blen, f);
+	if (wptr) {
+		wlen = wcslen(wptr);
+		if (wptr[wlen - 1] == '\n' || feof(f)) {
+			*len = wlen;
+			return wptr;
+		}
+	} else {
+		return NULL;
+	}
+
+	for (;;) {
+		wchar_t *nptr;
+		*blen = wlen + BUF_PIECE;
+		*sbuf = realloc(*sbuf, *blen * sizeof(wchar_t));
+		if (*sbuf) err(1, "realloc");
+
+		nptr = fgetws(*sbuf + wlen, BUF_PIECE, f);
+		if (!nptr) {
+			if (feof(f))
+				break;
+			return NULL;
+		}
+
+		wlen += wcslen(nptr);
+		if ((*sbuf)[wlen - 1] == '\n' || feof(f)) {
+			break;
+		}
+	}
+
+	*len = wlen;
+	return *sbuf;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -65,6 +105,10 @@
 	FILE *fp;
 	size_t len;
 	int ch, rval;
+	size_t bufl = BUF_PIECE;
+	wchar_t *buf = malloc(bufl * sizeof(wchar_t));
+
+	if (!buf) err(1, "malloc");
 
 	setlocale(LC_ALL, "");
 
@@ -91,7 +135,7 @@
 			}
 			filename = *argv++;
 		}
-		while ((p = fgetwln(fp, &len)) != NULL) {
+		while ((p = get_wln(fp, &len, &buf, &bufl)) != NULL) {
 			if (p[len - 1] == '\n')
 				--len;
 			for (t = p + len - 1; t >= p; --t)
@@ -105,6 +149,7 @@
 		}
 		(void)fclose(fp);
 	} while(*argv);
+	free(buf);
 	exit(rval);
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/wall/ttymsg.c src.freebsd/miscutils/wall/ttymsg.c
--- src.orig/miscutils/wall/ttymsg.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/wall/ttymsg.c	2023-01-13 18:21:52.701535557 +0100
@@ -37,6 +37,7 @@
 static const char sccsid[] = "@(#)ttymsg.c	8.2 (Berkeley) 11/16/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dirent.h>
@@ -50,6 +51,7 @@
 #include <unistd.h>
 
 #include "ttymsg.h"
+#include "compat.h"
 
 /*
  * Display the contents of a uio structure on a terminal.  Used by wall(1),
@@ -68,6 +70,7 @@
 	static char errbuf[1024];
 	char *p;
 	int forked;
+	sigset_t set;
 
 	forked = 0;
 	if (iovcnt > (int)(sizeof(localiov) / sizeof(localiov[0])))
@@ -143,7 +146,8 @@
 			/* wait at most tmout seconds */
 			(void) signal(SIGALRM, SIG_DFL);
 			(void) signal(SIGTERM, SIG_DFL); /* XXX */
-			(void) sigsetmask(0);
+			sigemptyset(&set);
+			sigprocmask(SIG_SETMASK, &set, 0);
 			(void) alarm((u_int)tmout);
 			(void) fcntl(fd, F_SETFL, 0);	/* clear O_NONBLOCK */
 			continue;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/wall/wall.c src.freebsd/miscutils/wall/wall.c
--- src.orig/miscutils/wall/wall.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/wall/wall.c	2023-01-13 18:21:52.701535557 +0100
@@ -49,6 +49,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
 
@@ -162,7 +163,7 @@
 					ingroup = 1;
 				else if ((grp = getgrgid(g->gid)) != NULL) {
 					for (np = grp->gr_mem; *np; np++) {
-						if (strcmp(*np, utmp->ut_user) == 0) {
+						if (strncmp(*np, utmp->ut_user, sizeof(utmp->ut_user)) == 0) {
 							ingroup = 1;
 							break;
 						}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/miscutils/write/write.c src.freebsd/miscutils/write/write.c
--- src.orig/miscutils/write/write.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/miscutils/write/write.c	2023-01-13 18:21:52.701535557 +0100
@@ -48,27 +48,28 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
-#include <sys/capsicum.h>
-#include <sys/filio.h>
-#include <sys/signal.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
-#include <capsicum_helpers.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <locale.h>
 #include <paths.h>
 #include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <signal.h>
 #include <unistd.h>
+#include <time.h>
 #include <utmpx.h>
 #include <wchar.h>
 #include <wctype.h>
 
+#include "compat.h"
+
 void done(int);
 void do_write(int, char *, char *, const char *);
 static void usage(void);
@@ -80,8 +81,6 @@
 int
 main(int argc, char **argv)
 {
-	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, FIODGNAME };
-	cap_rights_t rights;
 	struct passwd *pwd;
 	time_t atime;
 	uid_t myuid;
@@ -95,30 +94,6 @@
 	devfd = open(_PATH_DEV, O_RDONLY);
 	if (devfd < 0)
 		err(1, "open(/dev)");
-	cap_rights_init(&rights, CAP_FCNTL, CAP_FSTAT, CAP_IOCTL, CAP_LOOKUP,
-	    CAP_PWRITE);
-	if (caph_rights_limit(devfd, &rights) < 0)
-		err(1, "can't limit devfd rights");
-
-	/*
-	 * Can't use capsicum helpers here because we need the additional
-	 * FIODGNAME ioctl.
-	 */
-	cap_rights_init(&rights, CAP_FCNTL, CAP_FSTAT, CAP_IOCTL, CAP_READ,
-	    CAP_WRITE);
-	if (caph_rights_limit(STDIN_FILENO, &rights) < 0 ||
-	    caph_rights_limit(STDOUT_FILENO, &rights) < 0 ||
-	    caph_rights_limit(STDERR_FILENO, &rights) < 0 ||
-	    caph_ioctls_limit(STDIN_FILENO, cmds, nitems(cmds)) < 0 ||
-	    caph_ioctls_limit(STDOUT_FILENO, cmds, nitems(cmds)) < 0 ||
-	    caph_ioctls_limit(STDERR_FILENO, cmds, nitems(cmds)) < 0 ||
-	    caph_fcntls_limit(STDIN_FILENO, CAP_FCNTL_GETFL) < 0 ||
-	    caph_fcntls_limit(STDOUT_FILENO, CAP_FCNTL_GETFL) < 0 ||
-	    caph_fcntls_limit(STDERR_FILENO, CAP_FCNTL_GETFL) < 0)
-		err(1, "can't limit stdio rights");
-
-	caph_cache_catpages();
-	caph_cache_tzdata();
 
 	/*
 	 * Cache UTX database fds.
@@ -137,9 +112,6 @@
 			login = "???";
 	}
 
-	if (caph_enter() < 0)
-		err(1, "cap_enter");
-
 	while (getopt(argc, argv, "") != -1)
 		usage();
 	argc -= optind;
@@ -203,7 +175,8 @@
 {
 	struct utmpx lu, *u;
 
-	strncpy(lu.ut_line, tty, sizeof lu.ut_line);
+	strncpy(lu.ut_line, tty, sizeof lu.ut_line - 1);
+	lu.ut_line[sizeof lu.ut_line - 1] = '\0';
 	while ((u = getutxline(&lu)) != NULL)
 		if (u->ut_type == USER_PROCESS &&
 		    strcmp(user, u->ut_user) == 0) {
@@ -244,7 +217,7 @@
 				continue;	/* bad term? skip */
 			if (myuid && !msgsok)
 				continue;	/* skip ttys with msgs off */
-			if (strcmp(u->ut_line, mytty) == 0) {
+			if (strncmp(u->ut_line, mytty, sizeof(u->ut_line)) == 0) {
 				user_is_me = 1;
 				continue;	/* don't write to yourself */
 			}
@@ -303,10 +276,9 @@
 	fd = openat(devfd, tty, O_WRONLY);
 	if (fd < 0)
 		err(1, "openat(%s%s)", _PATH_DEV, tty);
-	fclose(stdout);
-	stdout = fdopen(fd, "w");
-	if (stdout == NULL)
+	if (dup2(fd, STDOUT_FILENO) < 0)
 		err(1, "%s%s", _PATH_DEV, tty);
+	close(fd);
 
 	(void)signal(SIGINT, done);
 	(void)signal(SIGHUP, done);
@@ -328,7 +300,7 @@
  * done - cleanup and exit
  */
 void
-done(int n __unused)
+done(int n __attribute__((unused)))
 {
 	(void)printf("EOF\r\n");
 	exit(0);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/patch/backupfile.c src.freebsd/patch/backupfile.c
--- src.orig/patch/backupfile.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/patch/backupfile.c	2023-01-13 18:21:52.701535557 +0100
@@ -105,7 +105,7 @@
 	file_name_length = strlen(file);
 
 	while ((dp = readdir(dirp)) != NULL) {
-		if (dp->d_namlen <= file_name_length)
+		if (strlen(dp->d_name) <= file_name_length)
 			continue;
 
 		this_version = version_number(file, dp->d_name, file_name_length);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/patch/inp.c src.freebsd/patch/inp.c
--- src.orig/patch/inp.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/patch/inp.c	2023-01-13 18:21:52.701535557 +0100
@@ -35,6 +35,7 @@
 
 #include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <libgen.h>
 #include <paths.h>
 #include <spawn.h>
@@ -284,8 +285,9 @@
 plan_b(const char *filename)
 {
 	FILE	*ifp;
-	size_t	i = 0, j, len, maxlen = 1;
-	char	*lbuf = NULL, *p;
+	size_t	i = 0, j, blen = 0, maxlen = 1;
+	ssize_t len;
+	char	*p = NULL;
 	bool	found_revision = (revision == NULL);
 
 	using_plan_a = false;
@@ -294,26 +296,20 @@
 	unlink(TMPINNAME);
 	if ((tifd = open(TMPINNAME, O_EXCL | O_CREAT | O_WRONLY, 0666)) < 0)
 		pfatal("can't open file %s", TMPINNAME);
-	while ((p = fgetln(ifp, &len)) != NULL) {
+	while ((len = getline(&p, &blen, ifp)) >= 0) {
 		if (p[len - 1] == '\n')
 			p[len - 1] = '\0';
 		else {
-			/* EOF without EOL, copy and add the NUL */
-			if ((lbuf = malloc(len + 1)) == NULL)
-				fatal("out of memory\n");
-			memcpy(lbuf, p, len);
-			lbuf[len] = '\0';
-			p = lbuf;
-
+			/* EOF without EOL */
 			last_line_missing_eol = true;
 			len++;
 		}
 		if (revision != NULL && !found_revision && rev_in_string(p))
 			found_revision = true;
-		if (len > maxlen)
+		if ((size_t)len > maxlen)
 			maxlen = len;   /* find longest line */
 	}
-	free(lbuf);
+	free(p);
 	if (ferror(ifp))
 		pfatal("can't read file %s", filename);
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/patch/patch.c src.freebsd/patch/patch.c
--- src.orig/patch/patch.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/patch/patch.c	2023-01-13 18:21:52.705533165 +0100
@@ -46,6 +46,7 @@
 #include "inp.h"
 #include "backupfile.h"
 #include "pathnames.h"
+#include "compat.h"
 
 mode_t		filemode = 0644;
 
@@ -558,7 +559,11 @@
 	Argv_last = Argv;
 	if (!Argc)
 		return;
+#ifdef __GLIBC__
+	optind = 0;
+#else
 	optreset = optind = 1;
+#endif
 	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
 		switch (ch) {
 		case 'b':
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/patch/pch.c src.freebsd/patch/pch.c
--- src.orig/patch/pch.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/patch/pch.c	2023-01-14 03:24:27.505699039 +0100
@@ -43,6 +43,7 @@
 #include "util.h"
 #include "pch.h"
 #include "pathnames.h"
+#include "compat.h"
 
 /* Patch (diff listing) abstract type. */
 
@@ -1214,14 +1215,15 @@
 size_t
 pgets(bool do_indent)
 {
-	char *line;
-	size_t len;
+	char *line = NULL;
+	ssize_t len = 0;
+	size_t buflen = 0;
 	int indent = 0, skipped = 0;
 
-	line = fgetln(pfp, &len);
-	if (line != NULL) {
-		if (len + 1 > buf_size) {
-			while (len + 1 > buf_size)
+	if ((len = getline(&line, &buflen, pfp)) >= 0) {
+		char *linep = line;
+		if ((size_t)(len + 1) > buf_size) {
+			while ((size_t)(len + 1) > buf_size)
 				buf_size *= 2;
 			free(buf);
 			buf = malloc(buf_size);
@@ -1240,8 +1242,10 @@
 		}
 		memcpy(buf, line, len - skipped);
 		buf[len - skipped] = '\0';
+		line = linep;
 	}
-	return len;
+	free(line);
+	return (len > 0) ? len : 0;
 }
 
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/patch/util.c src.freebsd/patch/util.c
--- src.orig/patch/util.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/patch/util.c	2023-01-13 18:21:52.705533165 +0100
@@ -46,6 +46,7 @@
 #include "util.h"
 #include "backupfile.h"
 #include "pathnames.h"
+#include "compat.h"
 
 /* Rename a file, copying it if necessary. */
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sed/compile.c src.freebsd/sed/compile.c
--- src.orig/sed/compile.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/sed/compile.c	2023-01-13 18:21:52.705533165 +0100
@@ -827,11 +827,15 @@
 			y->bytetab[i] = (btowc(i) != WEOF) ? i : 0;
 		while (*op != '\0') {
 			oclen = mbrlen(op, MB_LEN_MAX, &mbs1);
-			if (oclen == (size_t)-1 || oclen == (size_t)-2)
-				errc(1, EILSEQ, NULL);
+			if (oclen == (size_t)-1 || oclen == (size_t)-2) {
+				errno = EILSEQ;
+				err(1, NULL);
+			}
 			nclen = mbrlen(np, MB_LEN_MAX, &mbs2);
-			if (nclen == (size_t)-1 || nclen == (size_t)-2)
-				errc(1, EILSEQ, NULL);
+			if (nclen == (size_t)-1 || nclen == (size_t)-2) {
+				errno = EILSEQ;
+				err(1, NULL);
+			}
 			if (oclen == 1 && nclen == 1)
 				y->bytetab[(u_char)*op] = *np;
 			else {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sed/main.c src.freebsd/sed/main.c
--- src.orig/sed/main.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/sed/main.c	2023-01-13 18:21:52.705533165 +0100
@@ -67,6 +67,9 @@
 
 #include "defs.h"
 #include "extern.h"
+#include "compat.h"
+
+extern const char *__progname;
 
 /*
  * Linked list of units (strings and files) to be compiled
@@ -213,7 +216,7 @@
 	(void)fprintf(stderr,
 	    "usage: %s script [-Ealnru] [-i extension] [file ...]\n"
 	    "\t%s [-Ealnu] [-i extension] [-e script] ... [-f script_file]"
-	    " ... [file ...]\n", getprogname(), getprogname());
+	    " ... [file ...]\n", __progname, __progname);
 	exit(1);
 }
 
@@ -262,7 +265,7 @@
 			state = ST_STRING;
 			goto again;
 		default:
-			__unreachable();
+			abort(); /* unreachable */
 		}
 	case ST_FILE:
 		if ((p = fgets(buf, n, f)) != NULL) {
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sed/process.c src.freebsd/sed/process.c
--- src.orig/sed/process.c	2022-05-12 06:54:04.000000000 +0200
+++ src.freebsd/sed/process.c	2023-01-13 18:21:52.705533165 +0100
@@ -669,6 +669,10 @@
 	size_t start, size_t stop)
 {
 	int eval;
+#ifndef REG_STARTEND
+	char *buf;
+	size_t slen;
+#endif
 
 	if (preg == NULL) {
 		if (defpreg == NULL)
@@ -677,11 +681,26 @@
 		defpreg = preg;
 
 	/* Set anchors */
+#ifndef REG_STARTEND
+	buf = malloc(stop - start + 1);
+	if (!buf)
+		errx(1, "out of memory");
+	slen = stop - start;
+	memcpy(buf, string + start, slen);
+	buf[slen] = '\0';
+	eval = regexec(defpreg, buf, nomatch ? 0 : maxnsub + 1, match, eflags);
+	for (size_t i = 0; i <= (nomatch ? 0 : maxnsub); ++i) {
+		match[i].rm_so += start;
+		match[i].rm_eo += start;
+	}
+	free(buf);
+#else
 	match[0].rm_so = start;
 	match[0].rm_eo = stop;
 
 	eval = regexec(defpreg, string,
 	    nomatch ? 0 : maxnsub + 1, match, eflags | REG_STARTEND);
+#endif
 	switch(eval) {
 	case 0:
 		return (1);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/alias.c src.freebsd/sh/alias.c
--- src.orig/sh/alias.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/alias.c	2023-01-13 18:21:52.705533165 +0100
@@ -199,7 +199,7 @@
 }
 
 int
-aliascmd(int argc __unused, char **argv __unused)
+aliascmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char *n, *v;
 	int ret = 0;
@@ -228,7 +228,7 @@
 }
 
 int
-unaliascmd(int argc __unused, char **argv __unused)
+unaliascmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	int i;
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/arith_yacc.c src.freebsd/sh/arith_yacc.c
--- src.orig/sh/arith_yacc.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/arith_yacc.c	2023-01-13 18:21:52.705533165 +0100
@@ -199,6 +199,7 @@
 		return ~primary(op, val, yylex(), noeval);
 	default:
 		yyerror("expecting primary");
+		return 0; /* unreachable */
 	}
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/cd.c src.freebsd/sh/cd.c
--- src.orig/sh/cd.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/cd.c	2023-01-13 18:21:52.705533165 +0100
@@ -77,7 +77,7 @@
 static char *curdir = NULL;	/* current working directory */
 
 int
-cdcmd(int argc __unused, char **argv __unused)
+cdcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	const char *dest;
 	const char *path;
@@ -331,7 +331,7 @@
 }
 
 int
-pwdcmd(int argc __unused, char **argv __unused)
+pwdcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char *p;
 	int ch, phys;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/error.h src.freebsd/sh/error.h
--- src.orig/sh/error.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/error.h	2023-01-13 18:21:52.705533165 +0100
@@ -83,12 +83,3 @@
 void warning(const char *, ...) __printflike(1, 2);
 void error(const char *, ...) __printf0like(1, 2) __dead2;
 void errorwithstatus(int, const char *, ...) __printf0like(2, 3) __dead2;
-
-
-/*
- * BSD setjmp saves the signal mask, which violates ANSI C and takes time,
- * so we use _setjmp instead.
- */
-
-#define setjmp(jmploc)	_setjmp(jmploc)
-#define longjmp(jmploc, val)	_longjmp(jmploc, val)
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/eval.c src.freebsd/sh/eval.c
--- src.orig/sh/eval.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/eval.c	2023-01-13 18:21:52.705533165 +0100
@@ -1259,7 +1259,7 @@
  * The `command' command.
  */
 int
-commandcmd(int argc __unused, char **argv __unused)
+commandcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	const char *path;
 	int ch;
@@ -1313,14 +1313,14 @@
 
 
 int
-falsecmd(int argc __unused, char **argv __unused)
+falsecmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	return 1;
 }
 
 
 int
-truecmd(int argc __unused, char **argv __unused)
+truecmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	return 0;
 }
@@ -1351,7 +1351,7 @@
 
 
 int
-timescmd(int argc __unused, char **argv __unused)
+timescmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct rusage ru;
 	long shumins, shsmins, chumins, chsmins;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/exec.c src.freebsd/sh/exec.c
--- src.orig/sh/exec.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/exec.c	2023-01-13 18:21:52.705533165 +0100
@@ -255,7 +255,7 @@
 
 
 int
-hashcmd(int argc __unused, char **argv __unused)
+hashcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct tblentry **pp;
 	struct tblentry *cmdp;
@@ -513,7 +513,7 @@
  */
 
 void
-changepath(const char *newval __unused)
+changepath(const char *newval __attribute__((unused)))
 {
 	clearcmdentry();
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/expand.c src.freebsd/sh/expand.c
--- src.orig/sh/expand.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/expand.c	2023-01-13 18:21:52.709530774 +0100
@@ -645,7 +645,8 @@
 		}
 		error("%.*s: parameter %snot set", (int)(p - var - 1),
 		      var, (varflags & VSNUL) ? "null or " : "");
-
+		abort();
+		break;
 	default:
 		abort();
 	}
@@ -802,6 +803,7 @@
 		c = p - var - 1;
 		error("${%.*s%s}: Bad substitution", c, var,
 		    (c > 0 && *p != CTLENDVAR) ? "..." : "");
+		break; /* unreachable */
 
 	default:
 		abort();
@@ -1171,7 +1173,7 @@
 		if (dp->d_name[0] == '.' && ! matchdot)
 			continue;
 		if (patmatch(start, dp->d_name)) {
-			namlen = dp->d_namlen;
+			namlen = strlen(dp->d_name);
 			if (enddir + namlen + 1 > expdir_end)
 				continue;
 			memcpy(enddir, dp->d_name, namlen + 1);
@@ -1504,7 +1506,7 @@
  */
 
 int
-freebsd_wordexpcmd(int argc __unused, char **argv __unused)
+freebsd_wordexpcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct arglist arglist;
 	union node *args, *n;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/histedit.c src.freebsd/sh/histedit.c
--- src.orig/sh/histedit.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/histedit.c	2023-01-13 18:21:52.709530774 +0100
@@ -74,9 +74,13 @@
 static char *fc_replace(const char *, char *, char *);
 static int not_fcnumber(const char *);
 static int str_to_event(const char *, int);
-static int comparator(const void *, const void *, void *);
+#ifdef HAVE_FN_COMPLETE2
+static int comparator(const void *, const void *);
 static char **sh_matches(const char *, int, int);
 static unsigned char sh_complete(EditLine *, int);
+#else
+#define sh_complete _el_fn_complete
+#endif
 
 /*
  * Set history and editing status.  Called whenever the status may
@@ -188,7 +192,7 @@
 }
 
 int
-histcmd(int argc, char **argv __unused)
+histcmd(int argc, char **argv __attribute__((unused)))
 {
 	int ch;
 	const char *editor = NULL;
@@ -513,16 +517,17 @@
 	return ret;
 }
 
+#ifdef HAVE_FN_COMPLETE2
+static size_t comp_curpos;
 /*
  * Comparator function for qsort(). The use of curpos here is to skip
  * characters that we already know to compare equal (common prefix).
  */
 static int
-comparator(const void *a, const void *b, void *thunk)
+comparator(const void *a, const void *b)
 {
-	size_t curpos = (intptr_t)thunk;
-	return (strcmp(*(char *const *)a + curpos,
-		*(char *const *)b + curpos));
+	return (strcmp(*(char *const *)a + comp_curpos,
+		*(char *const *)b + comp_curpos));
 }
 
 /*
@@ -592,8 +597,8 @@
 	}
 	uniq = 1;
 	if (i > 1) {
-		qsort_s(matches + 1, i, sizeof(matches[0]), comparator,
-			(void *)(intptr_t)curpos);
+		comp_curpos = curpos;
+		qsort(matches + 1, i, sizeof(matches[0]), comparator);
 		for (size_t k = 2; k <= i; k++) {
 			const char *l = matches[uniq] + curpos;
 			const char *r = matches[k] + curpos;
@@ -639,18 +644,19 @@
  * bind a key (tab by default) to execute the function.
  */
 unsigned char
-sh_complete(EditLine *sel, int ch __unused)
+sh_complete(EditLine *sel, int ch __attribute__((unused)))
 {
 	return (unsigned char)fn_complete2(sel, NULL, sh_matches,
 		L" \t\n\"\\'`@$><=;|&{(", NULL, NULL, (size_t)100,
 		NULL, &((int) {0}), NULL, NULL, FN_QUOTE_MATCH);
 }
+#endif
 
 #else
 #include "error.h"
 
 int
-histcmd(int argc __unused, char **argv __unused)
+histcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 
 	error("not compiled with history support");
@@ -659,7 +665,7 @@
 }
 
 int
-bindcmd(int argc __unused, char **argv __unused)
+bindcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 
 	error("not compiled with line editing support");
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/input.c src.freebsd/sh/input.c
--- src.orig/sh/input.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/input.c	2023-01-13 18:21:52.709530774 +0100
@@ -59,7 +59,9 @@
 #include "error.h"
 #include "alias.h"
 #include "parser.h"
+#ifndef NO_HISTORY
 #include "myhistedit.h"
+#endif
 #include "trap.h"
 
 #define EOF_NLEFT -99		/* value of parsenleft when EOF pushed back */
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/jobs.c src.freebsd/sh/jobs.c
--- src.orig/sh/jobs.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/jobs.c	2023-01-13 18:21:52.709530774 +0100
@@ -246,7 +246,7 @@
 
 #if JOBS
 int
-fgcmd(int argc __unused, char **argv __unused)
+fgcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct job *jp;
 	pid_t pgrp;
@@ -271,7 +271,7 @@
 
 
 int
-bgcmd(int argc __unused, char **argv __unused)
+bgcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct job *jp;
 
@@ -314,7 +314,7 @@
 
 
 int
-jobscmd(int argc __unused, char *argv[] __unused)
+jobscmd(int argc __attribute__((unused)), char *argv[] __attribute__((unused)))
 {
 	char *id;
 	int ch, mode;
@@ -537,7 +537,7 @@
 
 
 int
-waitcmd(int argc __unused, char **argv __unused)
+waitcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct job *job;
 	int retval;
@@ -615,7 +615,7 @@
 
 
 int
-jobidcmd(int argc __unused, char **argv __unused)
+jobidcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct job *jp;
 	int i;
@@ -747,7 +747,7 @@
  */
 
 struct job *
-makejob(union node *node __unused, int nprocs)
+makejob(union node *node __attribute__((unused)), int nprocs)
 {
 	int i;
 	struct job *jp;
@@ -1129,7 +1129,7 @@
 
 
 static void
-dummy_handler(int sig __unused)
+dummy_handler(int sig __attribute__((unused)))
 {
 }
 
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/jobs.h src.freebsd/sh/jobs.h
--- src.orig/sh/jobs.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/jobs.h	2023-01-13 18:21:52.709530774 +0100
@@ -55,7 +55,7 @@
 void showjobs(int, int);
 struct job *makejob(union node *, int);
 pid_t forkshell(struct job *, union node *, int);
-pid_t vforkexecshell(struct job *, char **, char **, const char *, int, int []);
+pid_t vforkexecshell(struct job *, char **, char **, const char *, int, int [2]);
 int waitforjob(struct job *, int *);
 int stoppedjobs(void);
 int backgndpidset(void);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/main.c src.freebsd/sh/main.c
--- src.orig/sh/main.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/main.c	2023-01-13 18:21:52.709530774 +0100
@@ -341,4 +341,5 @@
 		exitshell(number(argv[1]));
 	else
 		exitshell_savedstatus();
+	return 1; /* unreachable */
 }
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/memalloc.h src.freebsd/sh/memalloc.h
--- src.orig/sh/memalloc.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/memalloc.h	2023-01-13 18:21:52.709530774 +0100
@@ -37,6 +37,9 @@
 
 #include <string.h>
 
+#define ALIGNBYTES (sizeof(void *) - 1)
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+
 struct stackmark {
 	struct stack_block *stackp;
 	char *stacknxt;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/miscbltin.c src.freebsd/sh/miscbltin.c
--- src.orig/sh/miscbltin.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/miscbltin.c	2023-01-13 18:21:52.709530774 +0100
@@ -63,6 +63,7 @@
 #include "mystring.h"
 #include "syntax.h"
 #include "trap.h"
+#include "compat.h"
 
 #undef eflag
 
@@ -155,7 +156,7 @@
  */
 
 int
-readcmd(int argc __unused, char **argv __unused)
+readcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char **ap;
 	int backslash;
@@ -351,7 +352,7 @@
 
 
 int
-umaskcmd(int argc __unused, char **argv __unused)
+umaskcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char *ap;
 	int mask;
@@ -515,7 +516,7 @@
 }
 
 int
-ulimitcmd(int argc __unused, char **argv __unused)
+ulimitcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	rlim_t val = 0;
 	enum limithow how = SOFT | HARD;
@@ -567,7 +568,8 @@
 				error("bad number");
 			uval *= l->factor;
 			val = (rlim_t)uval;
-			if (val < 0 || (uintmax_t)val != uval ||
+			/* posix says rlim_t is unsigned */
+			if (uval > ((rlim_t)~(rlim_t)0) ||
 			    val == RLIM_INFINITY)
 				error("bad number");
 		}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/mkbuiltins src.freebsd/sh/mkbuiltins
--- src.orig/sh/mkbuiltins	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/mkbuiltins	2023-01-13 18:21:52.709530774 +0100
@@ -34,7 +34,7 @@
 #	@(#)mkbuiltins	8.2 (Berkeley) 5/4/95
 # $FreeBSD$
 
-temp=`mktemp -t ka`
+temp=`mktemp`
 srcdir=$1
 havejobs=0
 if grep '^#define[	 ]*JOBS[	 ]*1' $srcdir/shell.h > /dev/null
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/mksyntax.c src.freebsd/sh/mksyntax.c
--- src.orig/sh/mksyntax.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/mksyntax.c	2023-01-13 18:21:52.709530774 +0100
@@ -114,7 +114,7 @@
 static void output_type_macros(void);
 
 int
-main(int argc __unused, char **argv __unused)
+main(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	int i;
 	char buf[80];
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/mktokens src.freebsd/sh/mktokens
--- src.orig/sh/mktokens	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/mktokens	2023-01-13 18:21:52.709530774 +0100
@@ -38,7 +38,7 @@
 # token marks the end of a list.  The third column is the name to print in
 # error messages.
 
-temp=`mktemp -t ka`
+temp=`mktemp`
 cat > $temp <<\!
 TEOF	1	end of file
 TNL	0	newline
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/myhistedit.h src.freebsd/sh/myhistedit.h
--- src.orig/sh/myhistedit.h	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/myhistedit.h	2023-01-13 18:21:52.709530774 +0100
@@ -38,7 +38,21 @@
 extern EditLine *el;
 extern int displayhist;
 
-#include <filecomplete.h>
+#ifdef HAVE_FN_COMPLETE2
+#define FN_QUOTE_MATCH 1U
+/* while this is not a part of the public API in libedit, it is a part of
+ * its public ABI (in recent versions, older ones did not have it, which
+ * is why this is guarded here)
+ *
+ * i hope libedit will at very least play nice and not break it, as that
+ * could get ugly
+ */
+int fn_complete2(EditLine *,
+    char *(*)(const char *, int),
+    char **(*)(const char *, int, int),
+    const wchar_t *, const wchar_t *, const char *(*)(const char *), size_t,
+    int *, int *, int *, int *, unsigned int);
+#endif
 
 void histedit(void);
 void sethistsize(const char *);
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/output.c src.freebsd/sh/output.c
--- src.orig/sh/output.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/output.c	2023-01-13 18:21:52.709530774 +0100
@@ -71,7 +71,7 @@
 #define MEM_OUT -2		/* output to dynamically allocated memory */
 #define OUTPUT_ERR 01		/* error occurred on output */
 
-static int doformat_wr(void *, const char *, int);
+static ssize_t doformat_wr(void *, const char *, size_t);
 
 struct output output = {NULL, NULL, NULL, OUTBUFSIZ, 1, 0};
 struct output errout = {NULL, NULL, NULL, 256, 2, 0};
@@ -318,8 +318,8 @@
 	INTON;
 }
 
-static int
-doformat_wr(void *cookie, const char *buf, int len)
+static ssize_t
+doformat_wr(void *cookie, const char *buf, size_t len)
 {
 	struct output *o;
 
@@ -329,12 +329,19 @@
 	return (len);
 }
 
+static cookie_io_functions_t func = {
+    .write = doformat_wr,
+    .read = NULL,
+    .seek = NULL,
+    .close = NULL
+};
+
 void
 doformat(struct output *dest, const char *f, va_list ap)
 {
 	FILE *fp;
 
-	if ((fp = fwopen(dest, doformat_wr)) != NULL) {
+	if ((fp = fopencookie(dest, "a", func)) != NULL) {
 		vfprintf(fp, f, ap);
 		fclose(fp);
 	}
@@ -343,7 +350,7 @@
 FILE *
 out1fp(void)
 {
-	return fwopen(out1, doformat_wr);
+	return fopencookie(out1, "a", func);
 }
 
 /*
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/parser.c src.freebsd/sh/parser.c
--- src.orig/sh/parser.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/parser.c	2023-01-13 18:21:52.713528382 +0100
@@ -65,6 +65,7 @@
 #ifndef NO_HISTORY
 #include "myhistedit.h"
 #endif
+#include "compat.h"
 
 /*
  * Shell command parser.
@@ -592,6 +593,9 @@
 	case TRP:
 		if (!redir)
 			synexpect(-1);
+		tokpushback++;
+		n1 = simplecmd(rpp, redir);
+		return n1;
 	case TWORD:
 		tokpushback++;
 		n1 = simplecmd(rpp, redir);
@@ -1092,7 +1096,6 @@
 	struct jmploc jmploc;
 	struct jmploc *const savehandler = handler;
 	size_t savelen;
-	int saveprompt;
 	const int bq_startlinno = plinno;
 	char *volatile ostr = NULL;
 	struct parsefile *const savetopfile = getcurrentfile();
@@ -1180,18 +1183,16 @@
 	(*nlpp)->next = NULL;
 
 	if (oldstyle) {
-		saveprompt = doprompt;
+		int saveprompt = doprompt;
 		doprompt = 0;
-	}
-
-	n = list(0);
-
-	if (oldstyle) {
+		n = list(0);
 		if (peektoken() != TEOF)
 			synexpect(-1);
 		doprompt = saveprompt;
-	} else
+	} else {
+		n = list(0);
 		consumetoken(TRP);
+	}
 
 	(*nlpp)->n = n;
         if (oldstyle) {
@@ -1240,12 +1241,13 @@
 readcstyleesc(char *out)
 {
 	int c, vc, i, n;
-	unsigned int v;
+	unsigned int v = 0;
 
 	c = pgetc();
 	switch (c) {
 	case '\0':
 		synerror("Unterminated quoted string");
+		return NULL; /* unreachable */
 	case '\n':
 		plinno++;
 		if (doprompt)
@@ -1989,7 +1991,7 @@
 static void
 getusername(char *name, size_t namelen)
 {
-	static char cached_name[MAXLOGNAME];
+	static char cached_name[LOGIN_NAME_MAX];
 	struct passwd *pw;
 	uid_t euid;
 
@@ -2024,7 +2026,7 @@
  *    should be added here.
  */
 char *
-getprompt(void *unused __unused)
+getprompt(void *unused __attribute__((unused)))
 {
 	static char ps[PROMPTLEN];
 	const char *fmt;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/redir.c src.freebsd/sh/redir.c
--- src.orig/sh/redir.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/redir.c	2023-01-13 18:21:52.713528382 +0100
@@ -175,7 +175,7 @@
 	struct stat sb;
 	int fd = redir->nfile.fd;
 	const char *fname;
-	int f;
+	int f = 0;
 	int e;
 
 	memory[fd] = 0;
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/trap.c src.freebsd/sh/trap.c
--- src.orig/sh/trap.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/trap.c	2023-01-13 18:21:52.713528382 +0100
@@ -58,8 +58,10 @@
 #include "trap.h"
 #include "mystring.h"
 #include "builtins.h"
+#ifndef NO_HISTORY
 #include "myhistedit.h"
-
+#endif
+#include "compat.h"
 
 /*
  * Sigmode records the current value of the signal handlers for the various
@@ -111,10 +113,11 @@
 
 		if (strncasecmp(sig, "SIG", 3) == 0)
 			sig += 3;
-		for (n = 1; n < sys_nsig; n++)
-			if (sys_signame[n] &&
-			    strcasecmp(sys_signame[n], sig) == 0)
+		for (n = 1; n < NSIG; n++) {
+			const char *sign = signum_to_signame(n);
+			if (sign && strcasecmp(sign, sig) == 0)
 				return (n);
+		}
 	}
 	return (-1);
 }
@@ -129,16 +132,17 @@
 	int n, outlen;
 
 	outlen = 0;
-	for (n = 1; n < sys_nsig; n++) {
-		if (sys_signame[n]) {
-			out1fmt("%s", sys_signame[n]);
-			outlen += strlen(sys_signame[n]);
+	for (n = 1; n < NSIG; n++) {
+		const char *sign = signum_to_signame(n);
+		if (sign) {
+			out1fmt("%s", sign);
+			outlen += strlen(sign);
 		} else {
 			out1fmt("%d", n);
 			outlen += 3;	/* good enough */
 		}
 		++outlen;
-		if (outlen > 71 || n == sys_nsig - 1) {
+		if (outlen > 71 || n == NSIG - 1) {
 			out1str("\n");
 			outlen = 0;
 		} else {
@@ -152,7 +156,7 @@
  * The trap builtin.
  */
 int
-trapcmd(int argc __unused, char **argv)
+trapcmd(int argc __attribute__((unused)), char **argv)
 {
 	char *action;
 	int signo;
@@ -169,14 +173,15 @@
 	argv = argptr;
 
 	if (*argv == NULL) {
-		for (signo = 0 ; signo < sys_nsig ; signo++) {
+		for (signo = 0 ; signo < NSIG ; signo++) {
 			if (signo < NSIG && trap[signo] != NULL) {
+				const char *sign = signum_to_signame(signo);
 				out1str("trap -- ");
 				out1qstr(trap[signo]);
 				if (signo == 0) {
 					out1str(" EXIT\n");
-				} else if (sys_signame[signo]) {
-					out1fmt(" %s\n", sys_signame[signo]);
+				} else if (sign) {
+					out1fmt(" %s\n", sign);
 				} else {
 					out1fmt(" %d\n", signo);
 				}
diff -Naur -x meson.build -x install.sh -x wrapper.sh -x '*.orig' src.orig/sh/var.c src.freebsd/sh/var.c
--- src.orig/sh/var.c	2022-05-12 06:53:55.000000000 +0200
+++ src.freebsd/sh/var.c	2023-01-13 18:21:52.713528382 +0100
@@ -594,7 +594,7 @@
  */
 
 int
-showvarscmd(int argc __unused, char **argv __unused)
+showvarscmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	struct var **vpp;
 	struct var *vp;
@@ -650,7 +650,7 @@
  */
 
 int
-exportcmd(int argc __unused, char **argv)
+exportcmd(int argc __attribute__((unused)), char **argv)
 {
 	struct var **vpp;
 	struct var *vp;
@@ -728,7 +728,7 @@
  */
 
 int
-localcmd(int argc __unused, char **argv __unused)
+localcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char *name;
 
@@ -849,7 +849,7 @@
  */
 
 int
-unsetcmd(int argc __unused, char **argv __unused)
+unsetcmd(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	char **ap;
 	int i;
