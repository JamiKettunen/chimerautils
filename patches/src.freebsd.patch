--- src.orig/bc/dc/bcode.c
+++ src.freebsd/bc/dc/bcode.c
@@ -72,7 +72,7 @@
 static void		 pop_print(void);
 static void		 pop_printn(void);
 static __inline void	 print_stack(void);
-static __inline void	 dup(void);
+static __inline void	 dcdup(void);
 static void		 swap(void);
 static void		 drop(void);
 
@@ -197,7 +197,7 @@
 	{ '_',	parse_number	},
 	{ 'a',	to_ascii	},
 	{ 'c',	clear_stack	},
-	{ 'd',	dup		},
+	{ 'd',	dcdup		},
 	{ 'e',	print_err	},
 	{ 'f',	print_stack	},
 	{ 'i',	set_ibase	},
@@ -378,7 +378,7 @@
 	bn_checkp(BN_copy(i, n->number));
 
 	if (n->scale == 0 && f != NULL)
-		bn_check(BN_zero(f));
+		BN_zero(f);
 	else if (n->scale < sizeof(factors)/sizeof(factors[0])) {
 		rem = BN_div_word(i, factors[n->scale]);
 		if (f != NULL)
@@ -551,7 +551,7 @@
 }
 
 static __inline void
-dup(void)
+dcdup(void)
 {
 
 	stack_dup(&bmachine.stack);
@@ -811,7 +811,7 @@
 		v = stack_tos(&bmachine.reg[idx]);
 		if (v == NULL) {
 			n = new_number();
-			bn_check(BN_zero(n->number));
+			BN_zero(n->number);
 			push_number(n);
 		} else
 			push(stack_dup_value(v, &copy));
@@ -896,7 +896,7 @@
 			v = frame_retrieve(stack, idx);
 			if (v == NULL || v->type == BCODE_NONE) {
 				n = new_number();
-				bn_check(BN_zero(n->number));
+				BN_zero(n->number);
 				push_number(n);
 			}
 			else
--- src.orig/bc/dc/inout.c
+++ src.freebsd/bc/dc/inout.c
@@ -192,7 +192,7 @@
 	bool dot = false, sign = false;
 
 	n = new_number();
-	bn_check(BN_zero(n->number));
+	BN_zero(n->number);
 
 	while ((ch = (*src->vtable->readchar)(src)) != EOF) {
 
@@ -230,8 +230,8 @@
 		base_n = BN_new();
 		exponent = BN_new();
 		divisor = new_number();
-		bn_check(BN_zero(base_n));
-		bn_check(BN_zero(exponent));
+		BN_zero(base_n);
+		BN_zero(exponent);
 
 		bn_check(BN_add_word(base_n, base));
 		bn_check(BN_add_word(exponent, iscale));
--- src.orig/compat/merge.c
+++ src.freebsd/compat/merge.c
@@ -38,6 +38,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#define __is_aligned(x, align) (((uintptr_t)x & ((align) - 1)) == 0)
+
 /*
  * Hybrid exponential search/linear search merge sort with hybrid
  * natural/pairwise first pass.  Requires about .3% more comparisons
@@ -52,11 +54,13 @@
  * (The default is pairwise merging.)
  */
 
+#include <sys/types.h>
 #include <sys/param.h>
 
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdint.h>
 
 #ifdef I_AM_MERGESORT_B
 #include "block_abi.h"
--- src.orig/compat/setmode.c
+++ src.freebsd/compat/setmode.c
@@ -36,10 +36,8 @@
 __SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
 __FBSDID("$FreeBSD$");
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 
 #include <ctype.h>
 #include <errno.h>
@@ -52,8 +50,6 @@
 #ifdef SETMODE_DEBUG
 #include <stdio.h>
 #endif
-#include "un-namespace.h"
-#include "libc_private.h"
 
 #define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
 #define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
@@ -346,9 +342,7 @@
 get_current_umask(void)
 {
 	sigset_t sigset, sigoset;
-	size_t len;
 	mode_t mask;
-	u_short smask;
 
 #ifdef KERN_PROC_UMASK
 	/*
@@ -366,9 +360,9 @@
 	 * handler, protect them as best we can.
 	 */
 	sigfillset(&sigset);
-	(void)__libc_sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
 	(void)umask(mask = umask(0));
-	(void)__libc_sigprocmask(SIG_SETMASK, &sigoset, NULL);
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
 	return (mask);
 }
 
--- src.orig/compat/vis.c
+++ src.freebsd/compat/vis.c
@@ -64,7 +64,6 @@
 #define	_DIAGASSERT(x)	assert(x)
 #endif
 
-#include "namespace.h"
 #include <sys/types.h>
 #include <sys/param.h>
 
@@ -72,8 +71,10 @@
 #include <vis.h>
 #include <errno.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <limits.h>
 
 #ifdef __weak_alias
 __weak_alias(strvisx,_strvisx)
@@ -81,7 +82,6 @@
 
 #if !HAVE_VIS || !HAVE_SVIS
 #include <ctype.h>
-#include <limits.h>
 #include <stdio.h>
 #include <string.h>
 
--- src.orig/coreutils/cat/cat.c
+++ src.freebsd/coreutils/cat/cat.c
@@ -343,7 +343,6 @@
 				if (ferror(fp) && errno == EILSEQ) {
 					clearerr(fp);
 					/* Resync attempt. */
-					memset(&fp->_mbstate, 0, sizeof(mbstate_t));
 					if ((ch = getc(fp)) == EOF)
 						break;
 					wch = ch;
--- src.orig/coreutils/chmod/chmod.1
+++ src.freebsd/coreutils/chmod/chmod.1
@@ -40,7 +40,7 @@
 .Nd change file modes
 .Sh SYNOPSIS
 .Nm
-.Op Fl fhv
+.Op Fl fv
 .Op Fl R Op Fl H | L | P
 .Ar mode
 .Ar
@@ -66,9 +66,6 @@
 option is specified, symbolic links on the command line are followed
 and hence unaffected by the command.
 (Symbolic links encountered during tree traversal are not followed.)
-.It Fl h
-If the file is a symbolic link, change the mode of the link itself
-rather than the file that the link points to.
 .It Fl L
 If the
 .Fl R
@@ -109,7 +106,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chmod/chmod.c
+++ src.freebsd/coreutils/chmod/chmod.c
@@ -82,7 +82,7 @@
 
 	set = NULL;
 	Hflag = Lflag = Rflag = fflag = hflag = vflag = 0;
-	while ((ch = getopt(argc, argv, "HLPRXfghorstuvwx")) != -1)
+	while ((ch = getopt(argc, argv, "HLPRXfgorstuvwx")) != -1)
 		switch (ch) {
 		case 'H':
 			Hflag = 1;
@@ -202,16 +202,24 @@
 		if (may_have_nfs4acl(p, hflag) == 0 &&
 		    (newmode & ALLPERMS) == (p->fts_statp->st_mode & ALLPERMS))
 				continue;
+		/* on linux we need to skip symlinks */
+		errno = 0;
 		if (fchmodat(AT_FDCWD, p->fts_accpath, newmode, atflag) == -1
-		    && !fflag) {
+		    && !fflag && (errno != ENOTSUP)) {
 			warn("%s", p->fts_path);
 			rval = 1;
 		} else if (vflag || siginfo) {
+			int olderr = errno;
+
 			(void)printf("%s", p->fts_path);
 
 			if (vflag > 1 || siginfo) {
 				char m1[12], m2[12];
 
+				/* do not give misleading information for linux symlinks */
+				if (olderr == ENOTSUP)
+					newmode = p->fts_statp->st_mode;
+
 				strmode(p->fts_statp->st_mode, m1);
 				strmode((p->fts_statp->st_mode &
 				    S_IFMT) | newmode, m2);
@@ -240,6 +248,7 @@
 static int
 may_have_nfs4acl(const FTSENT *ent, int hflag)
 {
+#if 0
 	int ret;
 	static dev_t previous_dev = NODEV;
 	static int supports_acls = -1;
@@ -259,4 +268,9 @@
 	}
 
 	return (supports_acls);
+#else
+	(void)ent;
+	(void)hflag;
+	return 1; /* TODO */
+#endif
 }
--- src.orig/coreutils/chown/chgrp.1
+++ src.freebsd/coreutils/chown/chgrp.1
@@ -124,7 +124,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chown/chown.8
+++ src.freebsd/coreutils/chown/chown.8
@@ -139,7 +139,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 signal (see the
 .Cm status
 argument for
--- src.orig/coreutils/chroot/chroot.8
+++ src.freebsd/coreutils/chroot/chroot.8
@@ -64,14 +64,10 @@
 .Ar user .
 .It Fl n
 Use the
-.Dv PROC_NO_NEW_PRIVS_CTL
-.Xr procctl 2
-command before chrooting, effectively disabling SUID/SGID bits
-for the calling process and its descendants.
-If
-.Dv security.bsd.unprivileged_chroot
-sysctl is set to 1, it will make it possible to chroot without
-superuser privileges.
+.Dv CLONE_NEWUSER
+.Xr unshare 2
+parameter before chrooting, effectively unsharing the user namespace.
+This makes it possible to chroot without superuser privileges.
 .El
 .Sh ENVIRONMENT
 The following environment variable is referenced by
--- src.orig/coreutils/chroot/chroot.c
+++ src.freebsd/coreutils/chroot/chroot.c
@@ -44,7 +44,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/procctl.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -57,6 +56,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sched.h>
 
 static void usage(void);
 
@@ -69,7 +69,7 @@
 	const char	*shell;
 	gid_t		gid, *gidlist;
 	uid_t		uid;
-	int		arg, ch, error, gids;
+	int		ch, error, gids;
 	long		ngroups_max;
 	bool		nonprivileged;
 
@@ -161,10 +161,9 @@
 	}
 
 	if (nonprivileged) {
-		arg = PROC_NO_NEW_PRIVS_ENABLE;
-		error = procctl(P_PID, getpid(), PROC_NO_NEW_PRIVS_CTL, &arg);
+		error = unshare(CLONE_NEWUSER);
 		if (error != 0)
-			err(1, "procctl");
+			err(1, "unshare");
 	}
 
 	if (chdir(argv[0]) == -1 || chroot(".") == -1)
--- src.orig/coreutils/cp/cp.1
+++ src.freebsd/coreutils/cp/cp.1
@@ -172,7 +172,7 @@
 .Nm
 to preserve the following attributes of each source
 file in the copy: modification time, access time,
-file flags, file mode, ACL, user ID, and group ID, as allowed by permissions.
+file flags, file mode, user ID, and group ID, as allowed by permissions.
 .Pp
 If the user ID and group ID cannot be preserved, no error message
 is displayed and the exit value is not altered.
@@ -252,7 +252,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/cp/utils.c
+++ src.freebsd/coreutils/cp/utils.c
@@ -38,7 +38,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 #ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
@@ -52,6 +51,7 @@
 #include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <signal.h>
 #include <sysexits.h>
 #include <unistd.h>
 
@@ -99,11 +99,9 @@
 	static char *buf = NULL;
 	static size_t bufsize;
 	struct stat *fs;
-	ssize_t rcount, wcount;
-	size_t wresid;
+	ssize_t rcount;
 	off_t wtotal;
 	int ch, checkch, from_fd, rval, to_fd;
-	char *bufp;
 #ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
 	char *p;
 #endif
@@ -236,9 +234,14 @@
 				if (use_copy_file_range) {
 					rcount = copy_file_range(from_fd, NULL,
 					    to_fd, NULL, SSIZE_MAX, 0);
-					if (rcount < 0 && errno == EINVAL) {
-						/* Prob a non-seekable FD */
+					if (rcount < 0) switch (errno) {
+					case EINVAL: /* Prob a non-seekable FD */
+					case EXDEV: /* Cross-FS link */
+					case ENOSYS: /* Syscall not supported */
 						use_copy_file_range = 0;
+						break;
+					default:
+						break;
 					}
 				}
 				if (!use_copy_file_range) {
@@ -409,12 +412,12 @@
 
 	if (!gotstat || fs->st_mode != ts.st_mode)
 		if (fdval ? fchmod(fd, fs->st_mode) :
-		    (islink ? lchmod(to.p_path, fs->st_mode) :
+		    (islink ? 0 :
 		    chmod(to.p_path, fs->st_mode))) {
 			warn("chmod: %s", to.p_path);
 			rval = 1;
 		}
-
+#if 0
 	if (!gotstat || fs->st_flags != ts.st_flags)
 		if (fdval ?
 		    fchflags(fd, fs->st_flags) :
@@ -423,13 +426,14 @@
 			warn("chflags: %s", to.p_path);
 			rval = 1;
 		}
-
+#endif
 	return (rval);
 }
 
 int
 preserve_fd_acls(int source_fd, int dest_fd)
 {
+#if 0
 	acl_t acl;
 	acl_type_t acl_type;
 	int acl_supported = 0, ret, trivial;
@@ -476,12 +480,17 @@
 		return (1);
 	}
 	acl_free(acl);
+#else
+	(void)source_fd;
+	(void)dest_fd;
+#endif
 	return (0);
 }
 
 int
 preserve_dir_acls(struct stat *fs, char *source_dir, char *dest_dir)
 {
+#if 0
 	acl_t (*aclgetf)(const char *, acl_type_t);
 	int (*aclsetf)(const char *, acl_type_t, acl_t);
 	struct acl *aclp;
@@ -563,6 +572,11 @@
 		return (1);
 	}
 	acl_free(acl);
+#else
+	(void)fs;
+	(void)source_dir;
+	(void)dest_dir;
+#endif
 	return (0);
 }
 
--- src.orig/coreutils/cut/cut.c
+++ src.freebsd/coreutils/cut/cut.c
@@ -277,14 +277,15 @@
 static int
 b_n_cut(FILE *fp, const char *fname)
 {
-	size_t col, i, lbuflen;
-	char *lbuf;
+	size_t col, i, bufsize = 0;
+	ssize_t lbuflen;
+	char *lbuf = NULL;
 	int canwrite, clen, warned;
 	mbstate_t mbs;
 
 	memset(&mbs, 0, sizeof(mbs));
 	warned = 0;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		for (col = 0; lbuflen > 0; col += clen) {
 			if ((clen = mbrlen(lbuf, lbuflen, &mbs)) < 0) {
 				if (!warned) {
@@ -333,6 +334,7 @@
 		if (lbuflen > 0)
 			putchar('\n');
 	}
+	free(lbuf);
 	return (warned);
 }
 
@@ -391,21 +393,22 @@
 	int field, i, isdelim;
 	char *pos, *p;
 	int output;
-	char *lbuf, *mlbuf;
-	size_t clen, lbuflen, reallen;
+	char *lbuf = NULL;
+	size_t clen, bufsize = 0, reallen;
+	ssize_t lbuflen;
 
-	mlbuf = NULL;
-	while ((lbuf = fgetln(fp, &lbuflen)) != NULL) {
+	while ((lbuflen = getline(&lbuf, &bufsize, fp)) >= 0) {
 		reallen = lbuflen;
 		/* Assert EOL has a newline. */
-		if (*(lbuf + lbuflen - 1) != '\n') {
+		if (lbuflen > 0 && *(lbuf + lbuflen - 1) != '\n') {
 			/* Can't have > 1 line with no trailing newline. */
-			mlbuf = malloc(lbuflen + 1);
-			if (mlbuf == NULL)
-				err(1, "malloc");
-			memcpy(mlbuf, lbuf, lbuflen);
-			*(mlbuf + lbuflen) = '\n';
-			lbuf = mlbuf;
+			if ((ssize_t)bufsize < (lbuflen + 1)) {
+				bufsize = lbuflen + 1;
+				lbuf = realloc(lbuf, bufsize);
+			}
+			if (lbuf == NULL)
+				err(1, "realloc");
+			lbuf[lbuflen] = '\n';
 			reallen++;
 		}
 		output = 0;
@@ -413,7 +416,7 @@
 			clen = mbrtowc(&ch, p, lbuf + reallen - p, NULL);
 			if (clen == (size_t)-1 || clen == (size_t)-2) {
 				warnc(EILSEQ, "%s", fname);
-				free(mlbuf);
+				free(lbuf);
 				return (1);
 			}
 			if (clen == 0)
@@ -440,7 +443,7 @@
 				    NULL);
 				if (clen == (size_t)-1 || clen == (size_t)-2) {
 					warnc(EILSEQ, "%s", fname);
-					free(mlbuf);
+					free(lbuf);
 					return (1);
 				}
 				if (clen == 0)
@@ -472,7 +475,7 @@
 		}
 		(void)putchar('\n');
 	}
-	free(mlbuf);
+	free(lbuf);
 	return (0);
 }
 
--- src.orig/coreutils/date/date.c
+++ src.freebsd/coreutils/date/date.c
@@ -58,6 +58,8 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <utmpx.h>
+#include <time.h>
+#include <langinfo.h>
 
 #include "vary.h"
 
@@ -164,7 +166,14 @@
 	if (!rflag && time(&tval) == -1)
 		err(1, "time");
 
-	format = "%+";
+	/* Linux libc's do not support %+ */
+#ifdef _DATE_FMT
+	/* glibc extension */
+	format = nl_langinfo(_DATE_FMT);
+#else
+	/* fallback, e.g. musl */
+	format = "%a %b %e %H:%M:%S %Z %Y";
+#endif
 
 	if (Rflag)
 		format = rfc2822_format;
@@ -344,14 +353,18 @@
 	if (!jflag) {
 		utx.ut_type = OLD_TIME;
 		memset(utx.ut_id, 0, sizeof(utx.ut_id));
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 		tv.tv_sec = tval;
 		tv.tv_usec = 0;
 		if (settimeofday(&tv, NULL) != 0)
 			err(1, "settimeofday (timeval)");
 		utx.ut_type = NEW_TIME;
-		(void)gettimeofday(&utx.ut_tv, NULL);
+		(void)gettimeofday(&tv, NULL);
+		utx.ut_tv.tv_sec = tv.tv_sec;
+		utx.ut_tv.tv_usec = tv.tv_usec;
 		pututxline(&utx);
 
 		if ((p = getlogin()) == NULL)
--- src.orig/coreutils/dd/dd.1
+++ src.freebsd/coreutils/dd/dd.1
@@ -417,7 +417,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/dd/dd.c
+++ src.freebsd/coreutils/dd/dd.c
@@ -50,9 +50,6 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
-#include <sys/disklabel.h>
-#include <sys/filio.h>
 #include <sys/mtio.h>
 #include <sys/time.h>
 
@@ -145,7 +142,7 @@
 	u_int cnt;
 	int iflags, oflags;
 	cap_rights_t rights;
-	unsigned long cmds[] = { FIODTYPE, MTIOCTOP };
+	unsigned long cmds[] = { 0 };
 
 	if (in.name == NULL) {
 		in.name = "stdin";
@@ -179,7 +176,7 @@
 			oflags = fcntl(out.fd, F_GETFL);
 			if (oflags == -1)
 				err(1, "unable to get fd flags for stdout");
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 			if (fcntl(out.fd, F_SETFL, oflags) == -1)
 				err(1, "unable to set fd flags for stdout");
 		}
@@ -188,7 +185,7 @@
 		if (!(ddflags & (C_SEEK | C_NOTRUNC)))
 			oflags |= O_TRUNC;
 		if (ddflags & C_OFSYNC)
-			oflags |= O_FSYNC;
+			oflags |= O_SYNC;
 		if (ddflags & C_ODIRECT)
 			oflags |= O_DIRECT;
 		out.fd = open(out.name, O_RDWR | oflags, DEFFILEMODE);
@@ -316,23 +313,16 @@
 getfdtype(IO *io)
 {
 	struct stat sb;
-	int type;
 
 	if (fstat(io->fd, &sb) == -1)
 		err(1, "%s", io->name);
 	if (S_ISREG(sb.st_mode))
 		io->flags |= ISTRUNC;
-	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) { 
-		if (ioctl(io->fd, FIODTYPE, &type) == -1) {
-			err(1, "%s", io->name);
-		} else {
-			if (type & D_TAPE)
-				io->flags |= ISTAPE;
-			else if (type & (D_DISK | D_MEM))
-				io->flags |= ISSEEK;
-			if (S_ISCHR(sb.st_mode) && (type & D_TAPE) == 0)
-				io->flags |= ISCHR;
-		}
+	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
+		if (S_ISCHR(sb.st_mode))
+			io->flags |= ISCHR;
+		if (S_ISBLK(sb.st_mode))
+			io->flags |= ISSEEK;
 		return;
 	}
 	errno = 0;
--- src.orig/coreutils/dd/dd.h
+++ src.freebsd/coreutils/dd/dd.h
@@ -36,6 +36,8 @@
  * $FreeBSD$
  */
 
+#include <sys/types.h>
+
 /* Input/output stream state. */
 typedef struct {
 	u_char		*db;		/* buffer address */
--- src.orig/coreutils/dd/extern.h
+++ src.freebsd/coreutils/dd/extern.h
@@ -36,6 +36,8 @@
  * $FreeBSD$
  */
 
+#include <signal.h>
+
 void block(void);
 void block_close(void);
 void dd_out(int);
--- src.orig/coreutils/dd/position.c
+++ src.freebsd/coreutils/dd/position.c
@@ -72,9 +72,9 @@
 	 *
 	 * Bail out if the calculation of a file offset would overflow.
 	 */
-	if ((io->flags & ISCHR) == 0 && (n < 0 || n > OFF_MAX / (ssize_t)sz))
+	if ((io->flags & ISCHR) == 0 && (n < 0 || n > LONG_MAX / (ssize_t)sz))
 		errx(1, "seek offsets cannot be larger than %jd",
-		    (intmax_t)OFF_MAX);
+		    (intmax_t)LONG_MAX);
 	else if ((io->flags & ISCHR) != 0 && (uint64_t)n > UINT64_MAX / sz)
 		errx(1, "seek offsets cannot be larger than %ju",
 		    (uintmax_t)UINT64_MAX);
--- src.orig/coreutils/df/df.1
+++ src.freebsd/coreutils/df/df.1
@@ -39,7 +39,7 @@
 .Nm
 .Op Fl -libxo
 .Op Fl b | g | H | h | k | m | P
-.Op Fl acilnT
+.Op Fl acilT
 .Op Fl \&,
 .Op Fl t Ar type
 .Op Ar file | filesystem ...
@@ -127,15 +127,6 @@
 This overrides any
 .Ev BLOCKSIZE
 specification from the environment.
-.It Fl n
-Print out the previously obtained statistics from the file systems.
-This option should be used if it is possible that one or more
-file systems are in a state such that they will not be able to provide
-statistics without a long delay.
-When this option is specified,
-.Nm
-will not request new statistics from the file systems, but will respond
-with the possibly stale statistics that were previously obtained.
 .It Fl P
 Explicitly use 512 byte blocks, overriding any
 .Ev BLOCKSIZE
@@ -219,7 +210,7 @@
 .Fl t
 option can be specified only once:
 .Bd -literal -offset indent
-$ df -i -n -t nodevfs,linsysfs
+$ df -i -t nodevfs,linsysfs
 Filesystem   1K-blocks      Used      Avail Capacity iused     ifree %iused
 Mounted on
 /dev/ada1p2  223235736 159618992   45757888    78% 1657590  27234568    6%   /
@@ -277,13 +268,6 @@
 .At v1 .
 .Sh BUGS
 The
-.Fl n
-flag is ignored if a file or file system is specified.
-Also, if a mount
-point is not accessible by the user, it is possible that the file system
-information could be stale.
-.Pp
-The
 .Fl b
 and
 .Fl P
--- src.orig/coreutils/df/df.c
+++ src.freebsd/coreutils/df/df.c
@@ -50,8 +50,8 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/statvfs.h>
 #include <sys/mount.h>
-#include <sys/sysctl.h>
 #include <err.h>
 #include <getopt.h>
 #include <libutil.h>
@@ -63,10 +63,38 @@
 #include <sysexits.h>
 #include <unistd.h>
 #include <libxo/xo.h>
+#include <assert.h>
+#include <mntent.h>
 
 #define UNITS_SI	1
 #define UNITS_2		2
 
+/*
+ * Static list of network filesystems
+ *
+ * This replaces the makenetvfslist() function from FreeBSD, but this
+ * list should be made in to something we can generate at runtime or
+ * just expand the list.
+ */
+#define NETVFSLIST "nonfs,nfs4,smb,cifs"
+
+/* combining data from getmntent() and statvfs() on Linux */
+struct mntinfo {
+    char *f_mntfromname;          /* mnt_fsname from getmntent */
+    char *f_mntonname;            /* mnt_dir from getmntent */
+    char *f_fstypename;           /* mnt_fsname from getmntent */
+    char *f_opts;                 /* mnt_opts from getmntent */
+    unsigned long f_bsize;        /* f_bsize from statvfs */
+    fsblkcnt_t f_blocks;          /* f_blocks from statvfs */
+    fsblkcnt_t f_bfree;           /* f_bfree from statvfs */
+    fsblkcnt_t f_bavail;          /* f_bavail from statvfs */
+    fsfilcnt_t f_files;           /* f_files from statvfs */
+    fsfilcnt_t f_ffree;           /* f_ffree from statvfs */
+    unsigned long f_flag;         /* f_flag from statvfs */
+    dev_t f_dev;                  /* st_dev from stat */
+    unsigned int f_selected;      /* used internally here only */
+};
+
 /* Maximum widths of various fields. */
 struct maxwidths {
 	int	mntfrom;
@@ -78,20 +106,20 @@
 	int	ifree;
 };
 
-static void	  addstat(struct statfs *, struct statfs *);
-static char	 *getmntpt(const char *);
+static void	  addstat(struct mntinfo *, struct mntinfo *);
+static char	 *getmntpt(struct mntinfo **, const size_t, const char *);
 static const char **makevfslist(char *fslist, int *skip);
 static int	  checkvfsname(const char *vfsname, const char **vfslist, int skip);
 static int	  checkvfsselected(char *);
 static int	  int64width(int64_t);
-static char	 *makenetvfslist(void);
-static void	  prthuman(const struct statfs *, int64_t);
+static void	  prthuman(const struct mntinfo *, int64_t);
 static void	  prthumanval(const char *, int64_t);
 static intmax_t	  fsbtoblk(int64_t, uint64_t, u_long);
-static void	  prtstat(struct statfs *, struct maxwidths *);
-static size_t	  regetmntinfo(struct statfs **, long);
-static void	  update_maxwidths(struct maxwidths *, const struct statfs *);
+static void	  prtstat(struct mntinfo *, struct maxwidths *);
+static void	  update_maxwidths(struct maxwidths *, const struct mntinfo *);
 static void	  usage(void);
+static int	  getmntinfo(struct mntinfo **);
+static void	  freemntinfo(struct mntinfo *, int);
 
 static __inline int
 imax(int a, int b)
@@ -99,7 +127,7 @@
 	return (a > b ? a : b);
 }
 
-static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, nflag, Tflag;
+static int	  aflag = 0, cflag, hflag, iflag, kflag, lflag = 0, Tflag;
 static int	  thousands;
 static int	  skipvfs_l, skipvfs_t;
 static const char **vfslist_l, **vfslist_t;
@@ -114,9 +142,9 @@
 main(int argc, char *argv[])
 {
 	struct stat stbuf;
-	struct statfs statfsbuf, totalbuf;
+	struct mntinfo *mntbuf = NULL;
+	struct mntinfo totalbuf;
 	struct maxwidths maxwidths;
-	struct statfs *mntbuf;
 	char *mntpt;
 	int i, mntsize;
 	int ch, rv;
@@ -125,13 +153,12 @@
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	memset(&totalbuf, 0, sizeof(totalbuf));
 	totalbuf.f_bsize = DEV_BSIZE;
-	strlcpy(totalbuf.f_mntfromname, "total", MNAMELEN);
 
 	argc = xo_parse_args(argc, argv);
 	if (argc < 0)
 		exit(1);
 
-	while ((ch = getopt_long(argc, argv, "+abcgHhiklmnPt:T,", long_options,
+	while ((ch = getopt_long(argc, argv, "+abcgHhiklmPt:T,", long_options,
 	    NULL)) != -1)
 		switch (ch) {
 		case 'a':
@@ -176,7 +203,7 @@
 			/* Ignore duplicate -l */
 			if (lflag)
 				break;
-			vfslist_l = makevfslist(makenetvfslist(), &skipvfs_l);
+			vfslist_l = makevfslist(NETVFSLIST, &skipvfs_l);
 			lflag = 1;
 			break;
 		case 'm':
@@ -184,7 +211,6 @@
 			hflag = 0;
 			break;
 		case 'n':
-			nflag = 1;
 			break;
 		case 't':
 			if (vfslist_t != NULL)
@@ -205,32 +231,28 @@
 	argv += optind;
 
 	rv = 0;
-	if (!*argv) {
-		/* everything (modulo -t) */
-		mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
-		mntsize = regetmntinfo(&mntbuf, mntsize);
-	} else {
-		/* just the filesystems specified on the command line */
-		mntbuf = malloc(argc * sizeof(*mntbuf));
-		if (mntbuf == NULL)
-			xo_err(1, "malloc()");
-		mntsize = 0;
-		/* continued in for loop below */
-	}
+	mntsize = getmntinfo(&mntbuf);
 
 	xo_open_container("storage-system-information");
 	xo_open_list("filesystem");
 
+	/* unselect all filesystems if an explicit list is given */
+	if (*argv) {
+		for (i = 0; i < mntsize; i++) {
+			mntbuf[i].f_selected = 0;
+		}
+	}
+
 	/* iterate through specified filesystems */
 	for (; *argv; argv++) {
 		if (stat(*argv, &stbuf) < 0) {
-			if ((mntpt = getmntpt(*argv)) == NULL) {
+			if ((mntpt = getmntpt(&mntbuf, mntsize, *argv)) == NULL) {
 				xo_warn("%s", *argv);
 				rv = 1;
 				continue;
 			}
 		} else if (S_ISCHR(stbuf.st_mode)) {
-			mntpt = getmntpt(*argv);
+			mntpt = getmntpt(&mntbuf, mntsize, *argv);
 			if (mntpt == NULL) {
 				xo_warnx("%s: not mounted", *argv);
 				rv = 1;
@@ -239,46 +261,27 @@
 		} else {
 			mntpt = *argv;
 		}
-
-		/*
-		 * Statfs does not take a `wait' flag, so we cannot
-		 * implement nflag here.
-		 */
-		if (statfs(mntpt, &statfsbuf) < 0) {
-			xo_warn("%s", mntpt);
-			rv = 1;
-			continue;
-		}
-
-		/*
-		 * Check to make sure the arguments we've been given are
-		 * satisfied.  Return an error if we have been asked to
-		 * list a mount point that does not match the other args
-		 * we've been given (-l, -t, etc.).
-		 */
-		if (checkvfsselected(statfsbuf.f_fstypename) != 0) {
-			rv = 1;
-			continue;
+		for (i = 0; i < mntsize; i++) {
+			/* selected specified filesystems if the mount point or device matches */
+			if (((stbuf.st_dev == mntbuf[i].f_dev) || !strcmp(mntbuf[i].f_mntfromname, mntpt) || !strcmp(mntbuf[i].f_mntonname, mntpt)) && checkvfsselected(mntbuf[i].f_fstypename) == 0) {
+				mntbuf[i].f_selected = 1;
+				break;
+			}
 		}
-
-		/* the user asked for it, so ignore the ignore flag */
-		statfsbuf.f_flags &= ~MNT_IGNORE;
-
-		/* add to list */
-		mntbuf[mntsize++] = statfsbuf;
 	}
 
 	memset(&maxwidths, 0, sizeof(maxwidths));
 	for (i = 0; i < mntsize; i++) {
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected) {
 			update_maxwidths(&maxwidths, &mntbuf[i]);
 			if (cflag)
 				addstat(&totalbuf, &mntbuf[i]);
 		}
 	}
-	for (i = 0; i < mntsize; i++)
-		if (aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0)
+	for (i = 0; i < mntsize; i++) {
+		if ((aflag || (mntbuf[i].f_blocks > 0)) && mntbuf[i].f_selected)
 			prtstat(&mntbuf[i], &maxwidths);
+	}
 
 	xo_close_list("filesystem");
 
@@ -287,19 +290,21 @@
 
 	xo_close_container("storage-system-information");
 	xo_finish();
+	freemntinfo(mntbuf, mntsize);
 	exit(rv);
 }
 
 static char *
-getmntpt(const char *name)
+getmntpt(struct mntinfo **mntbuf, const size_t mntsize, const char *name)
 {
-	size_t mntsize, i;
-	struct statfs *mntbuf;
+	size_t i;
+
+	if (mntsize == 0 || mntbuf == NULL || name == NULL)
+		return NULL;
 
-	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
 	for (i = 0; i < mntsize; i++) {
-		if (!strcmp(mntbuf[i].f_mntfromname, name))
-			return (mntbuf[i].f_mntonname);
+		if (mntbuf[i] == NULL)
+			continue;
 	}
 	return (NULL);
 }
@@ -376,45 +381,8 @@
 	return (result);
 }
 
-/*
- * Make a pass over the file system info in ``mntbuf'' filtering out
- * file system types not in vfslist_{l,t} and possibly re-stating to get
- * current (not cached) info.  Returns the new count of valid statfs bufs.
- */
-static size_t
-regetmntinfo(struct statfs **mntbufp, long mntsize)
-{
-	int error, i, j;
-	struct statfs *mntbuf;
-
-	if (vfslist_l == NULL && vfslist_t == NULL)
-		return (nflag ? mntsize : getmntinfo(mntbufp, MNT_WAIT));
-
-	mntbuf = *mntbufp;
-	for (j = 0, i = 0; i < mntsize; i++) {
-		if (checkvfsselected(mntbuf[i].f_fstypename) != 0)
-			continue;
-		/*
-		 * XXX statfs(2) can fail for various reasons. It may be
-		 * possible that the user does not have access to the
-		 * pathname, if this happens, we will fall back on
-		 * "stale" filesystem statistics.
-		 */
-		error = statfs(mntbuf[i].f_mntonname, &mntbuf[j]);
-		if (nflag || error < 0)
-			if (i != j) {
-				if (error < 0)
-					xo_warnx("%s stats possibly stale",
-					    mntbuf[i].f_mntonname);
-				mntbuf[j] = mntbuf[i];
-			}
-		j++;
-	}
-	return (j);
-}
-
 static void
-prthuman(const struct statfs *sfsp, int64_t used)
+prthuman(const struct mntinfo *sfsp, int64_t used)
 {
 
 	prthumanval("  {:blocks/%6s}", sfsp->f_blocks * sfsp->f_bsize);
@@ -458,7 +426,7 @@
 }
 
 /*
- * Convert statfs returned file system size into BLOCKSIZE units.
+ * Convert statvfs returned file system size into BLOCKSIZE units.
  */
 static intmax_t
 fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
@@ -470,7 +438,7 @@
  * Print out status about a file system.
  */
 static void
-prtstat(struct statfs *sfsp, struct maxwidths *mwp)
+prtstat(struct mntinfo *sfsp, struct maxwidths *mwp)
 {
 	static long blocksize;
 	static int headerlen, timesthrough = 0;
@@ -544,7 +512,7 @@
 		    mwp->avail, fsbtoblk(sfsp->f_bavail,
 		    sfsp->f_bsize, blocksize));
 	}
-	xo_emit(" {:used-percent/%5.0f}{U:%%}",
+	xo_emit("   {:used-percent/%5.0f}{U:%%}",
 	    availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
 	if (iflag) {
 		inodes = sfsp->f_files;
@@ -566,23 +534,23 @@
 			(double)used / (double)inodes * 100.0);
 	} else
 		xo_emit("  ");
-	if (strncmp(sfsp->f_mntfromname, "total", MNAMELEN) != 0)
-		xo_emit("  {:mounted-on}", sfsp->f_mntonname);
+	if (strcmp(sfsp->f_mntfromname, "total") != 0)
+		xo_emit("{:mounted-on}", sfsp->f_mntonname);
 	xo_emit("\n");
 	xo_close_instance("filesystem");
 }
 
 static void
-addstat(struct statfs *totalfsp, struct statfs *statfsp)
+addstat(struct mntinfo *totalfsp, struct mntinfo *statvfsp)
 {
 	uint64_t bsize;
 
-	bsize = statfsp->f_bsize / totalfsp->f_bsize;
-	totalfsp->f_blocks += statfsp->f_blocks * bsize;
-	totalfsp->f_bfree += statfsp->f_bfree * bsize;
-	totalfsp->f_bavail += statfsp->f_bavail * bsize;
-	totalfsp->f_files += statfsp->f_files;
-	totalfsp->f_ffree += statfsp->f_ffree;
+	bsize = statvfsp->f_bsize / totalfsp->f_bsize;
+	totalfsp->f_blocks += statvfsp->f_blocks * bsize;
+	totalfsp->f_bfree += statvfsp->f_bfree * bsize;
+	totalfsp->f_bavail += statvfsp->f_bavail * bsize;
+	totalfsp->f_files += statvfsp->f_files;
+	totalfsp->f_ffree += statvfsp->f_ffree;
 }
 
 /*
@@ -590,7 +558,7 @@
  * the file system specified by `sfsp'.
  */
 static void
-update_maxwidths(struct maxwidths *mwp, const struct statfs *sfsp)
+update_maxwidths(struct maxwidths *mwp, const struct mntinfo *sfsp)
 {
 	static long blocksize = 0;
 	int dummy;
@@ -642,69 +610,95 @@
 	exit(EX_USAGE);
 }
 
-static char *
-makenetvfslist(void)
+static int
+getmntinfo(struct mntinfo **mntbuf)
 {
-	char *str, *strptr, **listptr;
-	struct xvfsconf *xvfsp, *keep_xvfsp;
-	size_t buflen;
-	int cnt, i, maxvfsconf;
+	struct mntinfo *list = NULL;
+	struct mntinfo *current = NULL;
+	struct mntent *ent = NULL;
+	int mntsize = 0;
+	FILE *fp = NULL;
+	struct statvfs svfsbuf;
+	struct stat stmnt;
+
+#ifdef _PATH_MOUNTED
+	fp = setmntent(_PATH_MOUNTED, "r");
+#else
+	if (access("/proc/self/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/self/mounts", "r");
+	} else if (access("/proc/mounts", R_OK) == 0) {
+	    fp = setmntent("/proc/mounts", "r");
+	} else if (access("/etc/mtab", R_OK) == 0) {
+	    fp = setmntent("/etc/mtab", "r");
+	}
+#endif
+
+	if (fp == NULL) {
+	    err(1, "setmntent");
+	}
+
+	while ((ent = getmntent(fp)) != NULL) {
+	    /* skip if necessary */
+	    if (hasmntopt(ent, MNTTYPE_IGNORE) != NULL) {
+	        continue;
+	    }
+
+	    /* filter out filesystems to be skipped */
+	    if (vfslist_l || vfslist_t) {
+	        if (checkvfsselected(ent->mnt_type) != 0)
+	            continue;
+	    }
+
+	    /* get stat(vfs) fields and copy those over */
+	    if (statvfs(ent->mnt_dir, &svfsbuf) == -1 || stat(ent->mnt_dir, &stmnt) == -1) {
+	        if ((errno == EACCES) || (errno == EPERM)) continue;
+	        err(1, "statvfs");
+	    }
+
+	    /* allocate the entry */
+	    list = realloc(list, (mntsize + 1) * sizeof(*list));
+	    assert(list != NULL);
+	    current = list + mntsize;
+
+	    /* fill the struct with getmntent fields */
+	    current->f_fstypename = strdup(ent->mnt_type);
+	    current->f_mntfromname = strdup(ent->mnt_fsname);
+	    current->f_mntonname = strdup(ent->mnt_dir);
+	    current->f_opts = strdup(ent->mnt_opts);
+
+	    current->f_flag = svfsbuf.f_flag;
+	    current->f_blocks = svfsbuf.f_blocks;
+	    current->f_bsize = svfsbuf.f_bsize;
+	    current->f_bfree = svfsbuf.f_bfree;
+	    current->f_bavail = svfsbuf.f_bavail;
+	    current->f_files = svfsbuf.f_files;
+	    current->f_ffree = svfsbuf.f_ffree;
+
+	    current->f_dev = stmnt.st_dev;
+
+	    current->f_selected = 1;
 
-	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		return (NULL);
+	    mntsize++;
 	}
-	xvfsp = malloc(buflen);
-	if (xvfsp == NULL) {
-		xo_warnx("malloc failed");
-		return (NULL);
-	}
-	keep_xvfsp = xvfsp;
-	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
-		xo_warn("sysctl(vfs.conflist)");
-		free(keep_xvfsp);
-		return (NULL);
-	}
-	maxvfsconf = buflen / sizeof(struct xvfsconf);
 
-	if ((listptr = malloc(sizeof(char*) * maxvfsconf)) == NULL) {
-		xo_warnx("malloc failed");
-		free(keep_xvfsp);
-		return (NULL);
-	}
+	endmntent(fp);
 
-	for (cnt = 0, i = 0; i < maxvfsconf; i++) {
-		if (xvfsp->vfc_flags & VFCF_NETWORK) {
-			listptr[cnt++] = strdup(xvfsp->vfc_name);
-			if (listptr[cnt-1] == NULL) {
-				xo_warnx("malloc failed");
-				free(listptr);
-				free(keep_xvfsp);
-				return (NULL);
-			}
-		}
-		xvfsp++;
-	}
+	*mntbuf = list;
+	return mntsize;
+}
 
-	if (cnt == 0 ||
-	    (str = malloc(sizeof(char) * (32 * cnt + cnt + 2))) == NULL) {
-		if (cnt > 0)
-			xo_warnx("malloc failed");
-		free(listptr);
-		free(keep_xvfsp);
-		return (NULL);
+static void
+freemntinfo(struct mntinfo *mntbuf, int mntsize)
+{
+	int i = 0;
+
+	for (i = 0; i < mntsize; i++) {
+	    free(mntbuf[i].f_fstypename);
+	    free(mntbuf[i].f_mntfromname);
+	    free(mntbuf[i].f_mntonname);
+	    free(mntbuf[i].f_opts);
 	}
 
-	*str = 'n'; *(str + 1) = 'o';
-	for (i = 0, strptr = str + 2; i < cnt; i++, strptr++) {
-		strlcpy(strptr, listptr[i], 32);
-		strptr += strlen(listptr[i]);
-		*strptr = ',';
-		free(listptr[i]);
-	}
-	*(--strptr) = '\0';
-
-	free(keep_xvfsp);
-	free(listptr);
-	return (str);
+	free(mntbuf);
+	return;
 }
--- src.orig/coreutils/du/du.1
+++ src.freebsd/coreutils/du/du.1
@@ -116,12 +116,6 @@
 are counted (and displayed) as many times as they are found.
 .It Fl m
 Display block counts in 1048576-byte (1 MiB) blocks.
-.It Fl n
-Ignore files and directories with user
-.Dq nodump
-flag
-.Pq Dv UF_NODUMP
-set.
 .It Fl r
 Generate messages about directories that cannot be read, files
 that cannot be opened, and so on.
--- src.orig/coreutils/du/du.c
+++ src.freebsd/coreutils/du/du.c
@@ -56,6 +56,7 @@
 #include <getopt.h>
 #include <libutil.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -82,7 +83,6 @@
 static int	ignorep(FTSENT *);
 static void	siginfo(int __unused);
 
-static int	nodumpflag = 0;
 static int	Aflag, hflag;
 static long	blocksize, cblocksize;
 static volatile sig_atomic_t info;
@@ -121,7 +121,7 @@
 	depth = INT_MAX;
 	SLIST_INIT(&ignores);
 
-	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmnrt:x",
+	while ((ch = getopt_long(argc, argv, "+AB:HI:LPasd:cghklmrt:x",
 	    long_options, NULL)) != -1)
 		switch (ch) {
 		case 'A':
@@ -187,19 +187,23 @@
 			hflag = 0;
 			blocksize = 1048576;
 			break;
-		case 'n':
-			nodumpflag = 1;
-			break;
 		case 'r':		 /* Compatibility. */
 			break;
-		case 't' :
-			if (expand_number(optarg, &threshold) != 0 ||
-			    threshold == 0) {
+		case 't' : {
+			uint64_t thresh;
+			/* expand_number takes an unsigned pointer but will happily store
+			 * negative values (represented as values beyond signed maximum)
+			 * store in unsigned and then copy to avoid UB
+			 */
+			int ret = expand_number(optarg, &thresh);
+			memcpy(&threshold, &thresh, sizeof(threshold));
+			if (ret != 0 || threshold == 0) {
 				warnx("invalid threshold: %s", optarg);
 				usage();
 			} else if (threshold < 0)
 				threshold_sign = -1;
 			break;
+		}
 		case 'x':
 			ftsoptions |= FTS_XDEV;
 			break;
@@ -281,18 +285,18 @@
 			curblocks = Aflag ?
 			    howmany(p->fts_statp->st_size, cblocksize) :
 			    howmany(p->fts_statp->st_blocks, cblocksize);
-			p->fts_parent->fts_bignum += p->fts_bignum +=
+			p->fts_parent->fts_number += p->fts_number +=
 			    curblocks;
 
 			if (p->fts_level <= depth && threshold <=
-			    threshold_sign * howmany(p->fts_bignum *
+			    threshold_sign * howmany(p->fts_number *
 			    cblocksize, blocksize)) {
 				if (hflag > 0) {
-					prthumanval(p->fts_bignum);
+					prthumanval(p->fts_number);
 					(void)printf("\t%s\n", p->fts_path);
 				} else {
 					(void)printf("%jd\t%s\n",
-					    (intmax_t)howmany(p->fts_bignum *
+					    (intmax_t)howmany(p->fts_number *
 					    cblocksize, blocksize),
 					    p->fts_path);
 				}
@@ -334,9 +338,9 @@
 				}
 			}
 
-			p->fts_parent->fts_bignum += curblocks;
+			p->fts_parent->fts_number += curblocks;
 		}
-		savednumber = p->fts_parent->fts_bignum;
+		savednumber = p->fts_parent->fts_number;
 	}
 
 	if (errno)
@@ -547,8 +551,6 @@
 {
 	struct ignentry *ign;
 
-	if (nodumpflag && (ent->fts_statp->st_flags & UF_NODUMP))
-		return 1;
 	SLIST_FOREACH(ign, &ignores, next)
 		if (fnmatch(ign->mask, ent->fts_name, 0) != FNM_NOMATCH)
 			return 1;
--- src.orig/coreutils/env/env.1
+++ src.freebsd/coreutils/env/env.1
@@ -40,12 +40,10 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl 0iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl u Ar name
 .Op Ar name Ns = Ns Ar value ...
 .Nm
 .Op Fl iv
-.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
 .Op Fl P Ar altpath
 .Op Fl S Ar string
 .Op Fl u Ar name
@@ -82,34 +80,6 @@
 by
 .Nm
 is ignored completely.
-.\"	-L | -U
-.It Fl L | Fl U Ar user Ns Op / Ns Ar class
-Add the environment variable definitions from
-.Xr login.conf 5
-for the specified user and login class to the environment, after
-processing any
-.Fl i
-or
-.Fl u
-options, but before processing any
-.Ar name Ns = Ns Ar value
-options.
-If
-.Fl L
-is used, only the system-wide
-.Pa /etc/login.conf.db
-file is read; if
-.Fl U
-is used, then the specified user's
-.Pa ~/.login_conf
-is read as well.
-The user may be specified by name or by uid.
-If a username of
-.Sq Li \&-
-is given, then no user lookup will be done, the login class will default to
-.Sq Li default
-if not explicitly given, and no substitutions will be done on the values.
-.\"	-P
 .It Fl P Ar altpath
 Search the set of directories as specified by
 .Ar altpath
--- src.orig/coreutils/env/env.c
+++ src.freebsd/coreutils/env/env.c
@@ -48,7 +48,6 @@
 
 #include <err.h>
 #include <errno.h>
-#include <login_cap.h>
 #include <pwd.h>
 #include <stdbool.h>
 #include <stdio.h>
@@ -76,23 +75,18 @@
 {
 	char *altpath, **ep, *p, **parg, term;
 	char *cleanenv[1];
-	char *login_class, *login_name;
+	char *login_name;
 	struct passwd *pw;
-	login_cap_t *lc;
-	bool login_as_user;
 	uid_t uid;
 	int ch, want_clear;
 	int rtrn;
 
 	altpath = NULL;
-	login_class = NULL;
 	login_name = NULL;
 	pw = NULL;
-	lc = NULL;
-	login_as_user = false;
 	want_clear = 0;
 	term = '\n';
-	while ((ch = getopt(argc, argv, "-0iL:P:S:U:u:v")) != -1)
+	while ((ch = getopt(argc, argv, "0iP:S:u:v")) != -1)
 		switch(ch) {
 		case '-':
 		case 'i':
@@ -101,12 +95,6 @@
 		case '0':
 			term = '\0';
 			break;
-		case 'U':
-			login_as_user = true;
-			/* FALLTHROUGH */
-		case 'L':
-			login_name = optarg;
-			break;
 		case 'P':
 			altpath = strdup(optarg);
 			break;
@@ -134,6 +122,10 @@
 		default:
 			usage();
 		}
+	if (optind < argc && !strcmp(argv[optind], "-")) {
+		want_clear = 1;
+		++argv; /* skip the initial - during later scan */
+	}
 	if (want_clear) {
 		environ = cleanenv;
 		cleanenv[0] = NULL;
@@ -141,9 +133,6 @@
 			fprintf(stderr, "#env clearing environ\n");
 	}
 	if (login_name != NULL) {
-		login_class = strchr(login_name, '/');
-		if (login_class)
-			*login_class++ = '\0';
 		if (*login_name != '\0' && strcmp(login_name, "-") != 0) {
 			pw = getpwnam(login_name);
 			if (pw == NULL) {
@@ -156,38 +145,8 @@
 			if (pw == NULL)
 				errx(EXIT_FAILURE, "no such user: %s", login_name);
 		}
-		/*
-		 * Note that it is safe for pw to be null here; the libutil
-		 * code handles that, bypassing substitution of $ and using
-		 * the class "default" if no class name is given either.
-		 */
-		if (login_class != NULL) {
-			lc = login_getclass(login_class);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "no such login class: %s",
-				    login_class);
-		} else {
-			lc = login_getpwclass(pw);
-			if (lc == NULL)
-				errx(EXIT_FAILURE, "login_getpwclass failed");
-		}
 
-		/*
-		 * This is not done with setusercontext() because that will
-		 * try and use ~/.login_conf even when we don't want it to.
-		 */
-		setclassenvironment(lc, pw, 1);
-		setclassenvironment(lc, pw, 0);
-		if (login_as_user) {
-			login_close(lc);
-			if ((lc = login_getuserclass(pw)) != NULL) {
-				setclassenvironment(lc, pw, 1);
-				setclassenvironment(lc, pw, 0);
-			}
-		}
 		endpwent();
-		if (lc != NULL)
-			login_close(lc);
 	}
 	for (argv += optind; *argv && (p = strchr(*argv, '=')); ++argv) {
 		if (env_verbosity)
--- src.orig/coreutils/env/envopts.c
+++ src.freebsd/coreutils/env/envopts.c
@@ -33,6 +33,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <err.h>
--- src.orig/coreutils/expr/expr.y
+++ src.freebsd/coreutils/expr/expr.y
@@ -8,6 +8,7 @@
  * $FreeBSD$
  */
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 
 #include <ctype.h>
@@ -270,8 +271,7 @@
 	int c;
 
 	setlocale(LC_ALL, "");
-	if (getenv("EXPR_COMPAT") != NULL
-	    || check_utility_compat("expr")) {
+	if (getenv("EXPR_COMPAT") != NULL) {
 		av = argv + 1;
 		nonposix = 1;
 	} else {
--- src.orig/coreutils/factor/factor.c
+++ src.freebsd/coreutils/factor/factor.c
@@ -66,6 +66,7 @@
  * If no args are given, the list of numbers are read from stdin.
  */
 
+#include <sys/types.h>
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
--- src.orig/coreutils/fmt/fmt.c
+++ src.freebsd/coreutils/fmt/fmt.c
@@ -185,6 +185,7 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <stdint.h>
 
 /* Something that, we hope, will never be a genuine line length,
  * indentation etc.
@@ -380,7 +381,7 @@
 		goal_length = 65;
 	if (max_length == 0)
 		max_length = goal_length + 10;
-	if (max_length >= SIZE_T_MAX / sizeof(wchar_t))
+	if (max_length >= SIZE_MAX / sizeof(wchar_t))
 		errx(EX_USAGE, "max length too large");
 	/* really needn't be longer */
 	output_buffer = XMALLOC((max_length + 1) * sizeof(wchar_t));
--- src.orig/coreutils/head/head.c
+++ src.freebsd/coreutils/head/head.c
@@ -157,15 +157,17 @@
 static void
 head(FILE *fp, int cnt)
 {
-	char *cp;
-	size_t error, readlen;
+	char *cp = NULL;
+	size_t error, bufsize = 0;
+	ssize_t readlen;
 
-	while (cnt != 0 && (cp = fgetln(fp, &readlen)) != NULL) {
+	while (cnt != 0 && (readlen = getline(&cp, &bufsize, fp)) >= 0) {
 		error = fwrite(cp, sizeof(char), readlen, stdout);
-		if (error != readlen)
+		if ((ssize_t)error != readlen)
 			err(1, "stdout");
 		cnt--;
 	}
+	free(cp);
 }
 
 static void
--- src.orig/coreutils/id/id.1
+++ src.freebsd/coreutils/id/id.1
@@ -41,18 +41,12 @@
 .Nm
 .Op Ar user
 .Nm
-.Fl A
-.Nm
 .Fl G Op Fl n
 .Op Ar user
 .Nm
-.Fl M
-.Nm
 .Fl P
 .Op Ar user
 .Nm
-.Fl c
-.Nm
 .Fl g Op Fl nr
 .Op Ar user
 .Nm
@@ -77,22 +71,15 @@
 .Pp
 The options are as follows:
 .Bl -tag -width indent
-.It Fl A
-Display the process audit user ID and other process audit properties, which
-requires privilege.
 .It Fl G
 Display the different group IDs (effective, real and supplementary)
 as white-space separated numbers, in no particular order.
-.It Fl M
-Display the MAC label of the current process.
 .It Fl P
 Display the id as a password file entry.
 .It Fl a
 Ignored for compatibility with other
 .Nm
 implementations.
-.It Fl c
-Display current login class.
 .It Fl g
 Display the effective group ID as a number.
 .It Fl n
--- src.orig/coreutils/id/id.c
+++ src.freebsd/coreutils/id/id.c
@@ -43,12 +43,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/mac.h>
-
-#ifdef USE_BSM_AUDIT
-#include <bsm/audit.h>
-#endif
 
 #include <err.h>
 #include <errno.h>
@@ -67,7 +63,6 @@
 static void	auditid(void);
 #endif
 static void	group(struct passwd *, int);
-static void	maclabel(void);
 static void	usage(void);
 static struct passwd *who(char *);
 
@@ -78,14 +73,10 @@
 {
 	struct group *gr;
 	struct passwd *pw;
-	int Gflag, Mflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
-	int Aflag, cflag;
-	int error;
+	int Gflag, Pflag, ch, gflag, id, nflag, pflag, rflag, uflag;
 	const char *myname;
-	char loginclass[MAXLOGNAME];
 
-	Gflag = Mflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
-	Aflag = cflag = 0;
+	Gflag = Pflag = gflag = nflag = pflag = rflag = uflag = 0;
 
 	myname = strrchr(argv[0], '/');
 	myname = (myname != NULL) ? myname + 1 : argv[0];
@@ -99,27 +90,16 @@
 	}
 
 	while ((ch = getopt(argc, argv,
-	    (isgroups || iswhoami) ? "" : "APGMacgnpru")) != -1)
+	    (isgroups || iswhoami) ? "" : "PGagnpru")) != -1)
 		switch(ch) {
-#ifdef USE_BSM_AUDIT
-		case 'A':
-			Aflag = 1;
-			break;
-#endif
 		case 'G':
 			Gflag = 1;
 			break;
-		case 'M':
-			Mflag = 1;
-			break;
 		case 'P':
 			Pflag = 1;
 			break;
 		case 'a':
 			break;
-		case 'c':
-			cflag = 1;
-			break;
 		case 'g':
 			gflag = 1;
 			break;
@@ -144,10 +124,8 @@
 
 	if (iswhoami && argc > 0)
 		usage();
-	if ((cflag || Aflag || Mflag) && argc > 0)
-		usage();
 
-	switch(Aflag + Gflag + Mflag + Pflag + gflag + pflag + uflag) {
+	switch(Gflag + Pflag + gflag + pflag + uflag) {
 	case 1:
 		break;
 	case 0:
@@ -160,24 +138,6 @@
 
 	pw = *argv ? who(*argv) : NULL;
 
-	if (Mflag && pw != NULL)
-		usage();
-
-#ifdef USE_BSM_AUDIT
-	if (Aflag) {
-		auditid();
-		exit(0);
-	}
-#endif
-
-	if (cflag) {
-		error = getloginclass(loginclass, sizeof(loginclass));
-		if (error != 0)
-			err(1, "loginclass");
-		(void)printf("%s\n", loginclass);
-		exit(0);
-	}
-
 	if (gflag) {
 		id = pw ? pw->pw_gid : rflag ? getgid() : getegid();
 		if (nflag && (gr = getgrgid(id)))
@@ -201,11 +161,6 @@
 		exit(0);
 	}
 
-	if (Mflag) {
-		maclabel();
-		exit(0);
-	}
-
 	if (Pflag) {
 		pline(pw);
 		exit(0);
@@ -418,30 +373,6 @@
 	free(groups);
 }
 
-static void
-maclabel(void)
-{
-	char *string;
-	mac_t label;
-	int error;
-
-	error = mac_prepare_process_label(&label);
-	if (error == -1)
-		errx(1, "mac_prepare_type: %s", strerror(errno));
-
-	error = mac_get_proc(label);
-	if (error == -1)
-		errx(1, "mac_get_proc: %s", strerror(errno));
-
-	error = mac_to_text(label, &string);
-	if (error == -1)
-		errx(1, "mac_to_text: %s", strerror(errno));
-
-	(void)printf("%s\n", string);
-	mac_free(label);
-	free(string);
-}
-
 static struct passwd *
 who(char *u)
 {
@@ -471,9 +402,9 @@
 			err(1, "getpwuid");
 	}
 
-	(void)printf("%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n", pw->pw_name,
-			pw->pw_passwd, pw->pw_uid, pw->pw_gid, pw->pw_class,
-			(long)pw->pw_change, (long)pw->pw_expire, pw->pw_gecos,
+	(void)printf("%s:%s:%d:%d:%s:%s:%s\n", pw->pw_name,
+			pw->pw_passwd, pw->pw_uid, pw->pw_gid,
+			pw->pw_gecos,
 			pw->pw_dir, pw->pw_shell);
 }
 
@@ -487,7 +418,7 @@
 	else if (iswhoami)
 		(void)fprintf(stderr, "usage: whoami\n");
 	else
-		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+		(void)fprintf(stderr, "%s\n%s%s\n%s\n%s\n%s\n%s\n",
 		    "usage: id [user]",
 #ifdef USE_BSM_AUDIT
 		    "       id -A\n",
@@ -495,9 +426,7 @@
 		    "",
 #endif
 		    "       id -G [-n] [user]",
-		    "       id -M",
 		    "       id -P [user]",
-		    "       id -c",
 		    "       id -g [-nr] [user]",
 		    "       id -p [user]",
 		    "       id -u [-nr] [user]");
--- src.orig/coreutils/join/join.c
+++ src.freebsd/coreutils/join/join.c
@@ -47,6 +47,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include <sys/types.h>
 #include <sys/param.h>
 
 #include <err.h>
@@ -276,9 +277,10 @@
 slurp(INPUT *F)
 {
 	LINE *lp, *lastlp, tmp;
-	size_t len;
+	size_t blen = 0;
+	ssize_t len;
 	int cnt;
-	char *bp, *fieldp;
+	char *bp, *buf = NULL, *fieldp;
 
 	/*
 	 * Read all of the lines from an input file that have the same
@@ -321,21 +323,21 @@
 			F->pushbool = 0;
 			continue;
 		}
-		if ((bp = fgetln(F->fp, &len)) == NULL)
+		if ((len = getline(&buf, &blen, F->fp)) < 0) {
+			free(buf);
 			return;
-		if (lp->linealloc <= len + 1) {
+		}
+		if (lp->linealloc <= (size_t)(len + 1)) {
 			lp->linealloc += MAX(100, len + 1 - lp->linealloc);
 			if ((lp->line =
 			    realloc(lp->line, lp->linealloc)) == NULL)
 				err(1, NULL);
 		}
-		memmove(lp->line, bp, len);
+		memmove(lp->line, buf, len);
 
 		/* Replace trailing newline, if it exists. */
-		if (bp[len - 1] == '\n')
+		if (buf[len - 1] == '\n')
 			lp->line[len - 1] = '\0';
-		else
-			lp->line[len] = '\0';
 		bp = lp->line;
 
 		/* Split the line into fields, allocate space as necessary. */
@@ -359,6 +361,7 @@
 			break;
 		}
 	}
+	free(buf);
 }
 
 static char *
--- src.orig/coreutils/ln/ln.c
+++ src.freebsd/coreutils/ln/ln.c
@@ -148,6 +148,7 @@
 	switch(argc) {
 	case 0:
 		usage();
+		break;
 		/* NOTREACHED */
 	case 1:				/* ln source */
 		exit(linkit(argv[0], ".", 1));
--- src.orig/coreutils/ls/cmp.c
+++ src.freebsd/coreutils/ls/cmp.c
@@ -125,7 +125,7 @@
 int
 birthcmp(const FTSENT *a, const FTSENT *b)
 {
-
+#if 0
 	if (b->fts_statp->st_birthtim.tv_sec >
 	    a->fts_statp->st_birthtim.tv_sec)
 		return (1);
@@ -138,6 +138,7 @@
 	if (b->fts_statp->st_birthtim.tv_nsec <
 	    a->fts_statp->st_birthtim.tv_nsec)
 		return (-1);
+#endif
 	if (f_samesort)
 		return (strcoll(b->fts_name, a->fts_name));
 	else
--- src.orig/coreutils/ls/ls.1
+++ src.freebsd/coreutils/ls/ls.1
@@ -40,7 +40,7 @@
 .Nd list directory contents
 .Sh SYNOPSIS
 .Nm
-.Op Fl ABCFGHILPRSTUWZabcdfghiklmnopqrstuwxy1\&,
+.Op Fl ABCFGHILPRSTWabcdfghiklmnpqrstuwxy1\&,
 .Op Fl -color Ns = Ns Ar when
 .Op Fl D Ar format
 .Op Ar
@@ -122,9 +122,6 @@
 an equals sign
 .Pq Ql =
 after each socket,
-a percent sign
-.Pq Ql %
-after each whiteout,
 and a vertical bar
 .Pq Ql \&|
 after each that is a
@@ -185,19 +182,6 @@
 option gives even more control over the output format.
 This option is not defined in
 .St -p1003.1-2008 .
-.It Fl U
-Use time when file was created for sorting or printing.
-This option is not defined in
-.St -p1003.1-2008 .
-.It Fl W
-Display whiteouts when scanning directories.
-This option is not defined in
-.St -p1003.1-2008 .
-.It Fl Z
-Display each file's MAC label; see
-.Xr maclabel 7 .
-This option is not defined in
-.St -p1003.1-2008 .
 .It Fl a
 Include directory entries whose names begin with a
 dot
@@ -338,15 +322,6 @@
 or group name in a long
 .Pq Fl l
 output.
-.It Fl o
-Include the file flags in a long
-.Pq Fl l
-output.
-This option is incompatible with
-.St -p1003.1-2008 .
-See
-.Xr chflags 1
-for a list of file flags and their meanings.
 .It Fl p
 Write a slash
 .Pq Ql /
@@ -566,8 +541,6 @@
 .Tn FIFO .
 .It Sy s
 Socket.
-.It Sy w
-Whiteout.
 .El
 .Pp
 The next three fields
@@ -856,11 +829,10 @@
 .Dl $ ls -l
 .Pp
 In addition to listing the contents of the current working directory in
-long format, show inode numbers, file flags (see
-.Xr chflags 1 ) ,
+long format, show inode numbers,
 and suffix each filename with a symbol representing its file type:
 .Pp
-.Dl $ ls -lioF
+.Dl $ ls -liF
 .Pp
 List the files in
 .Pa /var/log ,
@@ -874,7 +846,6 @@
 .St -p1003.2
 specification.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr getfacl 1 ,
 .Xr sort 1 ,
@@ -889,9 +860,9 @@
 .Xr getfmac 8
 .Sh STANDARDS
 With the exception of options
-.Fl g , n
+.Fl g
 and
-.Fl o ,
+.Fl n,
 the
 .Nm
 utility conforms to
@@ -899,7 +870,7 @@
 and
 .St -p1003.1-2008 .
 The options
-.Fl B , D , G , I , T , U , W , Z , b , h , w , y
+.Fl B , D , G , I , T , W , b , h , w , y
 and
 .Fl ,
 are non-standard extensions.
--- src.orig/coreutils/ls/ls.c
+++ src.freebsd/coreutils/ls/ls.c
@@ -49,7 +49,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <sys/mac.h>
+#include <sys/types.h>
 
 #include <ctype.h>
 #include <dirent.h>
@@ -98,7 +98,7 @@
 	} while(0)
 
 static void	 display(const FTSENT *, FTSENT *, int);
-static int	 mastercmp(const FTSENT * const *, const FTSENT * const *);
+static int	 mastercmp(const FTSENT **, const FTSENT **);
 static void	 traverse(int, char **, int);
 
 #define	COLOR_OPT	(CHAR_MAX + 1)
@@ -274,7 +274,7 @@
 		colorflag = COLORFLAG_AUTO;
 #endif
 	while ((ch = getopt_long(argc, argv,
-	    "+1ABCD:FGHILPRSTUWXZabcdfghiklmnopqrstuwxy,", long_opts,
+	    "+1ABCD:FGHILPRSTXabcdfghiklmnpqrstuwxy,", long_opts,
 	    NULL)) != -1) {
 		switch (ch) {
 		/*
@@ -458,8 +458,6 @@
 				errx(2, "unsupported --color value '%s' (must be always, auto, or never)",
 				    optarg);
 			break;
-#else
-			warnx("color support not compiled in");
 #endif
 		default:
 		case '?':
@@ -692,7 +690,7 @@
  * points to the parent directory of the display list.
  */
 static void
-display(const FTSENT *p, FTSENT *list, int options)
+display(const FTSENT *p, FTSENT *list, int options __unused)
 {
 	struct stat *sp;
 	DISPLAY d;
@@ -710,8 +708,9 @@
 	size_t flen, ulen, glen;
 	char *initmax;
 	int entries, needstats;
+	struct passwd *pwentry = NULL;
+	struct group *grentry = NULL;
 	const char *user, *group;
-	char *flags, *labelstr = NULL;
 	char ngroup[STRBUF_SIZEOF(uid_t) + 1];
 	char nuser[STRBUF_SIZEOF(gid_t) + 1];
 	u_long width[9];
@@ -720,6 +719,7 @@
 	needstats = f_inode || f_longform || f_size;
 	flen = 0;
 	btotal = 0;
+	labelstrlen = 0;
 
 #define LS_COLWIDTHS_FIELDS	9
 	initmax = getenv("LS_COLWIDTHS");
@@ -768,7 +768,6 @@
 
 	d.s_size = 0;
 	sizelen = 0;
-	flags = NULL;
 	for (cur = list, entries = 0; cur; cur = cur->fts_link) {
 		if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS) {
 			warnx("%s: %s",
@@ -823,27 +822,33 @@
 					user = nuser;
 					group = ngroup;
 				} else {
-					user = user_from_uid(sp->st_uid, 0);
+					pwentry = getpwuid(sp->st_uid);
 					/*
-					 * user_from_uid(..., 0) only returns
-					 * NULL in OOM conditions.  We could
-					 * format the uid here, but (1) in
-					 * general ls(1) exits on OOM, and (2)
-					 * there is another allocation/exit
-					 * path directly below, which will
-					 * likely exit anyway.
+					 * getpwuid and getgrgid are allowed to
+					 * return NULL when the information is
+					 * not known (i.e. not in /etc/passwd)
+					 * so fall back to numeric IDs if needed
 					 */
-					if (user == NULL)
-						err(1, "user_from_uid");
-					group = group_from_gid(sp->st_gid, 0);
+					if (pwentry == NULL) {
+						(void)snprintf(nuser, sizeof(nuser),
+						    "%u", sp->st_uid);
+						user = nuser;
+					} else
+						user = pwentry->pw_name;
+					grentry = getgrgid(sp->st_gid);
 					/* Ditto. */
-					if (group == NULL)
-						err(1, "group_from_gid");
+					if (grentry == NULL) {
+						(void)snprintf(ngroup, sizeof(ngroup),
+						    "%u", sp->st_gid);
+						group = ngroup;
+					} else
+						group = grentry->gr_name;
 				}
 				if ((ulen = strlen(user)) > maxuser)
 					maxuser = ulen;
 				if ((glen = strlen(group)) > maxgroup)
 					maxgroup = glen;
+#if 0
 				if (f_flags) {
 					flags = fflagstostr(sp->st_flags);
 					if (flags != NULL && *flags == '\0') {
@@ -911,7 +916,7 @@
 						maxlabelstr = labelstrlen;
 				} else
 					labelstrlen = 0;
-
+#endif
 				if ((np = malloc(sizeof(NAMES) + labelstrlen +
 				    ulen + glen + flen + 4)) == NULL)
 					err(1, "malloc");
@@ -929,17 +934,6 @@
 						d.s_size = sizelen;
 				}
 
-				if (f_flags) {
-					np->flags = &np->data[ulen + glen + 2];
-					(void)strcpy(np->flags, flags);
-					free(flags);
-				}
-				if (f_label) {
-					np->label = &np->data[ulen + glen + 2
-					    + (f_flags ? flen + 1 : 0)];
-					(void)strcpy(np->label, labelstr);
-					free(labelstr);
-				}
 				cur->fts_pointer = np;
 			}
 		}
@@ -989,7 +983,7 @@
  * All other levels use the sort function.  Error entries remain unsorted.
  */
 static int
-mastercmp(const FTSENT * const *a, const FTSENT * const *b)
+mastercmp(const FTSENT **a, const FTSENT **b)
 {
 	int a_info, b_info;
 
--- src.orig/coreutils/ls/print.c
+++ src.freebsd/coreutils/ls/print.c
@@ -42,7 +42,6 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
-#include <sys/acl.h>
 
 #include <err.h>
 #include <errno.h>
@@ -247,7 +246,7 @@
 		if (f_accesstime)
 			printtime(sp->st_atime);
 		else if (f_birthtime)
-			printtime(sp->st_birthtime);
+			printtime(sp->st_ctime);
 		else if (f_statustime)
 			printtime(sp->st_ctime);
 		else
@@ -464,8 +463,11 @@
 	const char *format;
 	static int d_first = -1;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		d_first = 0;
+		if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+			d_first = 1;
+	}
 	if (now == 0)
 		now = time(NULL);
 
@@ -511,9 +513,6 @@
 	case S_IFSOCK:
 		(void)putchar('=');
 		return (1);
-	case S_IFWHT:
-		(void)putchar('%');
-		return (1);
 	default:
 		break;
 	}
@@ -762,6 +761,7 @@
 static void
 aclmode(char *buf, const FTSENT *p)
 {
+#if 0
 	char name[MAXPATHLEN + 1];
 	int ret, trivial;
 	static dev_t previous_dev = NODEV;
@@ -800,7 +800,7 @@
 		}
 		if (supports_acls == 0) {
 			ret = lpathconf(name, _PC_ACL_EXTENDED);
-			if (ret > 0) {
+		if (ret > 0) {
 				type = ACL_TYPE_ACCESS;
 				supports_acls = 1;
 			} else if (ret < 0 && errno != EINVAL) {
@@ -824,4 +824,8 @@
 	if (!trivial)
 		buf[10] = '+';
 	acl_free(facl);
+#else
+	(void)buf;
+	(void)p;
+#endif
 }
--- src.orig/coreutils/ls/util.c
+++ src.freebsd/coreutils/ls/util.c
@@ -227,9 +227,9 @@
 {
 	(void)fprintf(stderr,
 #ifdef COLORLS
-	"usage: ls [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuwxy1,] [--color=when] [-D format]"
+	"usage: ls [-ABCFGHILPRSTWabcdfghiklmnpqrstuwxy1,] [--color=when] [-D format]"
 #else
-	"usage: ls [-ABCFHILPRSTUWZabcdfghiklmnopqrstuwxy1,] [-D format]"
+	"usage: ls [-ABCFHILPRSTWabcdfghiklmnpqrstuwxy1,] [-D format]"
 #endif
 		      " [file ...]\n");
 	exit(1);
--- src.orig/coreutils/mknod/mknod.c
+++ src.freebsd/coreutils/mknod/mknod.c
@@ -48,6 +48,7 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 
 #include <err.h>
 #include <errno.h>
--- src.orig/coreutils/mv/mv.c
+++ src.freebsd/coreutils/mv/mv.c
@@ -47,12 +47,12 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/statvfs.h>
 
 #include <err.h>
 #include <errno.h>
@@ -178,6 +178,8 @@
 	struct stat sb;
 	int ask, ch, first;
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/*
 	 * Check access.  If interactive and file exists, ask user if it
@@ -203,10 +205,15 @@
 			ask = 1;
 		} else if (access(to, W_OK) && !stat(to, &sb) && isatty(STDIN_FILENO)) {
 			strmode(sb.st_mode, modep);
+			pw = getpwuid(sb.st_uid);
+			if (pw == NULL)
+				err(EXIT_FAILURE, "getpwuid");
+			gr = getgrgid(sb.st_gid);
+			if (gr == NULL)
+				err(EXIT_FAILURE, "getgrgid");
 			(void)fprintf(stderr, "override %s%s%s/%s for %s? %s",
 			    modep + 1, modep[9] == ' ' ? "" : " ",
-			    user_from_uid((unsigned long)sb.st_uid, 0),
-			    group_from_gid((unsigned long)sb.st_gid, 0), to, YESNO);
+			    pw->pw_name, gr->gr_name, to, YESNO);
 			ask = 1;
 		}
 		if (ask) {
@@ -231,7 +238,6 @@
 	}
 
 	if (errno == EXDEV) {
-		struct statfs sfs;
 		char path[PATH_MAX];
 
 		/*
@@ -248,11 +254,6 @@
 				warn("cannot resolve %s: %s", from, path);
 				return (1);
 			}
-			if (!statfs(path, &sfs) &&
-			    !strcmp(path, sfs.f_mntonname)) {
-				warnx("cannot rename a mount point");
-				return (1);
-			}
 		}
 	} else {
 		warn("rename %s to %s", from, to);
@@ -280,7 +281,6 @@
 	static char *bp = NULL;
 	mode_t oldmode;
 	int nread, from_fd, to_fd;
-	struct stat tsb;
 
 	if ((from_fd = open(from, O_RDONLY, 0)) < 0) {
 		warn("fastcopy: open() failed (from): %s", from);
@@ -340,6 +340,7 @@
 	 * if the server supports flags and we were trying to *remove* flags
 	 * on a file that we copied, i.e., that we didn't create.)
 	 */
+#if 0
 	if (fstat(to_fd, &tsb) == 0) {
 		if ((sbp->st_flags  & ~UF_ARCHIVE) !=
 		    (tsb.st_flags & ~UF_ARCHIVE)) {
@@ -352,7 +353,7 @@
 		}
 	} else
 		warn("%s: cannot stat", to);
-
+#endif
 	ts[0] = sbp->st_atim;
 	ts[1] = sbp->st_mtim;
 	if (futimens(to_fd, ts))
@@ -454,6 +455,7 @@
 preserve_fd_acls(int source_fd, int dest_fd, const char *source_path,
     const char *dest_path)
 {
+#if 0
 	acl_t acl;
 	acl_type_t acl_type;
 	int acl_supported = 0, ret, trivial;
@@ -501,6 +503,12 @@
 		return;
 	}
 	acl_free(acl);
+#else
+	(void)source_fd;
+	(void)dest_fd;
+	(void)source_path;
+	(void)dest_path;
+#endif
 }
 
 static void
--- src.orig/coreutils/pr/pr.c
+++ src.freebsd/coreutils/pr/pr.c
@@ -65,6 +65,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <time.h>
 
 #include "pr.h"
 #include "extern.h"
@@ -1857,7 +1858,9 @@
 
 	(void) setlocale(LC_TIME, (Lflag != NULL) ? Lflag : "");
 
-	d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	d_first = 0;
+	if (strlen(nl_langinfo(D_FMT)) >= 2 && nl_langinfo(D_FMT)[1] == 'd')
+		d_first = 1;
 	timefrmt = strdup(d_first ? TIMEFMTD : TIMEFMTM);
 
 	return(0);
--- src.orig/coreutils/rm/rm.1
+++ src.freebsd/coreutils/rm/rm.1
@@ -42,7 +42,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl f | i
-.Op Fl dIRrvWx
+.Op Fl dIRrvx
 .Ar
 .Nm unlink
 .Op Fl -
@@ -110,11 +110,6 @@
 .Fl R .
 .It Fl v
 Be verbose when deleting files, showing them as they are removed.
-.It Fl W
-Attempt to undelete the named files.
-Currently, this option can only be used to recover
-files covered by whiteouts in a union file system (see
-.Xr undelete 2 ) .
 .It Fl x
 When removing a hierarchy, do not cross mount points.
 .El
@@ -211,9 +206,7 @@
 .Fx 13
 and may be removed in the future.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr rmdir 1 ,
-.Xr undelete 2 ,
 .Xr unlink 2 ,
 .Xr fts 3 ,
 .Xr getopt 3 ,
--- src.orig/coreutils/rm/rm.c
+++ src.freebsd/coreutils/rm/rm.c
@@ -54,13 +54,14 @@
 #include <grp.h>
 #include <locale.h>
 #include <pwd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sysexits.h>
 #include <unistd.h>
 
-static int dflag, eval, fflag, iflag, vflag, Wflag, stdin_ok;
+static int dflag, eval, fflag, iflag, vflag, stdin_ok;
 static int rflag, Iflag, xflag;
 static uid_t uid;
 static volatile sig_atomic_t info;
@@ -109,7 +110,7 @@
 	}
 
 	rflag = xflag = 0;
-	while ((ch = getopt(argc, argv, "dfiIPRrvWx")) != -1)
+	while ((ch = getopt(argc, argv, "dfiIPRrvx")) != -1)
 		switch(ch) {
 		case 'd':
 			dflag = 1;
@@ -135,9 +136,6 @@
 		case 'v':
 			vflag = 1;
 			break;
-		case 'W':
-			Wflag = 1;
-			break;
 		case 'x':
 			xflag = 1;
 			break;
@@ -198,8 +196,6 @@
 	flags = FTS_PHYSICAL;
 	if (!needstat)
 		flags |= FTS_NOSTAT;
-	if (Wflag)
-		flags |= FTS_WHITEOUT;
 	if (xflag)
 		flags |= FTS_XDEV;
 	if (!(fts = fts_open(argv, flags, NULL))) {
@@ -238,12 +234,6 @@
 				(void)fts_set(fts, p, FTS_SKIP);
 				p->fts_number = SKIPPED;
 			}
-			else if (!uid &&
-				 (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-				 !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-				 lchflags(p->fts_accpath,
-					 p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE)) < 0)
-				goto err;
 			continue;
 		case FTS_DP:
 			/* Post-order: see if user skipped. */
@@ -257,11 +247,13 @@
 		}
 
 		rval = 0;
+#if 0
 		if (!uid &&
 		    (p->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
 		    !(p->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)))
 			rval = lchflags(p->fts_accpath,
 				       p->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE));
+#endif
 		if (rval == 0) {
 			/*
 			 * If we can't read or search the directory, may still be
@@ -284,7 +276,7 @@
 					continue;
 				}
 				break;
-
+#if 0
 			case FTS_W:
 				rval = undelete(p->fts_accpath);
 				if (rval == 0 && (fflag && errno == ENOENT)) {
@@ -299,7 +291,7 @@
 					continue;
 				}
 				break;
-
+#endif
 			case FTS_NS:
 				/*
 				 * Assume that since fts_read() couldn't stat
@@ -308,7 +300,6 @@
 				if (fflag)
 					continue;
 				/* FALLTHROUGH */
-
 			case FTS_F:
 			case FTS_NSOK:
 			default:
@@ -326,7 +317,6 @@
 				}
 			}
 		}
-err:
 		warn("%s", p->fts_path);
 		eval = 1;
 	}
@@ -349,18 +339,10 @@
 	while ((f = *argv++) != NULL) {
 		/* Assume if can't stat the file, can't unlink it. */
 		if (lstat(f, &sb)) {
-			if (Wflag) {
-				sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
-			} else {
-				if (!fflag || errno != ENOENT) {
-					warn("%s", f);
-					eval = 1;
-				}
-				continue;
+			if (!fflag || errno != ENOENT) {
+				warn("%s", f);
+				eval = 1;
 			}
-		} else if (Wflag) {
-			warnx("%s: %s", f, strerror(EEXIST));
-			eval = 1;
 			continue;
 		}
 
@@ -369,21 +351,12 @@
 			eval = 1;
 			continue;
 		}
-		if (!fflag && !S_ISWHT(sb.st_mode) && !check(f, f, &sb))
+		if (!fflag && !check(f, f, &sb))
 			continue;
-		rval = 0;
-		if (!uid && !S_ISWHT(sb.st_mode) &&
-		    (sb.st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
-		    !(sb.st_flags & (SF_APPEND|SF_IMMUTABLE)))
-			rval = lchflags(f, sb.st_flags & ~(UF_APPEND|UF_IMMUTABLE));
-		if (rval == 0) {
-			if (S_ISWHT(sb.st_mode))
-				rval = undelete(f);
-			else if (S_ISDIR(sb.st_mode))
-				rval = rmdir(f);
-			else
-				rval = unlink(f);
-		}
+		if (S_ISDIR(sb.st_mode))
+			rval = rmdir(f);
+		else
+			rval = unlink(f);
 		if (rval && (!fflag || errno != ENOENT)) {
 			warn("%s", f);
 			eval = 1;
@@ -401,7 +374,9 @@
 check(const char *path, const char *name, struct stat *sp)
 {
 	int ch, first;
-	char modep[15], *flagsp;
+	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
 
 	/* Check -i first. */
 	if (iflag)
@@ -413,21 +388,20 @@
 		 * because their permissions are meaningless.  Check stdin_ok
 		 * first because we may not have stat'ed the file.
 		 */
-		if (!stdin_ok || S_ISLNK(sp->st_mode) ||
-		    (!access(name, W_OK) &&
-		    !(sp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
-		    (!(sp->st_flags & (UF_APPEND|UF_IMMUTABLE)) || !uid)))
+		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK))
 			return (1);
 		strmode(sp->st_mode, modep);
-		if ((flagsp = fflagstostr(sp->st_flags)) == NULL)
-			err(1, "fflagstostr");
-		(void)fprintf(stderr, "override %s%s%s/%s %s%sfor %s? ",
+		pw = getpwuid(sp->st_uid);
+		if (pw == NULL)
+			err(EXIT_FAILURE, "getpwuid");
+		gr = getgrgid(sp->st_gid);
+		if (gr == NULL)
+			err(EXIT_FAILURE, "getgrgid");
+		(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
 		    modep + 1, modep[10] == ' ' ? "" : " ",
-		    user_from_uid(sp->st_uid, 0),
-		    group_from_gid(sp->st_gid, 0),
-		    *flagsp ? flagsp : "", *flagsp ? " " : "",
+		    pw->pw_name,
+		    gr->gr_name,
 		    path);
-		free(flagsp);
 	}
 	(void)fflush(stderr);
 
--- src.orig/coreutils/sleep/sleep.1
+++ src.freebsd/coreutils/sleep/sleep.1
@@ -52,7 +52,7 @@
 .Nm
 command receives a signal, it takes the standard action.
 When the
-.Dv SIGINFO
+.Dv SIGUSR1
 signal is received, the estimate of the amount of seconds left to
 sleep is printed on the standard output.
 .Sh IMPLEMENTATION NOTES
--- src.orig/coreutils/sort/bwstring.c
+++ src.freebsd/coreutils/sort/bwstring.c
@@ -478,40 +478,100 @@
 bwsfgetln(FILE *f, size_t *len, bool zero_ended, struct reader_buffer *rb)
 {
 	wint_t eols;
+	wchar_t sbuf[256];
 
 	eols = zero_ended ? btowc('\0') : btowc('\n');
 
 	if (!zero_ended && (mb_cur_max > 1)) {
-		wchar_t *ret;
-
-		ret = fgetwln(f, len);
-
-		if (ret == NULL) {
+		wchar_t *buf = NULL;
+		wchar_t *wptr;
+		size_t bufsz = 0;
+		size_t wlen;
+		struct bwstring *ret;
+
+		wptr = fgetws(sbuf, sizeof(sbuf) / sizeof(wchar_t), f);
+		if (wptr) {
+			wlen = wcslen(wptr);
+			if (wptr[wlen - 1] == (wchar_t)eols)
+				return bwssbdup(wptr, wlen - 1);
+			if (feof(f))
+				return bwssbdup(wptr, wlen);
+		} else {
 			if (!feof(f))
 				err(2, NULL);
 			return (NULL);
 		}
-		if (*len > 0) {
-			if (ret[*len - 1] == (wchar_t)eols)
-				--(*len);
+		bufsz = wlen + 256;
+		buf = malloc(bufsz * sizeof(wchar_t));
+		memcpy(buf, wptr, wlen * sizeof(wchar_t));
+		for (;;) {
+			wchar_t *nptr = fgetws(&buf[wlen], 256, f);
+			if (!nptr) {
+				if (feof(f))
+					break;
+				free(buf);
+				err(2, NULL);
+			}
+			wlen += wcslen(nptr);
+			if (buf[wlen - 1] == (wchar_t)eols) {
+				--wlen;
+				break;
+			}
+			if (feof(f))
+				break;
+			bufsz += 256;
+			buf = realloc(buf, bufsz);
 		}
-		return (bwssbdup(ret, *len));
-
-	} else if (!zero_ended && (mb_cur_max == 1)) {
-		char *ret;
 
-		ret = fgetln(f, len);
-
-		if (ret == NULL) {
+		ret = bwssbdup(buf, wlen);
+		free(buf);
+		return ret;
+
+	} else if (!zero_ended && (MB_CUR_MAX == 1)) {
+		char *buf = NULL;
+		char *bptr;
+		size_t bufsz = 0;
+		size_t blen;
+		struct bwstring *ret;
+
+		bptr = fgets((char *)sbuf, sizeof(sbuf), f);
+		if (bptr) {
+			blen = strlen(bptr);
+			if (bptr[blen - 1] == '\n')
+				return bwscsbdup((unsigned char *)bptr, blen - 1);
+			if (feof(f))
+				return bwscsbdup((unsigned char *)bptr, blen);
+		} else {
 			if (!feof(f))
 				err(2, NULL);
 			return (NULL);
 		}
-		if (*len > 0) {
-			if (ret[*len - 1] == '\n')
-				--(*len);
+
+		bufsz = blen + 256;
+		buf = malloc(bufsz);
+		memcpy(buf, bptr, blen);
+		for (;;) {
+			char *nptr = fgets(&buf[blen], 256, f);
+			if (!f) {
+				if (feof(f))
+					break;
+				free(buf);
+				err(2, NULL);
+			}
+			blen += strlen(nptr);
+			if (buf[blen - 1] == '\n') {
+				--blen;
+				break;
+			}
+			if (feof(f))
+				break;
+			bufsz += 256;
+			buf = realloc(buf, bufsz);
 		}
-		return (bwscsbdup((unsigned char *)ret, *len));
+
+		ret = bwscsbdup((unsigned char *)buf, blen);
+		free(buf);
+		return ret;
 
 	} else {
 		*len = 0;
@@ -537,7 +597,7 @@
 						return (NULL);
 					goto line_read_done;
 				}
-				if (c == eols)
+				if ((wint_t)c == eols)
 					goto line_read_done;
 
 				if (*len + 1 >= rb->fgetwln_z_buffer_size) {
@@ -560,7 +620,7 @@
 						return (NULL);
 					goto line_read_done;
 				}
-				if (c == eols)
+				if ((wint_t)c == eols)
 					goto line_read_done;
 
 				if (*len + 1 >= rb->fgetwln_z_buffer_size) {
--- src.orig/coreutils/sort/coll.c
+++ src.freebsd/coreutils/sort/coll.c
@@ -37,7 +37,9 @@
 #include <langinfo.h>
 #include <limits.h>
 #include <math.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
@@ -60,7 +62,9 @@
 static int monthcoll(struct key_value*, struct key_value *, size_t offset);
 static int numcoll(struct key_value*, struct key_value *, size_t offset);
 static int hnumcoll(struct key_value*, struct key_value *, size_t offset);
+#ifndef WITHOUT_LIBCRYPTO
 static int randomcoll(struct key_value*, struct key_value *, size_t offset);
+#endif
 static int versioncoll(struct key_value*, struct key_value *, size_t offset);
 
 /*
@@ -473,8 +477,10 @@
 		return (gnumcoll);
 	else if (sm->Mflag)
 		return (monthcoll);
+#ifndef WITHOUT_LIBCRYPTO
 	else if (sm->Rflag)
 		return (randomcoll);
+#endif
 	else if (sm->Vflag)
 		return (versioncoll);
 	else
@@ -607,18 +613,18 @@
  * Compare two sort list items, according to the sort specs.
  */
 int
-list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll(const void *ss1, const void *ss2)
 {
 
-	return (list_coll_offset(ss1, ss2, 0));
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, 0));
 }
 
 #define	LSCDEF(N)							\
 static int 								\
-list_coll_##N(struct sort_list_item **ss1, struct sort_list_item **ss2)	\
+list_coll_##N(const void *ss1, const void *ss2)	\
 {									\
 									\
-	return (list_coll_offset(ss1, ss2, N));				\
+	return (list_coll_offset((struct sort_list_item **)ss1, (struct sort_list_item **)ss2, N)); \
 }
 
 LSCDEF(1)
@@ -662,9 +668,10 @@
  * Compare two sort list items, only by their original string.
  */
 int
-list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2)
+list_coll_by_str_only(const void *a1, const void *a2)
 {
-
+	struct sort_list_item **ss1 = (struct sort_list_item **)a1;
+	struct sort_list_item **ss2 = (struct sort_list_item **)a2;
 	return (top_level_str_coll(((*ss1)->str), ((*ss2)->str)));
 }
 
@@ -981,6 +988,7 @@
 	return (numcoll_impl(kv1, kv2, offset, true));
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /* Use hint space to memoize md5 computations, at least. */
 static void
 randomcoll_init_hint(struct key_value *kv, void *hash)
@@ -1037,6 +1045,7 @@
 
 	return (memcmp(hash1, hash2, sizeof(hash1)));
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Implements version sort (-V).
--- src.orig/coreutils/sort/coll.h
+++ src.freebsd/coreutils/sort/coll.h
@@ -105,7 +105,7 @@
 {
 	struct bwstring		*k; /* key string */
 	struct key_hint		 hint[0]; /* key sort hint */
-} __packed;
+} __attribute__((packed));
 
 /*
  * Set of keys container object.
@@ -141,7 +141,7 @@
 /*
  * Function type, used to compare two list objects
  */
-typedef int (*listcoll_t)(struct sort_list_item **ss1, struct sort_list_item **ss2);
+typedef int (*listcoll_t)(const void *ss1, const void *ss2);
 
 extern struct key_specs *keys;
 extern size_t keys_num;
@@ -173,8 +173,8 @@
 int top_level_str_coll(const struct bwstring *, const struct bwstring *);
 int key_coll(struct keys_array *ks1, struct keys_array *ks2, size_t offset);
 int str_list_coll(struct bwstring *str1, struct sort_list_item **ss2);
-int list_coll_by_str_only(struct sort_list_item **ss1, struct sort_list_item **ss2);
-int list_coll(struct sort_list_item **ss1, struct sort_list_item **ss2);
+int list_coll_by_str_only(const void *ss1, const void *ss2);
+int list_coll(const void *ss1, const void *ss2);
 int list_coll_offset(struct sort_list_item **ss1, struct sort_list_item **ss2, size_t offset);
 
 listcoll_t get_list_call_func(size_t offset);
--- src.orig/coreutils/sort/file.c
+++ src.freebsd/coreutils/sort/file.c
@@ -39,6 +39,7 @@
 #include <fcntl.h>
 #if defined(SORT_THREADS)
 #include <pthread.h>
+#include <sched.h>
 #endif
 #include <semaphore.h>
 #include <stdio.h>
@@ -632,7 +633,7 @@
 			size_t sz = 0;
 			int fd, flags;
 
-			flags = MAP_NOCORE | MAP_NOSYNC;
+			flags = MAP_PRIVATE;
 
 			fd = open(fsrc, O_RDONLY);
 			if (fd < 0)
@@ -654,6 +655,7 @@
 				close(fd);
 				break;
 			}
+			madvise(addr, sz, MADV_DONTDUMP);
 
 			ret->fd = fd;
 			ret->mmapaddr = addr;
@@ -1560,7 +1562,7 @@
 			pthread_attr_t attr;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -1569,7 +1571,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
--- src.orig/coreutils/sort/radixsort.c
+++ src.freebsd/coreutils/sort/radixsort.c
@@ -37,6 +37,7 @@
 #if defined(SORT_THREADS)
 #include <pthread.h>
 #include <semaphore.h>
+#include <sched.h>
 #endif
 #include <stdlib.h>
 #include <string.h>
@@ -647,7 +648,7 @@
 			pthread_t pth;
 
 			pthread_attr_init(&attr);
-			pthread_attr_setdetachstate(&attr, PTHREAD_DETACHED);
+			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
 			for (;;) {
 				int res = pthread_create(&pth, &attr,
@@ -655,7 +656,7 @@
 				if (res >= 0)
 					break;
 				if (errno == EAGAIN) {
-					pthread_yield();
+					sched_yield();
 					continue;
 				}
 				err(2, NULL);
@@ -684,7 +685,9 @@
 		pthread_mutexattr_t mattr;
 
 		pthread_mutexattr_init(&mattr);
+#ifdef PTHREAD_MUTEX_ADAPTIVE_NP
 		pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ADAPTIVE_NP);
+#endif
 
 		pthread_mutex_init(&g_ls_mutex, &mattr);
 		pthread_cond_init(&g_ls_cond, NULL);
--- src.orig/coreutils/sort/sort.1
+++ src.freebsd/coreutils/sort/sort.1
@@ -328,9 +328,9 @@
 .It Fl Fl debug
 Print some extra information about the sorting process to the
 standard output.
-%%THREADS%%.It Fl Fl parallel
-%%THREADS%%Set the maximum number of execution threads.
-%%THREADS%%Default number equals to the number of CPUs.
+.It Fl Fl parallel
+Set the maximum number of execution threads.
+Default number equals to the number of CPUs.
 .It Fl Fl files0-from Ns = Ns Ar filename
 Take the input file list from the file
 .Ar filename .
@@ -527,8 +527,6 @@
 behavior if neither the respective environment variable, nor
 .Ev LC_ALL
 are set.
-%%NLS%%.It Ev NLSPATH
-%%NLS%%Path to NLS catalogs.
 .It Ev TMPDIR
 Path to the directory in which temporary files will be stored.
 Note that
--- src.orig/coreutils/sort/sort.c
+++ src.freebsd/coreutils/sort/sort.c
@@ -31,7 +31,6 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/stat.h>
-#include <sys/sysctl.h>
 #include <sys/types.h>
 
 #include <err.h>
@@ -40,7 +39,9 @@
 #include <getopt.h>
 #include <limits.h>
 #include <locale.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 #include <regex.h>
 #include <signal.h>
 #include <stdbool.h>
@@ -62,9 +63,11 @@
 
 #define	OPTIONS	"bcCdfghik:Mmno:RrsS:t:T:uVz"
 
+#ifndef WITHOUT_LIBCRYPTO
 static bool need_random;
 
 MD5_CTX md5_ctx;
+#endif
 
 /*
  * Default messages to use when NLS is disabled or no catalogue
@@ -91,7 +94,11 @@
       "[--parallel thread_no] "
 #endif
       "[--human-numeric-sort] "
+#ifndef WITHOUT_LIBCRYPTO
+      "[--version-sort]] "
+#else
       "[--version-sort] [--random-sort [--random-source file]] "
+#endif
       "[--compress-program program] [file ...]\n" };
 
 struct sort_opts sort_opts_vals;
@@ -133,7 +140,9 @@
 #if defined(SORT_THREADS)
 	PARALLEL_OPT,
 #endif
+#ifndef WITHOUT_LIBCRYPTO
 	RANDOMSOURCE_OPT,
+#endif
 	COMPRESSPROGRAM_OPT,
 	QSORT_OPT,
 	MERGESORT_OPT,
@@ -174,8 +183,10 @@
 #endif
 				{ "qsort", no_argument, NULL, QSORT_OPT },
 				{ "radixsort", no_argument, NULL, RADIXSORT_OPT },
+#ifndef WITHOUT_LIBCRYPTO
 				{ "random-sort", no_argument, NULL, 'R' },
 				{ "random-source", required_argument, NULL, RANDOMSOURCE_OPT },
+#endif
 				{ "reverse", no_argument, NULL, 'r' },
 				{ "sort", required_argument, NULL, SORT_OPT },
 				{ "stable", no_argument, NULL, 's' },
@@ -329,16 +340,24 @@
 	lc = localeconv();
 
 	if (lc) {
+		wchar_t sym_decimal_point;
+		wchar_t sym_thousands_sep;
+		wchar_t sym_positive_sign;
+		wchar_t sym_negative_sign;
 		/* obtain LC_NUMERIC info */
 		/* Convert to wide char form */
-		conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
+		conv_mbtowc(&sym_decimal_point, lc->decimal_point,
 		    symbol_decimal_point);
-		conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
+		conv_mbtowc(&sym_thousands_sep, lc->thousands_sep,
 		    symbol_thousands_sep);
-		conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
+		conv_mbtowc(&sym_positive_sign, lc->positive_sign,
 		    symbol_positive_sign);
-		conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
+		conv_mbtowc(&sym_negative_sign, lc->negative_sign,
 		    symbol_negative_sign);
+		symbol_decimal_point = sym_decimal_point;
+		symbol_thousands_sep = sym_thousands_sep;
+		symbol_positive_sign = sym_positive_sign;
+		symbol_negative_sign = sym_negative_sign;
 	}
 
 	if (getenv("GNUSORT_NUMERIC_COMPATIBILITY"))
@@ -585,11 +604,13 @@
 	case 'i':
 		sm->iflag = true;
 		break;
+#ifndef WITHOUT_LIBCRYPTO
 	case 'R':
 		sm->Rflag = true;
 		need_hint = true;
 		need_random = true;
 		break;
+#endif
 	case 'M':
 		initialise_months();
 		sm->Mflag = true;
@@ -855,7 +876,7 @@
 void
 fix_obsolete_keys(int *argc, char **argv)
 {
-	char sopt[129];
+	char sopt[304];
 
 	for (int i = 1; i < *argc; i++) {
 		char *arg1;
@@ -911,6 +932,7 @@
 	}
 }
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * Seed random sort
  */
@@ -983,6 +1005,7 @@
 	MD5Init(&md5_ctx);
 	MD5Update(&md5_ctx, randseed, rd);
 }
+#endif /* WITHOUT_LIBCRYPTO */
 
 /*
  * Main function.
@@ -991,7 +1014,9 @@
 main(int argc, char **argv)
 {
 	char *outfile, *real_outfile;
+#ifndef WITHOUT_LIBCRYPTO
 	char *random_source = NULL;
+#endif
 	int c, result;
 	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
 	    { false, false, false, false, false, false };
@@ -1122,8 +1147,10 @@
 						set_sort_modifier(sm, 'n');
 					else if (!strcmp(optarg, "month"))
 						set_sort_modifier(sm, 'M');
+#ifndef WITHOUT_LIBCRYPTO
 					else if (!strcmp(optarg, "random"))
 						set_sort_modifier(sm, 'R');
+#endif
 					else
 						unknown(optarg);
 				}
@@ -1152,9 +1179,11 @@
 			case RADIXSORT_OPT:
 				sort_opts_vals.sort_method = SORT_RADIXSORT;
 				break;
+#ifndef WITHOUT_LIBCRYPTO
 			case RANDOMSOURCE_OPT:
 				random_source = strdup(optarg);
 				break;
+#endif
 			case COMPRESSPROGRAM_OPT:
 				compress_program = strdup(optarg);
 				break;
@@ -1247,8 +1276,10 @@
 		}
 	}
 
+#ifndef WITHOUT_LIBCRYPTO
 	if (need_random)
 		get_random_seed(random_source);
+#endif
 
 	/* Case when the outfile equals one of the input files: */
 	if (strcmp(outfile, "-")) {
--- src.orig/coreutils/sort/sort.h
+++ src.freebsd/coreutils/sort/sort.h
@@ -39,7 +39,9 @@
 #include <wchar.h>
 
 #include <sys/types.h>
+#ifndef WITHOUT_LIBCRYPTO
 #include <md5.h>
+#endif
 
 #define	VERSION	"2.3-FreeBSD"
 
@@ -66,10 +68,12 @@
  */
 extern bool debug_sort;
 
+#ifndef WITHOUT_LIBCRYPTO
 /*
  * MD5 context for random hash function
  */
 extern MD5_CTX md5_ctx;
+#endif
 
 /*
  * sort.c
--- src.orig/coreutils/split/split.c
+++ src.freebsd/coreutils/split/split.c
@@ -63,6 +63,10 @@
 #include <regex.h>
 #include <sysexits.h>
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 #define DEFLINE	1000			/* Default num lines per file. */
 
 static off_t	 bytecnt;		/* Byte count to split on. */
@@ -89,6 +93,7 @@
 	int ch;
 	int error;
 	char *ep, *p;
+	uint64_t ubytecnt;
 
 	setlocale(LC_ALL, "");
 
@@ -120,7 +125,8 @@
 			break;
 		case 'b':		/* Byte count. */
 			errno = 0;
-			error = expand_number(optarg, &bytecnt);
+			ubytecnt = bytecnt;
+			error = expand_number(optarg, &ubytecnt);
 			if (error == -1)
 				errx(EX_USAGE, "%s: offset too large", optarg);
 			break;
--- src.orig/coreutils/stat/stat.1
+++ src.freebsd/coreutils/stat/stat.1
@@ -38,7 +38,7 @@
 .Nd display file status
 .Sh SYNOPSIS
 .Nm
-.Op Fl FHLnq
+.Op Fl FLnq
 .Op Fl f Ar format | Fl l | r | s | x
 .Op Fl t Ar timefmt
 .Op Ar
@@ -90,11 +90,9 @@
 .Fa st_atime ,
 .Fa st_mtime ,
 .Fa st_ctime ,
-.Fa st_birthtime ,
 .Fa st_blksize ,
-.Fa st_blocks ,
 and
-.Fa st_flags
+.Fa st_blocks
 fields, in that order.
 .Pp
 The options are as follows:
@@ -124,13 +122,6 @@
 .Fl F
 implies
 .Fl l .
-.It Fl H
-Treat each argument as the hexadecimal representation of an NFS file handle,
-and use
-.Xr fhstat 2
-instead of
-.Xr lstat 2 .
-This requires root privileges.
 .It Fl L
 Use
 .Xr stat 2
@@ -273,11 +264,6 @@
 format.
 .It Cm dr
 Display actual device name.
-.It Cm f
-Display the flags of
-.Ar file
-as in
-.Nm ls Fl lTdo .
 .It Cm gu
 Display group or user name.
 .It Cm p
@@ -396,12 +382,11 @@
 .It Cm r
 Device number for character and block device special files
 .Pq Fa st_rdev .
-.It Cm a , m , c , B
+.It Cm a , m , c
 The time
 .Ar file
-was last accessed or modified, or when the inode was last changed, or
-the birth time of the inode
-.Pq Fa st_atime , st_mtime , st_ctime , st_birthtime .
+was last accessed or modified or when the inode was last changed
+.Pq Fa st_atime , st_mtime , st_ctime .
 .It Cm z
 The size of
 .Ar file
@@ -414,9 +399,6 @@
 .It Cm k
 Optimal file system I/O operation block size
 .Pq Fa st_blksize .
-.It Cm f
-User defined flags for
-.Ar file .
 .It Cm v
 Inode generation number
 .Pq Fa st_gen .
--- src.orig/coreutils/stat/stat.c
+++ src.freebsd/coreutils/stat/stat.c
@@ -42,17 +42,18 @@
 #if HAVE_CONFIG_H
 #include "config.h" 
 #else  /* HAVE_CONFIG_H */
-#define HAVE_STRUCT_STAT_ST_FLAGS 1
-#define HAVE_STRUCT_STAT_ST_GEN 1
-#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
+#define HAVE_STRUCT_STAT_ST_FLAGS 0
+#define HAVE_STRUCT_STAT_ST_GEN 0
+#define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
-#define HAVE_DEVNAME 1
+#define HAVE_DEVNAME 0
 #endif /* HAVE_CONFIG_H */
 
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
 
 #include <ctype.h>
 #include <err.h>
@@ -209,17 +210,14 @@
 {
 	struct stat st;
 	int ch, rc, errs, am_readlink;
-	int lsF, fmtchar, usestat, nfs_handle, fn, nonl, quiet;
+	int lsF, fmtchar, usestat, fn, nonl, quiet;
 	const char *statfmt, *options, *synopsis;
-	char dname[sizeof _PATH_DEV + SPECNAMELEN] = _PATH_DEV;
-	fhandle_t fhnd;
 	const char *file;
 
 	am_readlink = 0;
 	lsF = 0;
 	fmtchar = '\0';
 	usestat = 0;
-	nfs_handle = 0;
 	nonl = 0;
 	quiet = 0;
 	linkfail = 0;
@@ -234,7 +232,7 @@
 		fmtchar = 'f';
 		quiet = 1;
 	} else {
-		options = "f:FHlLnqrst:x";
+		options = "f:FlLnqrst:x";
 		synopsis = "[-FLnq] [-f format | -l | -r | -s | -x] "
 		    "[-t timefmt] [file|handle ...]";
 	}
@@ -244,9 +242,6 @@
 		case 'F':
 			lsF = 1;
 			break;
-                case 'H':
-			nfs_handle = 1;
-			break;
 		case 'L':
 			usestat = 1;
 			break;
@@ -324,37 +319,11 @@
 	errs = 0;
 	do {
 		if (argc == 0) {
-			if (fdevname_r(STDIN_FILENO, dname +
-			    sizeof _PATH_DEV - 1, SPECNAMELEN) != NULL)
-				file = dname;
-			else
-				file = "(stdin)";
+			file = "(stdin)";
 			rc = fstat(STDIN_FILENO, &st);
 		} else {
-			int j;
-
 			file = argv[0];
-			if (nfs_handle) {
-				rc = 0;
-				bzero(&fhnd, sizeof(fhnd));
-				j = MIN(2 * sizeof(fhnd), strlen(file));
-				if ((j & 1) != 0) {
-					rc = -1;
-				} else {
-					while (j) {
-						rc = hex2byte(&file[j - 2]);
-						if (rc == -1)
-							break;
-						((char*) &fhnd)[j / 2 - 1] = rc;
-						j -= 2;
-					}
-				}
-				if (rc == -1)
-					errno = EINVAL;
-				else
-					rc = fhstat(&fhnd, &st);
-
-			} else if (usestat) {
+			if (usestat) {
 				/*
 				 * Try stat() and if it fails, fall back to
 				 * lstat() just in case we're examining a
@@ -619,8 +588,10 @@
 {
 	u_int64_t data;
 	char *stmp, lfmt[24], tmp[20];
-	const char *sdata;
-	char smode[12], sid[12], path[PATH_MAX + 4];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	const char *sdata = NULL;
+	char smode[12], sid[13], path[PATH_MAX + 4];
 	const struct timespec *tsp;
 	struct timespec ts;
 	struct tm *tm;
@@ -717,10 +688,12 @@
 	case SHOW_st_uid:
 		small = (sizeof(st->st_uid) == 4);
 		data = st->st_uid;
-		sdata = user_from_uid(st->st_uid, 1);
-		if (sdata == NULL) {
+		pw = getpwuid(st->st_uid);
+		if (pw == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_uid);
 			sdata = sid;
+		} else {
+			sdata = pw->pw_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -730,10 +703,12 @@
 	case SHOW_st_gid:
 		small = (sizeof(st->st_gid) == 4);
 		data = st->st_gid;
-		sdata = group_from_gid(st->st_gid, 1);
-		if (sdata == NULL) {
+		gr = getgrgid(st->st_gid);
+		if (gr == NULL) {
 			snprintf(sid, sizeof(sid), "(%ld)", (long)st->st_gid);
 			sdata = sid;
+		} else {
+			sdata = gr->gr_name;
 		}
 		formats = FMTF_DECIMAL | FMTF_OCTAL | FMTF_UNSIGNED | FMTF_HEX |
 		    FMTF_STRING;
@@ -741,15 +716,15 @@
 			ofmt = FMTF_UNSIGNED;
 		break;
 	case SHOW_st_atime:
-		tsp = &st->st_atimespec;
+		tsp = &st->st_atim;
 		/* FALLTHROUGH */
 	case SHOW_st_mtime:
 		if (tsp == NULL)
-			tsp = &st->st_mtimespec;
+			tsp = &st->st_mtim;
 		/* FALLTHROUGH */
 	case SHOW_st_ctime:
 		if (tsp == NULL)
-			tsp = &st->st_ctimespec;
+			tsp = &st->st_ctim;
 		/* FALLTHROUGH */
 #if HAVE_STRUCT_STAT_ST_BIRTHTIME
 	case SHOW_st_btime:
@@ -1093,7 +1068,7 @@
 #define hex2nibble(c) (c <= '9' ? c - '0' : toupper(c) - 'A' + 10)
 int
 hex2byte(const char c[2]) {
-	if (!(ishexnumber(c[0]) && ishexnumber(c[1])))
+	if (!(isxdigit(c[0]) && isxdigit(c[1])))
 		return -1;
 	return (hex2nibble(c[0]) << 4) + hex2nibble(c[1]);
 }
--- src.orig/coreutils/stty/cchar.c
+++ src.freebsd/coreutils/stty/cchar.c
@@ -36,11 +36,14 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -56,12 +59,11 @@
  */
 struct cchar cchars1[] = {
 	{ "discard",	VDISCARD, 	CDISCARD },
-	{ "dsusp", 	VDSUSP,		CDSUSP },
+	{ "dsusp", 	CDSUSP,		CDSUSP },
 	{ "eof",	VEOF,		CEOF },
 	{ "eol",	VEOL,		CEOL },
 	{ "eol2",	VEOL2,		CEOL },
 	{ "erase",	VERASE,		CERASE },
-	{ "erase2",	VERASE2,	CERASE2 },
 	{ "intr",	VINTR,		CINTR },
 	{ "kill",	VKILL,		CKILL },
 	{ "lnext",	VLNEXT,		CLNEXT },
@@ -69,7 +71,7 @@
 	{ "quit",	VQUIT,		CQUIT },
 	{ "reprint",	VREPRINT, 	CREPRINT },
 	{ "start",	VSTART,		CSTART },
-	{ "status",	VSTATUS, 	CSTATUS },
+	{ "status",	CSTATUS, 	CSTATUS },
 	{ "stop",	VSTOP,		CSTOP },
 	{ "susp",	VSUSP,		CSUSP },
 	{ "time",	VTIME,		CTIME },
--- src.orig/coreutils/stty/extern.h
+++ src.freebsd/coreutils/stty/extern.h
@@ -42,4 +42,7 @@
 void	print(struct termios *, struct winsize *, int, enum FMT);
 void	usage(void) __dead2;
 
+int get_baud(speed_t s);
+speed_t get_speed(unsigned long b);
+
 extern struct cchar cchars1[], cchars2[];
--- src.orig/coreutils/stty/gfmt.c
+++ src.freebsd/coreutils/stty/gfmt.c
@@ -40,7 +40,9 @@
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -67,7 +69,7 @@
 	for (cp = cchars1; cp->name; ++cp)
 		(void)printf("%s=%x:", cp->name, tp->c_cc[cp->sub]);
 	(void)printf("ispeed=%lu:ospeed=%lu\n",
-	    (u_long)cfgetispeed(tp), (u_long)cfgetospeed(tp));
+	    (u_long)get_baud(cfgetispeed(tp)), (u_long)get_baud(cfgetospeed(tp)));
 }
 
 void
@@ -99,7 +101,7 @@
 		}
 		if (CHK("ispeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ispeed = tmp;
+			cfsetispeed(tp, tmp);
 			continue;
 		}
 		if (CHK("lflag")) {
@@ -112,7 +114,7 @@
 		}
 		if (CHK("ospeed")) {
 			tmp = strtoul(ep, NULL, 10);
-			tp->c_ospeed = tmp;
+			cfsetospeed(tp, tmp);
 			continue;
 		}
 		for (cp = cchars1; cp->name != NULL; ++cp)
--- src.orig/coreutils/stty/key.c
+++ src.freebsd/coreutils/stty/key.c
@@ -36,11 +36,15 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <sys/ttydefaults.h>
 
 #include <err.h>
+#include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -191,13 +195,23 @@
 void
 f_extproc(struct info *ip)
 {
+	struct termios tio;
+	errno = 0;
+
+	if (tcgetattr(ip->fd, &tio) == -1) {
+		err(1, "extproc");
+		return;
+	}
 
 	if (ip->off) {
-		int tmp = 0;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag &= ~EXTPROC;
 	} else {
-		int tmp = 1;
-		(void)ioctl(ip->fd, TIOCEXT, &tmp);
+		tio.c_lflag |= EXTPROC;
+	}
+
+	if (tcsetattr(ip->fd, TCSANOW, &tio) == -1) {
+		err(1, "extproc");
+		return;
 	}
 }
 
@@ -258,11 +272,16 @@
 {
 	struct termios def;
 
-	cfmakesane(&def);
+	def.c_cflag = TTYDEF_CFLAG;
+	def.c_iflag = TTYDEF_IFLAG;
+	def.c_lflag = TTYDEF_LFLAG;
+	def.c_oflag = TTYDEF_OFLAG;
+	cfsetispeed(&def, TTYDEF_SPEED);
+	cfsetospeed(&def, TTYDEF_SPEED);
 	ip->t.c_cflag = def.c_cflag | (ip->t.c_cflag & CLOCAL);
 	ip->t.c_iflag = def.c_iflag;
 	/* preserve user-preference flags in lflag */
-#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|ALTWERASE|TOSTOP|NOFLSH)
+#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|VWERASE|TOSTOP|NOFLSH)
 	ip->t.c_lflag = def.c_lflag | (ip->t.c_lflag & LKEEP);
 	ip->t.c_oflag = def.c_oflag;
 	ip->set = 1;
@@ -279,7 +298,7 @@
 f_speed(struct info *ip)
 {
 
-	(void)printf("%lu\n", (u_long)cfgetospeed(&ip->t));
+	(void)printf("%lu\n", (u_long)get_baud(cfgetospeed(&ip->t)));
 }
 
 void
@@ -287,7 +306,7 @@
 {
 	int tmp;
 
-	tmp = TTYDISC;
+	tmp = N_TTY;
 	if (ioctl(ip->fd, TIOCSETD, &tmp) < 0)
 		err(1, "TIOCSETD");
 }
--- src.orig/coreutils/stty/modes.c
+++ src.freebsd/coreutils/stty/modes.c
@@ -36,7 +36,9 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/types.h>
+#include <unistd.h>
 #include <string.h>
+#include <termios.h>
 #include "stty.h"
 
 int msearch(char ***, struct info *);
@@ -80,18 +82,6 @@
 	{ "-clocal",	0, CLOCAL },
 	{ "crtscts",	CRTSCTS, 0 },
 	{ "-crtscts",	0, CRTSCTS },
-	{ "ctsflow",	CCTS_OFLOW, 0 },
-	{ "-ctsflow",	0, CCTS_OFLOW },
-	{ "dsrflow",	CDSR_OFLOW, 0 },
-	{ "-dsrflow",	0, CDSR_OFLOW },
-	{ "dtrflow",	CDTR_IFLOW, 0 },
-	{ "-dtrflow",	0, CDTR_IFLOW },
-	{ "rtsflow",	CRTS_IFLOW, 0 },
-	{ "-rtsflow",	0, CRTS_IFLOW },
-	{ "mdmbuf",	MDMBUF, 0 },
-	{ "-mdmbuf",	0, MDMBUF },
-	{ "rtsdtr",	0, CNO_RTSDTR },
-	{ "-rtsdtr",	CNO_RTSDTR, 0 },
 	{ NULL,		0, 0 },
 };
 
@@ -146,8 +136,8 @@
 	{ "-echoke",	0, ECHOKE },
 	{ "crtkill",	ECHOKE, 0 },
 	{ "-crtkill",	0, ECHOKE },
-	{ "altwerase",	ALTWERASE, 0 },
-	{ "-altwerase",	0, ALTWERASE },
+	{ "altwerase",	VWERASE, 0 },
+	{ "-altwerase",	0, VWERASE },
 	{ "iexten",	IEXTEN, 0 },
 	{ "-iexten",	0, IEXTEN },
 	{ "echonl",	ECHONL, 0 },
@@ -176,10 +166,6 @@
 	{ "-crt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
 	{ "newcrt",	ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT },
 	{ "-newcrt",	ECHOK, ECHOE|ECHOKE|ECHOCTL },
-	{ "nokerninfo",	NOKERNINFO, 0 },
-	{ "-nokerninfo",0, NOKERNINFO },
-	{ "kerninfo",	0, NOKERNINFO },
-	{ "-kerninfo",	NOKERNINFO, 0 },
 	{ NULL,		0, 0 },
 };
 
--- src.orig/coreutils/stty/print.c
+++ src.freebsd/coreutils/stty/print.c
@@ -40,6 +40,8 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <string.h>
+#include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -60,12 +62,12 @@
 	cnt = 0;
 
 	/* Line discipline. */
-	if (ldisc != TTYDISC) {
+	if (ldisc != N_TTY) {
 		switch(ldisc) {
-		case SLIPDISC:
+		case N_SLIP:
 			cnt += printf("slip disc; ");
 			break;
-		case PPPDISC:
+		case N_PPP:
 			cnt += printf("ppp disc; ");
 			break;
 		default:
@@ -79,9 +81,9 @@
 	ospeed = cfgetospeed(tp);
 	if (ispeed != ospeed)
 		cnt +=
-		    printf("ispeed %d baud; ospeed %d baud;", ispeed, ospeed);
+		    printf("ispeed %d baud; ospeed %d baud;", get_baud(ispeed), get_baud(ospeed));
 	else
-		cnt += printf("speed %d baud;", ispeed);
+		cnt += printf("speed %d baud;", get_baud(ispeed));
 	if (fmt >= BSD)
 		cnt += printf(" %d rows; %d columns;", wp->ws_row, wp->ws_col);
 	if (cnt)
@@ -105,12 +107,11 @@
 	put("-echonl", ECHONL, 0);
 	put("-echoctl", ECHOCTL, 0);
 	put("-echoprt", ECHOPRT, 0);
-	put("-altwerase", ALTWERASE, 0);
+	put("-altwerase", VWERASE, 0);
 	put("-noflsh", NOFLSH, 0);
 	put("-tostop", TOSTOP, 0);
 	put("-flusho", FLUSHO, 0);
 	put("-pendin", PENDIN, 0);
-	put("-nokerninfo", NOKERNINFO, 0);
 	put("-extproc", EXTPROC, 0);
 
 	/* input flags */
@@ -170,26 +171,7 @@
 	put("-hupcl", HUPCL, 1);
 	put("-clocal", CLOCAL, 0);
 	put("-cstopb", CSTOPB, 0);
-	switch(tmp & (CCTS_OFLOW | CRTS_IFLOW)) {
-	case CCTS_OFLOW:
-		bput("ctsflow");
-		break;
-	case CRTS_IFLOW:
-		bput("rtsflow");
-		break;
-	default:
-		put("-crtscts", CCTS_OFLOW | CRTS_IFLOW, 0);
-		break;
-	}
-	put("-dsrflow", CDSR_OFLOW, 0);
-	put("-dtrflow", CDTR_IFLOW, 0);
-	put("-mdmbuf", MDMBUF, 0);	/* XXX mdmbuf ==  dtrflow */
-	if (on(CNO_RTSDTR))
-		bput("-rtsdtr");
-	else {
-		if (fmt >= BSD)
-			bput("rtsdtr");
-	}
+	put("-crtscts", CRTSCTS, 0);
 
 	/* special control characters */
 	cc = tp->c_cc;
--- src.orig/coreutils/stty/stty.1
+++ src.freebsd/coreutils/stty/stty.1
@@ -353,13 +353,6 @@
 erased with simply an
 .Dv ERASE
 character.)
-.It Cm mdmbuf Pq Fl mdmbuf
-If set, flow control output based on condition of Carrier Detect.
-Otherwise
-writes return an error if Carrier Detect is low (and Carrier is not being
-ignored with the
-.Dv CLOCAL
-flag.)
 .It Cm flusho Pq Fl flusho
 Indicates output is (is not) being discarded.
 .It Cm pendin Pq Fl pendin
@@ -393,7 +386,6 @@
 .It eol Ta Tn VEOL Ta EOL No character
 .It eol2 Ta Tn VEOL2 Ta EOL2 No character
 .It erase Ta Tn VERASE Ta ERASE No character
-.It erase2 Ta Tn VERASE2 Ta ERASE2 No character
 .It werase Ta Tn VWERASE Ta WERASE No character
 .It intr Ta Tn VINTR Ta INTR No character
 .It kill Ta Tn VKILL Ta KILL No character
@@ -401,10 +393,10 @@
 .It susp Ta Tn VSUSP Ta SUSP No character
 .It start Ta Tn VSTART Ta START No character
 .It stop Ta Tn VSTOP Ta STOP No character
-.It dsusp Ta Tn VDSUSP Ta DSUSP No character
+.It dsusp Ta Tn CDSUSP Ta DSUSP No character
 .It lnext Ta Tn VLNEXT Ta LNEXT No character
 .It reprint Ta Tn VREPRINT Ta REPRINT No character
-.It status Ta Tn VSTATUS Ta STATUS No character
+.It status Ta Tn CSTATUS Ta STATUS No character
 .El
 .Ed
 .It Cm min Ar number
@@ -452,22 +444,6 @@
 .Dv TTYDISC .
 .It Cm crt Pq Fl crt
 Set (disable) all modes suitable for a CRT display device.
-.It Cm kerninfo Pq Fl kerninfo
-Enable (disable) the system generated status line associated with
-processing a
-.Dv STATUS
-character (usually set to ^T).
-The status line consists of the
-system load average, the current command name, its process ID, the
-event the process is waiting on (or the status of the process), the user
-and system times, percent cpu, and current memory usage.
-.Pp
-If the
-.Xr sysctl 8
-variable
-.Va kern.tty_info_kstacks
-is set to a non-zero value, the status message also includes the kernel program
-stack of the foreground thread.
 .It Cm columns Ar number
 The terminal size is recorded as having
 .Ar number
--- src.orig/coreutils/stty/stty.c
+++ src.freebsd/coreutils/stty/stty.c
@@ -51,6 +51,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <errno.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -129,10 +131,11 @@
 
 		if (isdigit(**argv)) {
 			speed_t speed;
-
-			speed = strtonum(*argv, 0, UINT_MAX, &errstr);
+			unsigned int baud;
+			baud = (unsigned int)strtonum(*argv, 0, UINT_MAX, &errstr);
 			if (errstr)
 				err(1, "speed");
+			speed = get_speed(baud);
 			cfsetospeed(&i.t, speed);
 			cfsetispeed(&i.t, speed);
 			i.set = 1;
--- src.orig/coreutils/stty/util.c
+++ src.freebsd/coreutils/stty/util.c
@@ -40,6 +40,7 @@
 
 #include <err.h>
 #include <unistd.h>
+#include <termios.h>
 
 #include "stty.h"
 #include "extern.h"
@@ -60,3 +61,24 @@
 	    (sb1.st_rdev != sb2.st_rdev))
 warnx("stdout appears redirected, but stdin is the control descriptor");
 }
+
+static const int baudlist[] = {
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
+	19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600,
+	1000000, 1152000, 1500000, 2000000, 2500000, 3000000, 3500000, 4000000,
+};
+
+int get_baud(speed_t s) {
+	if (s & CBAUDEX)
+		s = (s & ~CBAUDEX) + 16;
+	return baudlist[s];
+}
+
+speed_t get_speed(unsigned long b) {
+	for (size_t i = 0; i < (sizeof(baudlist) / sizeof(int)); ++i) {
+		if ((unsigned long)baudlist[i] != b)
+			continue;
+		return i;
+	}
+	errx(1, "unknown speed for baud %lu", b);
+}
--- src.orig/coreutils/tail/forward.c
+++ src.freebsd/coreutils/tail/forward.c
@@ -46,12 +46,16 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/mman.h>
-#include <sys/event.h>
+#include <sys/inotify.h>
+#include <sys/vfs.h>
+
+#include <linux/magic.h>
 
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <poll.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -68,12 +72,12 @@
 
 /* defines for inner loop actions */
 #define USE_SLEEP	0
-#define USE_KQUEUE	1
+#define USE_INOTIFY	1
 #define ADD_EVENTS	2
 
-static struct kevent *ev;
+static int *ev;
 static int action = USE_SLEEP;
-static int kq;
+static int ifd;
 
 static const file_info_t *last;
 
@@ -265,41 +269,118 @@
 	return 1;
 }
 
+/* a rather ugly list of filesystems from linux/magic.h specifying whether
+ * we can watch them with inotify; explicitly specify them as we can still
+ * fall back to sleep for the other filesystems, while the opposite would
+ * cause actual practical problems
+ */
+static int
+fs_is_local(unsigned long magic)
+{
+	switch (magic) {
+	case ADFS_SUPER_MAGIC:
+	case AFFS_SUPER_MAGIC:
+	case ANON_INODE_FS_MAGIC:
+	case BDEVFS_MAGIC:
+	case BINFMTFS_MAGIC:
+	case BPF_FS_MAGIC:
+	case BTRFS_SUPER_MAGIC:
+	case BTRFS_TEST_MAGIC:
+	case CGROUP_SUPER_MAGIC:
+	case CGROUP2_SUPER_MAGIC:
+	case CRAMFS_MAGIC:
+	case DEBUGFS_MAGIC:
+	case DEVPTS_SUPER_MAGIC:
+	case ECRYPTFS_SUPER_MAGIC:
+	case EFS_SUPER_MAGIC:
+	case EXT2_SUPER_MAGIC:
+	case F2FS_SUPER_MAGIC:
+	case FUTEXFS_SUPER_MAGIC:
+	case HOSTFS_SUPER_MAGIC:
+	case HPFS_SUPER_MAGIC:
+	case HUGETLBFS_MAGIC:
+	case ISOFS_SUPER_MAGIC:
+	case JFFS2_SUPER_MAGIC:
+	case MINIX_SUPER_MAGIC:
+	case MINIX_SUPER_MAGIC2:
+	case MINIX2_SUPER_MAGIC:
+	case MINIX2_SUPER_MAGIC2:
+	case MINIX3_SUPER_MAGIC:
+	case MSDOS_SUPER_MAGIC:
+	case MTD_INODE_FS_MAGIC:
+	case NILFS_SUPER_MAGIC:
+	case NSFS_MAGIC:
+	case OPENPROM_SUPER_MAGIC:
+	case OVERLAYFS_SUPER_MAGIC:
+	case PROC_SUPER_MAGIC:
+	case PSTOREFS_MAGIC:
+	case QNX4_SUPER_MAGIC:
+	case QNX6_SUPER_MAGIC:
+	case RAMFS_MAGIC:
+	case REISERFS_SUPER_MAGIC:
+	case SECURITYFS_MAGIC:
+	case SELINUX_MAGIC:
+	case SMACK_MAGIC:
+	case SOCKFS_MAGIC:
+	case SQUASHFS_MAGIC:
+	case SYSFS_MAGIC:
+	case TMPFS_MAGIC:
+	case TRACEFS_MAGIC:
+	case UDF_SUPER_MAGIC:
+	case USBDEVICE_SUPER_MAGIC:
+	case V9FS_MAGIC:
+	case XENFS_SUPER_MAGIC:
+	case XFS_SUPER_MAGIC:
+		return 1;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* in addition to handling the watches, this also keeps a mapping of inotify
+ * watches to the actual file descriptors, it does so by keeping fixed indexes
+ * for each file; watches are registered so that they do not replace each other
+ */
 static void
 set_events(file_info_t *files)
 {
-	int i, n = 0;
+	int i;
 	file_info_t *file;
-	struct timespec ts;
 	struct statfs sf;
 
-	ts.tv_sec = 0;
-	ts.tv_nsec = 0;
-
-	action = USE_KQUEUE;
+	action = USE_INOTIFY;
 	for (i = 0, file = files; i < no_files; i++, file++) {
 		if (! file->fp)
 			continue;
 
-		if (fstatfs(fileno(file->fp), &sf) == 0 &&
-		    (sf.f_flags & MNT_LOCAL) == 0) {
+		if (fstatfs(fileno(file->fp), &sf) == 0 && !fs_is_local(sf.f_type)) {
 			action = USE_SLEEP;
 			return;
 		}
 
-		if (Fflag && fileno(file->fp) != STDIN_FILENO) {
-			EV_SET(&ev[n], fileno(file->fp), EVFILT_VNODE,
-			    EV_ADD | EV_ENABLE | EV_CLEAR,
-			    NOTE_DELETE | NOTE_RENAME, 0, 0);
-			n++;
+		if (fileno(file->fp) == STDIN_FILENO) {
+			action = USE_SLEEP;
+			return;
 		}
-		EV_SET(&ev[n], fileno(file->fp), EVFILT_READ,
-		    EV_ADD | EV_ENABLE | EV_CLEAR, 0, 0, 0);
-		n++;
 	}
 
-	if (kevent(kq, ev, n, NULL, 0, &ts) < 0) {
-		action = USE_SLEEP;
+	for (i = 0, file = files; i < no_files; i++, file++) {
+		uint32_t mask = IN_MODIFY | IN_MASK_ADD;
+
+		if (! file->fp) {
+			ev[i * 2 + 1] = 0;
+			continue;
+		}
+
+		ev[i * 2 + 1] = fileno(file->fp);
+
+		if (Fflag)
+			mask |= IN_DELETE_SELF | IN_MOVE_SELF;
+
+		ev[i * 2] = inotify_add_watch(ifd, file->file_name, mask);
+		if (ev[i * 2] < 0)
+			err(1, "inotify_add_watch");
 	}
 }
 
@@ -314,7 +395,7 @@
 	struct stat sb2;
 	file_info_t *file;
 	FILE *ftmp;
-	struct timespec ts;
+	struct pollfd fd;
 
 	/* Position each of the files */
 
@@ -337,14 +418,19 @@
 
 	last = --file;
 
-	kq = kqueue();
-	if (kq < 0)
-		err(1, "kqueue");
-	ev = malloc(n * sizeof(struct kevent));
+	ifd = inotify_init1(IN_NONBLOCK);
+	if (ifd < 0)
+		err(1, "inotify");
+
+	ev = calloc(no_files * 2, sizeof(int));
 	if (! ev)
-	    err(1, "Couldn't allocate memory for kevents.");
+		err(1, "Couldn't allocate memory for watch descriptors.");
+
 	set_events(files);
 
+	fd.fd = ifd;
+	fd.events = POLLIN;
+
 	for (;;) {
 		ev_change = 0;
 		if (Fflag) {
@@ -405,28 +491,61 @@
 			set_events(files);
 
 		switch (action) {
-		case USE_KQUEUE:
-			ts.tv_sec = 1;
-			ts.tv_nsec = 0;
+		case USE_INOTIFY: {
 			/*
 			 * In the -F case we set a timeout to ensure that
 			 * we re-stat the file at least once every second.
 			 */
-			n = kevent(kq, NULL, 0, ev, 1, Fflag ? &ts : NULL);
+			n = poll(&fd, 1, Fflag ? 1000 : -1);
 			if (n < 0)
-				err(1, "kevent");
+				err(1, "poll");
 			if (n == 0) {
 				/* timeout */
 				break;
-			} else if (ev->filter == EVFILT_READ && ev->data < 0) {
-				/* file shrank, reposition to end */
-				if (lseek(ev->ident, (off_t)0, SEEK_END) == -1) {
-					ierr(file->file_name);
-					continue;
+			} else if (fd.revents & POLLIN) {
+				struct inotify_event iev;
+				ssize_t len = read(ifd, &iev, sizeof(iev));
+
+				if (len < 0 && errno != EAGAIN)
+					err(1, "read");
+
+				if (len != sizeof(iev))
+					break;
+
+				/* skip name field */
+				for (; iev.len > 0; --iev.len) {
+					char c;
+					if (read(ifd, &c, 1) != 1)
+						err(1, "read");
+				}
+
+				/* we only care about the file shrinking here */
+				if (!(iev.mask & IN_MODIFY))
+					break;
+
+				/* locate the event source */
+				for (i = 0; i < n; ++i) {
+					struct stat st;
+					if (ev[i * 2] != iev.wd)
+						continue;
+					/* ignore watches with a cleared file descriptor */
+					if (ev[i * 2 + 1] == 0)
+						continue;
+					/* located a file, re-stat it and if it's smaller
+					 * than its current position, reposition to end */
+					if (fstat(ev[i * 2 + 1], &st) < 0)
+						err(1, "stat");
+					/* all is ok */
+					if (st.st_size > lseek(ev[i * 2 + 1], 0, SEEK_CUR))
+						break;
+					/* reposition */
+					if (lseek(ev[i * 2 + 1], 0, SEEK_END) < 0)
+						err(1, "lseek");
+					break;
 				}
 			}
 			break;
-
+		}
 		case USE_SLEEP:
 			(void) usleep(250000);
 			break;
--- src.orig/coreutils/tail/reverse.c
+++ src.freebsd/coreutils/tail/reverse.c
@@ -60,6 +60,14 @@
 
 #include "extern.h"
 
+/* some versions of queue.h don't come with this */
+#ifndef TAILQ_FOREACH_FROM_SAFE
+#define TAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)                 \
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));             \
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);            \
+	    (var) = (tvar))
+#endif
+
 static void r_buf(FILE *, const char *);
 static void r_reg(FILE *, const char *, enum STYLE, off_t, struct stat *);
 
--- src.orig/coreutils/tail/tail.c
+++ src.freebsd/coreutils/tail/tail.c
@@ -113,7 +113,7 @@
 	case '+':							\
 		if (off)						\
 			off -= (units);					\
-			style = (forward);				\
+		style = (forward);				\
 		break;							\
 	case '-':							\
 		off = -off;						\
--- src.orig/coreutils/timeout/timeout.c
+++ src.freebsd/coreutils/timeout/timeout.c
@@ -28,7 +28,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
-#include <sys/procctl.h>
+#include <sys/prctl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
 
@@ -104,16 +104,19 @@
 {
 	int sig, i;
 	const char *errstr;
+	const char *signame;
 
-	sig = strtonum(str, 1, sys_nsig - 1, &errstr);
+	sig = strtonum(str, 1, NSIG, &errstr);
 
 	if (errstr == NULL)
 		return (sig);
+
 	if (strncasecmp(str, "SIG", 3) == 0)
 		str += 3;
 
-	for (i = 1; i < sys_nsig; i++) {
-		if (strcasecmp(str, sys_signame[i]) == 0)
+	for (i = 1; i < NSIG; i++) {
+		signame = signum_to_signame(i);
+		if (signame && strcasecmp(str, signame) == 0)
 			return (i);
 	}
 
@@ -174,8 +177,7 @@
 	bool do_second_kill = false;
 	bool child_done = false;
 	struct sigaction signals;
-	struct procctl_reaper_status info;
-	struct procctl_reaper_kill killemall;
+	unsigned long info;
 	int signums[] = {
 		-1,
 		SIGTERM,
@@ -228,8 +230,8 @@
 
 	if (!foreground) {
 		/* Acquire a reaper */
-		if (procctl(P_PID, getpid(), PROC_REAP_ACQUIRE, NULL) == -1)
-			err(EX_OSERR, "Fail to acquire the reaper");
+		if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0) == -1)
+			err(EX_OSERR, "Fail to set the reaper");
 	}
 
 	memset(&signals, 0, sizeof(signals));
@@ -297,9 +299,8 @@
 				if (foreground) {
 					break;
 				} else {
-					procctl(P_PID, getpid(),
-					    PROC_REAP_STATUS, &info);
-					if (info.rs_children == 0)
+					prctl(PR_GET_CHILD_SUBREAPER, &info, 0, 0);
+					if (info == 0)
 						break;
 				}
 			}
@@ -308,10 +309,8 @@
 
 			timedout = true;
 			if (!foreground) {
-				killemall.rk_sig = killsig;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGKILL) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, killsig);
 
@@ -325,10 +324,8 @@
 
 		} else if (sig_term) {
 			if (!foreground) {
-				killemall.rk_sig = sig_term;
-				killemall.rk_flags = 0;
-				procctl(P_PID, getpid(), PROC_REAP_KILL,
-				    &killemall);
+				if (kill(getpid(), SIGTERM) == -1)
+					err(EXIT_FAILURE, "kill");
 			} else
 				kill(pid, sig_term);
 
@@ -348,7 +345,7 @@
 	}
 
 	if (!foreground)
-		procctl(P_PID, getpid(), PROC_REAP_RELEASE, NULL);
+		prctl(PR_SET_CHILD_SUBREAPER, 0, 0, 0);
 
 	if (WEXITSTATUS(pstat))
 		pstat = WEXITSTATUS(pstat);
--- src.orig/coreutils/tr/cmap.h
+++ src.freebsd/coreutils/tr/cmap.h
@@ -47,7 +47,7 @@
 	wint_t		cm_cache[CM_CACHE_SIZE];
 	bool		cm_havecache;
 	struct cmapnode	*cm_root;
-#define	CM_DEF_SELF	-2
+#define	CM_DEF_SELF	(wint_t)(-2)
 	wint_t		cm_def;
 	wint_t		cm_min;
 	wint_t		cm_max;
--- src.orig/coreutils/tr/extern.h
+++ src.freebsd/coreutils/tr/extern.h
@@ -35,7 +35,7 @@
 #include <limits.h>
 
 #define	NCHARS_SB	(UCHAR_MAX + 1)	/* Number of single-byte characters. */
-#define	OOBCH		-1		/* Out of band character value. */
+#define	OOBCH		(wint_t)(-1)		/* Out of band character value. */
 
 typedef struct {
 	enum { STRING1, STRING2 } which;
@@ -51,3 +51,5 @@
 
 wint_t	 next(STR *);
 int charcoll(const void *, const void *);
+
+#define iswrune(v) (iswprint(v) || iswcntrl(v))
--- src.orig/coreutils/tr/str.c
+++ src.freebsd/coreutils/tr/str.c
@@ -58,6 +58,44 @@
 static int      genrange(STR *, int);
 static void	genseq(STR *);
 
+static wint_t
+findwchar(wctype_t wct, wchar_t min, wchar_t max)
+{
+	for (; min <= max; ++min) {
+		if (iswctype(min, wct))
+			return min;
+	}
+	return (wint_t)-1;
+}
+
+/* we cannot reasonably implement this for wide characters/unicode, since
+ * the standard posix api has no way to find out the actual ranges, and
+ * doing binary search on the entire wchar range is inefficient (especially
+ * considering the character range does not have to be contiguous, which
+ * means doing a new search after we get to the end of the current part
+ * of the range)
+ *
+ * therefore, stick with what is representable in the C locale and do a
+ * simple linear search instead, this should always get us reliable results
+ */
+
+static wint_t
+nextwctype(wint_t ch, wctype_t wct)
+{
+	if (ch == (wint_t)-1) {
+		/* locate first character in the class */
+		return findwchar(wct, 0, UCHAR_MAX);
+	}
+
+	if ((ch == (wint_t)-1) || (ch >= UCHAR_MAX))
+		return (wint_t)-1;
+
+	if (!iswctype(++ch, wct))
+		return findwchar(wct, ch, UCHAR_MAX);
+
+	return ch;
+}
+
 wint_t
 next(STR *s)
 {
@@ -116,7 +154,7 @@
 	case CCLASS_LOWER:
 		s->cnt++;
 		ch = nextwctype(s->lastch, s->cclass);
-		if (ch == -1) {
+		if (ch == (wint_t)-1) {
 			s->state = NORMAL;
 			return (next(s));
 		}
@@ -241,9 +279,10 @@
 static int
 genrange(STR *s, int was_octal)
 {
-	int stopval, octal;
+	wint_t stopval;
+	int octal;
 	char *savestart;
-	int n, cnt, *p;
+	wint_t n, cnt, *p;
 	size_t clen;
 	wchar_t wc;
 
--- src.orig/coreutils/tr/tr.c
+++ src.freebsd/coreutils/tr/tr.c
@@ -78,6 +78,7 @@
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+	int optc;
 
 	(void)setlocale(LC_ALL, "");
 
@@ -88,8 +89,8 @@
 		err(1, "unable to enter capability mode");
 
 	Cflag = cflag = dflag = sflag = 0;
-	while ((ch = getopt(argc, argv, "Ccdsu")) != -1)
-		switch((char)ch) {
+	while ((optc = getopt(argc, argv, "Ccdsu")) != -1)
+		switch(optc) {
 		case 'C':
 			Cflag = 1;
 			cflag = 0;
@@ -119,6 +120,7 @@
 	default:
 		usage();
 		/* NOTREACHED */
+		return 1;
 	case 1:
 		isstring2 = 0;
 		break;
@@ -307,7 +309,7 @@
 
 		s2.str = argv[1];
 		s2.state = NORMAL;
-		for (cnt = 0; cnt < n; cnt++) {
+		for (cnt = 0; cnt < (wint_t)n; cnt++) {
 			(void)next(&s2);
 			cmap_add(map, carray[cnt], s2.lastch);
 			/*
--- src.orig/coreutils/truncate/truncate.c
+++ src.freebsd/coreutils/truncate/truncate.c
@@ -27,8 +27,10 @@
  *
  */
 
+#if 0
 static const char rcsid[] =
     "$FreeBSD$";
+#endif
 
 #include <sys/stat.h>
 
@@ -39,6 +41,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdint.h>
 
 #include <libutil.h>
 
--- src.orig/coreutils/tsort/tsort.c
+++ src.freebsd/coreutils/tsort/tsort.c
@@ -48,7 +48,6 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <db.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -98,7 +97,83 @@
 	int b_bsize;
 } BUF;
 
-static DB *db;
+#define HASH_CHUNK_SIZE 64
+#define HASH_BUCKET_COUNT 1024
+
+struct hash_elem {
+	NODE *elem;
+	struct hash_elem *next;
+};
+
+struct hash_chunk {
+	struct hash_elem elems[HASH_CHUNK_SIZE];
+	struct hash_chunk *next;
+};
+
+struct hash {
+	struct hash_elem **elems;
+	struct hash_chunk *chunks;
+	struct hash_elem *top;
+};
+
+static void hash_init(struct hash *h) {
+	h->chunks = NULL;
+	h->top = NULL;
+	h->elems = calloc(1024, sizeof(struct hash_elem *));
+}
+
+static void hash_destroy(struct hash *h) {
+	for (size_t i = 0; i < HASH_BUCKET_COUNT; ++i) {
+		struct hash_elem *e = h->elems[i];
+		while (e) {
+			free(e->elem->n_arcs);
+			free(e->elem);
+			e = e->next;
+		}
+	}
+	free(h->elems);
+	while (h->chunks) {
+		struct hash_chunk *c = h->chunks;
+		h->chunks = h->chunks->next;
+		free(c);
+	}
+}
+
+static size_t hash_key(char *key) {
+	size_t h = 5381;
+	for (size_t i = 0, k; (k = key[i]); ++i)
+		h = ((h << 5) + h) ^ k;
+	return h;
+}
+
+static NODE *hash_find(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	for (struct hash_elem *c = h->elems[hash]; c; c = c->next) {
+		if (!strcmp(key, c->elem->n_name))
+			return c->elem;
+	}
+	return NULL;
+}
+
+static struct hash_elem *hash_insert(struct hash *h, char *key) {
+	size_t hash = hash_key(key) & (HASH_BUCKET_COUNT - 1);
+	if (!h->top) {
+		struct hash_chunk *c = calloc(1, sizeof(struct hash_chunk));
+		c->next = h->chunks;
+		h->chunks = c;
+		for (size_t i = 0; i < (HASH_CHUNK_SIZE - 1); ++i) 
+			c->elems[i].next = &c->elems[i + 1];
+		c->elems[HASH_CHUNK_SIZE - 1].next = h->top;
+		h->top = c->elems;
+	}
+	struct hash_elem *hc = h->top;
+	h->top = h->top->next;
+	hc->next = h->elems[hash];
+	h->elems[hash] = hc;
+	return hc;
+}
+
+static struct hash db;
 static NODE *graph, **cycle_buf, **longest_cycle;
 static int debug, longest, quiet;
 
@@ -154,6 +229,8 @@
 	for (b = bufs, n = 2; --n >= 0; b++)
 		b->b_buf = grow_buf(NULL, b->b_bsize = 1024);
 
+	hash_init(&db);
+
 	/* parse input and build the graph */
 	for (n = 0, c = getc(fp);;) {
 		while (c != EOF && isspace(c))
@@ -183,6 +260,7 @@
 
 	/* do the sort */
 	tsort();
+	hash_destroy(&db);
 	exit(0);
 }
 
@@ -237,28 +315,15 @@
 static NODE *
 get_node(char *name)
 {
-	DBT data, key;
-	NODE *n;
+	NODE *n = hash_find(&db, name);
+	size_t nlen;
 
-	if (db == NULL &&
-	    (db = dbopen(NULL, O_RDWR, 0, DB_HASH, NULL)) == NULL)
-		err(1, "db: %s", name);
-
-	key.data = name;
-	key.size = strlen(name) + 1;
+	if (n)
+		return n;
 
-	switch ((*db->get)(db, &key, &data, 0)) {
-	case 0:
-		bcopy(data.data, &n, sizeof(n));
-		return (n);
-	case 1:
-		break;
-	default:
-	case -1:
-		err(1, "db: %s", name);
-	}
+	nlen = strlen(name) + 1;
 
-	if ((n = malloc(sizeof(NODE) + key.size)) == NULL)
+	if ((n = malloc(sizeof(NODE) + nlen)) == NULL)
 		err(1, NULL);
 
 	n->n_narcs = 0;
@@ -266,7 +331,7 @@
 	n->n_arcs = NULL;
 	n->n_refcnt = 0;
 	n->n_flags = 0;
-	bcopy(name, n->n_name, key.size);
+	bcopy(name, n->n_name, nlen);
 
 	/* Add to linked list. */
 	if ((n->n_next = graph) != NULL)
@@ -275,10 +340,7 @@
 	graph = n;
 
 	/* Add to hash table. */
-	data.data = &n;
-	data.size = sizeof(n);
-	if ((*db->put)(db, &key, &data, 0))
-		err(1, "db: %s", name);
+	hash_insert(&db, name)->elem = n;
 	return (n);
 }
 
--- src.orig/coreutils/uname/uname.c
+++ src.freebsd/coreutils/uname/uname.c
@@ -49,15 +49,14 @@
 #endif
 
 #include <sys/param.h>
-#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 
-#include <osreldate.h>
-
 #define	MFLAG	0x01
 #define	NFLAG	0x02
 #define	PFLAG	0x04
@@ -205,95 +204,39 @@
 	printf("\n");
 }
 
-#define	NATIVE_SYSCTL2_GET(var,mib0,mib1)	\
-static void					\
-native_##var(void)				\
-{						\
-	int mib[] = { (mib0), (mib1) };		\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctl(mib, sizeof mib / sizeof mib[0],	\
-	   &buf, &len, NULL, 0) == -1)		\
-		err(1, "sysctl");
-
-#define	NATIVE_SYSCTLNAME_GET(var,name)		\
-static void					\
-native_##var(void)				\
-{						\
-	size_t len;				\
-	static char buf[1024];			\
-	char **varp = &(var);			\
-						\
-	len = sizeof buf;			\
-	if (sysctlbyname(name, &buf, &len, NULL,\
-	    0) == -1)				\
-		err(1, "sysctlbyname");
-
-#define	NATIVE_SET				\
-	*varp = buf;				\
-	return;					\
-}	struct __hack
-
-#define	NATIVE_BUFFER	(buf)
-#define	NATIVE_LENGTH	(len)
-
-NATIVE_SYSCTL2_GET(sysname, CTL_KERN, KERN_OSTYPE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(hostname, CTL_KERN, KERN_HOSTNAME) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(release, CTL_KERN, KERN_OSRELEASE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(version, CTL_KERN, KERN_VERSION) {
-	size_t n;
-	char *p;
-
-	p = NATIVE_BUFFER;
-	n = NATIVE_LENGTH;
-	for (; n--; ++p)
-		if (*p == '\n' || *p == '\t') {
-			if (n > 1)
-				*p = ' ';
-			else
-				*p = '\0';
-		}
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(platform, CTL_HW, HW_MACHINE) {
-} NATIVE_SET;
-
-NATIVE_SYSCTL2_GET(arch, CTL_HW, HW_MACHINE_ARCH) {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(ident, "kern.ident") {
-} NATIVE_SET;
-
-NATIVE_SYSCTLNAME_GET(buildid, "kern.build_id") {
-} NATIVE_SET;
-
-static void
-native_uservers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", __FreeBSD_version);
-	uservers = buf;
+#define NATIVE_UNAME_GET(var,field) \
+static void \
+native_##var(void) \
+{ \
+	static char buf[1024]; \
+	struct utsname u; \
+ \
+	if (uname(&u) != 0) \
+		err(1, "uname"); \
+\
+	snprintf(buf, sizeof(buf), "%s", u.field); \
+	var = buf; \
 }
 
-static void
-native_kernvers(void)
-{
-	static char buf[128];
-
-	snprintf(buf, sizeof(buf), "%d", getosreldate());
-	kernvers = buf;
+NATIVE_UNAME_GET(sysname, sysname)
+NATIVE_UNAME_GET(hostname, nodename)
+NATIVE_UNAME_GET(release, release)
+NATIVE_UNAME_GET(version, version)
+NATIVE_UNAME_GET(platform, machine)
+
+#define UNKNOWN_GET(var) \
+static void \
+native_##var(void) \
+{ \
+	var = "unknown"; \
 }
 
+UNKNOWN_GET(arch)
+UNKNOWN_GET(ident)
+UNKNOWN_GET(buildid)
+UNKNOWN_GET(uservers)
+UNKNOWN_GET(kernvers)
+
 static void
 usage(void)
 {
--- src.orig/coreutils/uniq/uniq.c
+++ src.freebsd/coreutils/uniq/uniq.c
@@ -174,7 +174,7 @@
 	if (cap_rights_is_set(&rights, CAP_IOCTL)) {
 		unsigned long cmd;
 
-		cmd = TIOCGETA; /* required by isatty(3) in printf(3) */
+		cmd = 0; /* required by isatty(3) in printf(3) */
 
 		if (caph_ioctls_limit(fileno(ofp), &cmd, 1) < 0) {
 			err(1, "unable to limit ioctls for %s",
--- src.orig/coreutils/wc/wc.1
+++ src.freebsd/coreutils/wc/wc.1
@@ -130,7 +130,7 @@
 If
 .Nm
 receives a
-.Dv SIGINFO
+.Dv SIGUSR1
 (see the
 .Cm status
 argument for
--- src.orig/coreutils/wc/wc.c
+++ src.freebsd/coreutils/wc/wc.c
@@ -47,6 +47,7 @@
 #include <sys/capsicum.h>
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
@@ -54,6 +55,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
+#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -313,7 +315,7 @@
 			if (!domulti || MB_CUR_MAX == 1) {
 				clen = 1;
 				wch = (unsigned char)*p;
-			} else if ((clen = mbrtowc(&wch, p, len, &mbs)) ==
+			} else if ((clen = mbrtowc(&wch, (char *)p, len, &mbs)) ==
 			    (size_t)-1) {
 				if (!warned) {
 					errno = EILSEQ;
--- src.orig/coreutils/who/who.c
+++ src.freebsd/coreutils/who/who.c
@@ -45,7 +45,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
-#include <timeconv.h>
 #include <unistd.h>
 #include <utmpx.h>
 
@@ -118,7 +117,7 @@
 		usage();
 
 	if (*argv != NULL) {
-		if (setutxdb(UTXDB_ACTIVE, *argv) != 0)
+		if (utmpxname(*argv) == 0)
 			err(1, "%s", *argv);
 	}
 
@@ -171,8 +170,10 @@
 	struct tm *tm;
 	char state;
 
-	if (d_first < 0)
-		d_first = (*nl_langinfo(D_MD_ORDER) == 'd');
+	if (d_first < 0) {
+		char *s = nl_langinfo(D_FMT);
+		d_first = (strchr(s, 'd') < strchr(s, 'm'));
+	}
 
 	state = '?';
 	idle = 0;
@@ -288,7 +289,7 @@
 	else
 		name = "?";
 	strlcpy(ut.ut_user, name, sizeof ut.ut_user);
-	gettimeofday(&ut.ut_tv, NULL);
+	gettimeofday((struct timeval *)&ut.ut_tv, NULL);
 	row(&ut);
 }
 
--- src.orig/coreutils/xinstall/install.1
+++ src.freebsd/coreutils/xinstall/install.1
@@ -39,7 +39,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -53,7 +52,6 @@
 .Op Fl bCcpSsUv
 .Op Fl B Ar suffix
 .Op Fl D Ar destdir
-.Op Fl f Ar flags
 .Op Fl g Ar group
 .Op Fl h Ar hash
 .Op Fl l Ar linkflags
@@ -116,7 +114,7 @@
 Copy the file.
 If the target file already exists and the files are the same,
 then do not change the modification time of the target.
-If the target's file flags and mode need not to be changed,
+If the target's mode needs not to be changed,
 the target's inode change time is also unchanged.
 .It Fl c
 Copy the file.
@@ -138,10 +136,6 @@
 .It Fl d
 Create directories.
 Missing parent directories are created as required.
-.It Fl f Ar flags
-Specify the target's file flags; see
-.Xr chflags 1
-for a list of possible flags and their meanings.
 .It Fl g Ar group
 Specify a group.
 A numeric GID is allowed.
@@ -198,7 +192,7 @@
 .Dq full path
 specification line.
 The metadata includes: the file name and file type, and depending upon
-other options, the owner, group, file flags, modification time, and tags.
+other options, the owner, group, modification time, and tags.
 .It Fl m Ar mode
 Specify an alternate mode.
 The default mode is set to rwxr-xr-x (0755).
@@ -256,7 +250,7 @@
 .Fl M Ar metalog .
 .It Fl U
 Indicate that install is running unprivileged, and that it should not
-try to change the owner, the group, or the file flags of the destination.
+try to change the owner or the group of the destination.
 The information that would have been updated can be stored in a log
 file with
 .Fl M Ar metalog .
@@ -267,12 +261,6 @@
 showing files as they are installed or backed up.
 .El
 .Pp
-By default,
-.Nm
-preserves all file flags, with the exception of the
-.Dq nodump
-flag.
-.Pp
 The
 .Nm
 utility attempts to prevent moving a file onto itself.
@@ -328,7 +316,6 @@
 The default was changed to copy in
 .Fx 4.4 .
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chgrp 1 ,
 .Xr chmod 1 ,
 .Xr cp 1 ,
@@ -358,15 +345,6 @@
 .Nm
 exits abnormally.
 .Pp
-File flags cannot be set by
-.Xr fchflags 2
-over a NFS file system.
-Other file systems do not have a concept of flags.
-The
-.Nm
-utility will only warn when flags could not be set on a file system
-that does not support them.
-.Pp
 The
 .Nm
 utility with
--- src.orig/coreutils/xinstall/xinstall.c
+++ src.freebsd/coreutils/xinstall/xinstall.c
@@ -73,8 +73,6 @@
 #include <unistd.h>
 #include <vis.h>
 
-#include "mtree.h"
-
 /*
  * We need to build xinstall during the bootstrap stage when building on a
  * non-FreeBSD system. Linux does not have the st_flags and st_birthtime
@@ -165,7 +163,7 @@
 	fset = 0;
 	iflags = 0;
 	group = owner = NULL;
-	while ((ch = getopt(argc, argv, "B:bCcD:df:g:h:l:M:m:N:o:pSsT:Uv")) !=
+	while ((ch = getopt(argc, argv, "B:bCcD:dg:h:l:M:m:o:pSsT:Uv")) !=
 	     -1)
 		switch((char)ch) {
 		case 'B':
@@ -186,10 +184,12 @@
 		case 'd':
 			dodir = 1;
 			break;
+#if 0
 		case 'f':
 			haveopt_f = 1;
 			fflags = optarg;
 			break;
+#endif
 		case 'g':
 			haveopt_g = 1;
 			group = optarg;
@@ -236,11 +236,13 @@
 			mode = getmode(set, 0);
 			free(set);
 			break;
+#if 0
 		case 'N':
 			if (!setup_getid(optarg))
 				err(EX_OSERR, "Unable to use user and group "
 				    "databases in `%s'", optarg);
 			break;
+#endif
 		case 'o':
 			haveopt_o = 1;
 			owner = optarg;
@@ -310,30 +312,38 @@
 
 	/* get group and owner id's */
 	if (group != NULL && !dounpriv) {
-		if (gid_from_group(group, &gid) == -1) {
+		struct group *gr = getgrnam(group);
+		if (!gr) {
 			id_t id;
 			if (!parseid(group, &id))
 				errx(1, "unknown group %s", group);
 			gid = id;
+		} else {
+			gid = gr->gr_gid;
 		}
 	} else
 		gid = (gid_t)-1;
 
 	if (owner != NULL && !dounpriv) {
-		if (uid_from_user(owner, &uid) == -1) {
+		struct passwd *pw = getpwnam(owner);
+		if (!pw) {
 			id_t id;
 			if (!parseid(owner, &id))
 				errx(1, "unknown user %s", owner);
 			uid = id;
+		} else {
+			uid = pw->pw_uid;
 		}
 	} else
 		uid = (uid_t)-1;
 
+#if 0
 	if (fflags != NULL && !dounpriv) {
 		if (strtofflags(&fflags, &fset, NULL))
 			errx(EX_USAGE, "%s: invalid flag", fflags);
 		iflags |= SETFLAGS;
 	}
+#endif
 
 	if (metafile != NULL) {
 		if ((metafp = fopen(metafile, "a")) == NULL)
@@ -384,8 +394,7 @@
 		if (stat(*argv, &from_sb))
 			err(EX_OSERR, "%s", *argv);
 		if (!S_ISREG(to_sb.st_mode)) {
-			errno = EFTYPE;
-			err(EX_OSERR, "%s", to_name);
+			errx(EX_OSERR, "%s: not a regular file", to_name);
 		}
 		if (to_sb.st_dev == from_sb.st_dev &&
 		    to_sb.st_ino == from_sb.st_ino)
@@ -529,7 +538,7 @@
 do_link(const char *from_name, const char *to_name,
     const struct stat *target_sb)
 {
-	char tmpl[MAXPATHLEN];
+	char tmpl[MAXPATHLEN + 12];
 	int ret;
 
 	if (safecopy && target_sb != NULL) {
@@ -714,7 +723,6 @@
 				errx(1, "resolved pathname too long");
 		}
 		strcpy(to_name_copy, to_name);
-		cp = basename(to_name_copy);
 		if (strlcat(dst, cp, sizeof(dst)) > sizeof(dst))
 			errx(1, "resolved pathname too long");
 		free(to_name_copy);
@@ -763,7 +771,7 @@
  *	build a path name and install the file
  */
 static void
-install(const char *from_name, const char *to_name, u_long fset, u_int flags)
+install(const char *from_name, const char *to_name, u_long fset __unused, u_int flags)
 {
 	struct stat from_sb, temp_sb, to_sb;
 	struct timespec tsb[2];
@@ -783,8 +791,7 @@
 			if (stat(from_name, &from_sb))
 				err(EX_OSERR, "%s", from_name);
 			if (!S_ISREG(from_sb.st_mode)) {
-				errno = EFTYPE;
-				err(EX_OSERR, "%s", from_name);
+				errx(EX_OSERR, "%s: not a regular file", from_name);
 			}
 		}
 		/* Build the target path. */
@@ -818,8 +825,7 @@
 	}
 
 	if (target && !S_ISREG(to_sb.st_mode) && !S_ISLNK(to_sb.st_mode)) {
-		errno = EFTYPE;
-		warn("%s", to_name);
+		warnx("%s: not a regular file or a symlink", to_name);
 		return;
 	}
 
@@ -1134,13 +1140,13 @@
 			lseek(to_fd, 0, SEEK_SET);
 		}
 	} else
-		rv = 1;	/* don't bother in this case */
+		return 1;	/* don't bother in this case */
 
 	if (do_digest) {
 		if (rv == 0)
 			*dresp = digest_end(&ctx, NULL);
 		else
-			(void)digest_end(&ctx, NULL);
+			free(digest_end(&ctx, NULL));
 	}
 
 	return rv;
@@ -1171,7 +1177,7 @@
  *	create a new file, overwriting an existing one if necessary
  */
 static int
-create_newfile(const char *path, int target, struct stat *sbp)
+create_newfile(const char *path, int target, struct stat *sbp __unused)
 {
 	char backup[MAXPATHLEN];
 	int saved_errno = 0;
@@ -1336,7 +1342,7 @@
 	    __DECONST(char **, args), environ);
 	if (error != 0) {
 		(void)unlink(to_name);
-		errc(error == EAGAIN || error == EPROCLIM || error == ENOMEM ?
+		errc(error == EAGAIN || error == ENOMEM ?
 		    EX_TEMPFAIL : EX_OSERR, error, "spawn %s", stripbin);
 	}
 	if (waitpid(pid, &status, 0) == -1) {
--- src.orig/diffutils/cmp/cmp.c
+++ src.freebsd/diffutils/cmp/cmp.c
@@ -78,7 +78,7 @@
 static void usage(void);
 
 static bool
-parse_iskipspec(char *spec, off_t *skip1, off_t *skip2)
+parse_iskipspec(char *spec, uint64_t *skip1, uint64_t *skip2)
 {
 	char *colon;
 
@@ -100,7 +100,7 @@
 main(int argc, char *argv[])
 {
 	struct stat sb1, sb2;
-	off_t skip1, skip2, limit;
+	uint64_t skip1, skip2, limit;
 	int ch, fd1, fd2, oflag;
 	bool special;
 	const char *file1, *file2;
@@ -127,7 +127,7 @@
 			lflag = true;
 			break;
 		case 'n':		/* Limit */
-			if (expand_number(optarg, &limit) < 0 || limit < 0) {
+			if (expand_number(optarg, &limit) < 0) {
 				fprintf(stderr, "Invalid --bytes: %s\n",
 				    optarg);
 				usage();
--- src.orig/diffutils/cmp/extern.h
+++ src.freebsd/diffutils/cmp/extern.h
@@ -34,6 +34,8 @@
  *
  */
 
+#include <stdbool.h>
+
 #define OK_EXIT		0
 #define DIFF_EXIT	1
 #define ERR_EXIT	2	/* error exit code */
--- src.orig/diffutils/cmp/regular.c
+++ src.freebsd/diffutils/cmp/regular.c
@@ -41,6 +41,7 @@
 #include <sys/param.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <err.h>
--- src.orig/diffutils/diff/diff.1
+++ src.freebsd/diffutils/diff/diff.1
@@ -82,7 +82,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -107,7 +106,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -133,7 +131,6 @@
 .Op Fl -minimal
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -show-c-function
 .Op Fl -speed-large-files
@@ -163,7 +160,6 @@
 .Op Fl -new-file
 .Op Fl -no-ignore-file-name-case
 .Op Fl -normal
-.Op Fl -paginate
 .Op Fl -rcs
 .Op Fl -recursive
 .Op Fl -report-identical-files
@@ -354,10 +350,6 @@
 .Dq A
 will compare equal to
 .Dq a .
-.It Fl l -paginate
-Pass the output through
-.Xr pr 1
-to paginate it.
 .It Fl L Ar label Fl -label Ar label
 Print
 .Ar label
--- src.orig/diffutils/diff/diff.c
+++ src.freebsd/diffutils/diff/diff.c
@@ -38,7 +38,7 @@
 #include "diff.h"
 #include "xmalloc.h"
 
-int	 lflag, Nflag, Pflag, rflag, sflag, Tflag, cflag, Wflag;
+int	 Nflag, Pflag, rflag, sflag, Tflag, cflag, Wflag;
 int	 diff_format, diff_context, status, ignore_file_case, suppress_common;
 int	 tabsize = 8, width = 130;
 char	*start, *ifdefname, *diffargs, *label[2], *ignore_pats;
@@ -47,7 +47,7 @@
 struct excludes *excludes_list;
 regex_t	 ignore_re;
 
-#define	OPTIONS	"0123456789aBbC:cdD:efHhI:iL:lnNPpqrS:sTtU:uwW:X:x:y"
+#define	OPTIONS	"0123456789aBbC:cdD:efHhI:iL:nNPpqrS:sTtU:uwW:X:x:y"
 enum {
 	OPT_TSIZE = CHAR_MAX + 1,
 	OPT_STRIPCR,
@@ -71,7 +71,6 @@
 	{ "ignore-blank-lines",		no_argument,		0,	'B' },
 	{ "ignore-matching-lines",	required_argument,	0,	'I' },
 	{ "ignore-case",		no_argument,		0,	'i' },
-	{ "paginate",			no_argument,		NULL,	'l' },
 	{ "label",			required_argument,	0,	'L' },
 	{ "new-file",			no_argument,		0,	'N' },
 	{ "rcs",			no_argument,		0,	'n' },
@@ -198,9 +197,6 @@
 			else
 				usage();
 			break;
-		case 'l':
-			lflag = 1;
-			break;
 		case 'N':
 			Nflag = 1;
 			break;
@@ -379,12 +375,12 @@
 		diffdir(argv[0], argv[1], dflags);
 	} else {
 		if (S_ISDIR(stb1.st_mode)) {
-			argv[0] = splice(argv[0], argv[1]);
+			argv[0] = dsplice(argv[0], argv[1]);
 			if (stat(argv[0], &stb1) == -1)
 				err(2, "%s", argv[0]);
 		}
 		if (S_ISDIR(stb2.st_mode)) {
-			argv[1] = splice(argv[1], argv[0]);
+			argv[1] = dsplice(argv[1], argv[0]);
 			if (stat(argv[1], &stb2) == -1)
 				err(2, "%s", argv[1]);
 		}
@@ -418,20 +414,23 @@
 read_excludes_file(char *file)
 {
 	FILE *fp;
-	char *buf, *pattern;
-	size_t len;
+	char *pattern = NULL;
+	size_t blen = 0;
+	ssize_t len;
 
 	if (strcmp(file, "-") == 0)
 		fp = stdin;
 	else if ((fp = fopen(file, "r")) == NULL)
 		err(2, "%s", file);
-	while ((buf = fgetln(fp, &len)) != NULL) {
-		if (buf[len - 1] == '\n')
-			len--;
-		if ((pattern = strndup(buf, len)) == NULL)
-			err(2, "xstrndup");
+	while ((len = getline(&pattern, &blen, fp)) >= 0) {
+		if ((len > 0) && (pattern[len - 1] == '\n'))
+			pattern[len - 1] = '\0';
 		push_excludes(pattern);
+		/* we allocate a new string per line */
+		pattern = NULL;
+		blen = 0;
 	}
+	free(pattern);
 	if (strcmp(file, "-") != 0)
 		fclose(fp);
 }
--- src.orig/diffutils/diff/diff.h
+++ src.freebsd/diffutils/diff/diff.h
@@ -100,8 +100,16 @@
 extern struct	excludes *excludes_list;
 extern regex_t	ignore_re;
 
-char	*splice(char *, char *);
+char	*dsplice(char *, char *);
 int	diffreg(char *, char *, int, int);
 void	diffdir(char *, char *, int);
 void	print_only(const char *, size_t, const char *);
 void	print_status(int, char *, char *, const char *);
+
+#ifndef MIN
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
+#endif
--- src.orig/diffutils/diff/diffreg.c
+++ src.freebsd/diffutils/diff/diffreg.c
@@ -85,8 +85,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <time.h>
 
-#include "pr.h"
 #include "diff.h"
 #include "xmalloc.h"
 
@@ -259,7 +261,6 @@
 {
 	FILE *f1, *f2;
 	int i, rval;
-	struct pr *pr = NULL;
 	cap_rights_t rights_ro;
 
 	f1 = f2 = NULL;
@@ -339,9 +340,6 @@
 		goto closem;
 	}
 
-	if (lflag)
-		pr = start_pr(file1, file2);
-
 	if (capsicum) {
 		cap_rights_init(&rights_ro, CAP_READ, CAP_FSTAT, CAP_SEEK);
 		if (caph_rights_limit(fileno(f1), &rights_ro) < 0)
@@ -424,8 +422,6 @@
 	output(file1, f1, file2, f2, flags);
 
 closem:
-	if (pr != NULL)
-		stop_pr(pr);
 	if (anychange) {
 		status |= 1;
 		if (rval == D_SAME)
@@ -499,7 +495,7 @@
 }
 
 char *
-splice(char *dir, char *path)
+dsplice(char *dir, char *path)
 {
 	char *tail, *buf;
 	size_t dirlen;
@@ -1035,7 +1031,6 @@
 	int ret;
 
 	ret = regexec(&ignore_re, line, 0, NULL, 0);
-	free(line);
 	return (ret == 0);	/* if it matched, it should be ignored. */
 }
 
@@ -1043,13 +1038,10 @@
 ignoreline(char *line, bool skip_blanks)
 {
 
-	if (ignore_pats != NULL && skip_blanks)
-		return (ignoreline_pattern(line) || *line == '\0');
-	if (ignore_pats != NULL)
-		return (ignoreline_pattern(line));
-	if (skip_blanks)
-		return (*line == '\0');
-	/* No ignore criteria specified */
+	if (skip_blanks && *line == '\0')
+		return (true);
+	if (ignore_pats != NULL && ignoreline_pattern(line))
+		return (true);
 	return (false);
 }
 
@@ -1068,7 +1060,7 @@
 	long curpos;
 	int i, nc;
 	const char *walk;
-	bool skip_blanks;
+	bool skip_blanks, ignore;
 
 	skip_blanks = (*pflags & D_SKIPBLANKLINES);
 restart:
@@ -1086,7 +1078,9 @@
 			for (i = a; i <= b; i++) {
 				line = preadline(fileno(f1),
 				    ixold[i] - ixold[i - 1], ixold[i - 1]);
-				if (!ignoreline(line, skip_blanks))
+				ignore = ignoreline(line, skip_blanks);
+				free(line);
+				if (!ignore)
 					goto proceed;
 			}
 		}
@@ -1094,7 +1088,9 @@
 			for (i = c; i <= d; i++) {
 				line = preadline(fileno(f2),
 				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
-				if (!ignoreline(line, skip_blanks))
+				ignore = ignoreline(line, skip_blanks);
+				free(line);
+				if (!ignore)
 					goto proceed;
 			}
 		}
@@ -1376,6 +1372,7 @@
 		case '\0':
 			if ((flags & D_FORCEASCII) == 0)
 				return (RH_BINARY);
+			/* FALLTHROUGH */
 		case '\r':
 			if (flags & D_STRIPCR) {
 				t = getc(f);
@@ -1433,7 +1430,7 @@
 static char *
 match_function(const long *f, int pos, FILE *fp)
 {
-	unsigned char buf[FUNCTION_CONTEXT_SIZE];
+	char buf[FUNCTION_CONTEXT_SIZE];
 	size_t nc;
 	int last = lastline;
 	const char *state = NULL;
@@ -1652,41 +1649,18 @@
 static void
 print_header(const char *file1, const char *file2)
 {
-	const char *time_format;
-	char buf1[256];
-	char buf2[256];
-	char end1[10];
-	char end2[10];
-	struct tm tm1, tm2, *tm_ptr1, *tm_ptr2;
-	int nsec1 = stb1.st_mtim.tv_nsec;
-	int nsec2 = stb2.st_mtim.tv_nsec;
-
-	time_format = "%Y-%m-%d %H:%M:%S";
-
-	if (cflag)
-		time_format = "%c";
-	tm_ptr1 = localtime_r(&stb1.st_mtime, &tm1);
-	tm_ptr2 = localtime_r(&stb2.st_mtime, &tm2);
-	strftime(buf1, 256, time_format, tm_ptr1);
-	strftime(buf2, 256, time_format, tm_ptr2);
-	if (!cflag) {
-		strftime(end1, 10, "%z", tm_ptr1);
-		strftime(end2, 10, "%z", tm_ptr2);
-		sprintf(buf1, "%s.%.9d %s", buf1, nsec1, end1);
-		sprintf(buf2, "%s.%.9d %s", buf2, nsec2, end2);
-	}
 	if (label[0] != NULL)
 		printf("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
 		    label[0]);
 	else
-		printf("%s %s\t%s\n", diff_format == D_CONTEXT ? "***" : "---",
-		    file1, buf1);
+		printf("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
+		    file1, ctime(&stb1.st_mtime));
 	if (label[1] != NULL)
 		printf("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
 		    label[1]);
 	else
-		printf("%s %s\t%s\n", diff_format == D_CONTEXT ? "---" : "+++",
-		    file2, buf2);
+		printf("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
+		    file2, ctime(&stb2.st_mtime));
 }
 
 /*
--- src.orig/diffutils/sdiff/sdiff.c
+++ src.freebsd/diffutils/sdiff/sdiff.c
@@ -260,16 +260,19 @@
 		case 'E':
 		case 'i':
 		case 't':
-		case 'W':
-			diffargv[1]  = realloc(diffargv[1], sizeof(char) * strlen(diffargv[1]) + 2);
+		case 'W': {
+			int alen = strlen(diffargv[1]);
+			diffargv[1] = realloc(diffargv[1], sizeof(char) * alen + 2);
 			/*
 			 * In diff, the 'W' option is 'w' and the 'w' is 'W'.
 			 */
 			if (ch == 'W')
-				sprintf(diffargv[1], "%sw", diffargv[1]);
+				diffargv[1][alen] = 'w';
 			else
-				sprintf(diffargv[1], "%s%c", diffargv[1], ch);
+				diffargv[1][alen] = ch;
+			diffargv[1][alen + 1] = '\0';
 			break;
+		}
 		case 'H':
 			diffargv[diffargc++] = speed_lf;
 			break;
--- src.orig/ed/main.c
+++ src.freebsd/ed/main.c
@@ -212,6 +212,7 @@
 		switch (status) {
 		case EOF:
 			quit(0);
+			break; /* unreachable */
 		case EMOD:
 			modified = 0;
 			fputs("?\n", stderr);		/* give warning */
@@ -231,6 +232,7 @@
 			} else if (garrulous)
 				fprintf(stderr, "%s\n", errmsg);
 			quit(3);
+			break; /* unreachable */
 		default:
 			fputs("?\n", stderr);
 			if (!isatty(0)) {
--- src.orig/findutils/find/extern.h
+++ src.freebsd/findutils/find/extern.h
@@ -33,6 +33,7 @@
  */
 
 #include <sys/cdefs.h>
+#include <sys/types.h>
 
 void	 brace_subst(char *, char **, char *, size_t);
 PLAN	*find_create(char ***);
@@ -47,6 +48,7 @@
 int	 queryuser(char **);
 OPTION	*lookup_option(const char *);
 void	 finish_execplus(void);
+const char *f_fstypename(dev_t);
 
 creat_f	c_Xmin;
 creat_f	c_Xtime;
--- src.orig/findutils/find/find.1
+++ src.freebsd/findutils/find/find.1
@@ -181,35 +181,6 @@
 and neither means
 .Dq exactly n .
 .Bl -tag -width indent
-.It Ic -Bmin Ar n
-True if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full minute, is
-.Ar n
-minutes.
-.It Ic -Bnewer Ar file
-Same as
-.Ic -newerBm .
-.It Ic -Btime Ar n Ns Op Cm smhdw
-If no units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started, rounded up to the next full 24-hour period, is
-.Ar n
-24-hour periods.
-.Pp
-If units are specified, this primary evaluates to
-true if the difference between the time of a file's inode creation
-and the time
-.Nm
-was started is exactly
-.Ar n
-units.
-Please refer to the
-.Ic -atime
-primary description for information on supported time units.
 .It Ic -acl
 May be used in conjunction with other primaries to locate
 files with extended ACLs.
@@ -431,50 +402,6 @@
 returns a non-zero exit status,
 .Nm
 will return a non-zero exit status.
-.It Ic -flags Oo Cm - Ns | Ns Cm + Oc Ns Ar flags , Ns Ar notflags
-The flags are specified using symbolic names (see
-.Xr chflags 1 ) .
-Those with the
-.Qq Li no
-prefix (except
-.Qq Li nodump )
-are said to be
-.Ar notflags .
-Flags in
-.Ar flags
-are checked to be set, and flags in
-.Ar notflags
-are checked to be not set.
-Note that this is different from
-.Ic -perm ,
-which only allows the user to specify mode bits that are set.
-.Pp
-If flags are preceded by a dash
-.Pq Dq Li - ,
-this primary evaluates to true
-if at least all of the bits in
-.Ar flags
-and none of the bits in
-.Ar notflags
-are set in the file's flags bits.
-If flags are preceded by a plus
-.Pq Dq Li + ,
-this primary evaluates to true
-if any of the bits in
-.Ar flags
-is set in the file's flags bits,
-or any of the bits in
-.Ar notflags
-is not set in the file's flags bits.
-Otherwise,
-this primary evaluates to true
-if the bits in
-.Ar flags
-exactly match the file's flags bits,
-and none of the
-.Ar flags
-bits match those of
-.Ar notflags .
 .It Ic -fstype Ar type
 True if the file is contained in a file system of type
 .Ar type .
@@ -482,15 +409,9 @@
 .Xr lsvfs 1
 command can be used to find out the types of file systems
 that are available on the system.
-In addition, there are two pseudo-types,
-.Dq Li local
-and
-.Dq Li rdonly .
-The former matches any file system physically mounted on the system where
-the
-.Nm
-is being executed and the latter matches any file system which is
-mounted read-only.
+In addition, there is a pseudotype
+.Dq Li rdonly
+that matches any file system which is mounted read-only.
 .It Ic -gid Ar gname
 The same thing as
 .Ic -group Ar gname
@@ -998,7 +919,6 @@
 .Sx STANDARDS
 section below for details.
 .Sh SEE ALSO
-.Xr chflags 1 ,
 .Xr chmod 1 ,
 .Xr locate 1 ,
 .Xr lsvfs 1 ,
@@ -1028,9 +948,7 @@
 .Ic -amin , -anewer , -cmin , -cnewer , -delete , -empty , -fstype ,
 .Ic -iname , -inum , -iregex , -ls , -maxdepth , -mindepth , -mmin ,
 .Ic -not , -path , -print0 , -regex , -sparse
-and all of the
-.Fl B*
-birthtime related primaries are extensions to
+are extensions to
 .St -p1003.1-2001 .
 .Pp
 Historically, the
--- src.orig/findutils/find/find.c
+++ src.freebsd/findutils/find/find.c
@@ -52,7 +52,7 @@
 
 #include "find.h"
 
-static int find_compare(const FTSENT * const *s1, const FTSENT * const *s2);
+static int find_compare(const FTSENT **s1, const FTSENT **s2);
 
 /*
  * find_compare --
@@ -61,7 +61,7 @@
  *	order within each directory.
  */
 static int
-find_compare(const FTSENT * const *s1, const FTSENT * const *s2)
+find_compare(const FTSENT **s1, const FTSENT **s2)
 {
 
 	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
@@ -237,5 +237,6 @@
 	finish_execplus();
 	if (e && (!ignore_readdir_race || e != ENOENT))
 		errc(1, e, "fts_read");
+	f_fstypename(0); /* free allocated filesystem type resources */
 	return (exitstatus);
 }
--- src.orig/findutils/find/find.h
+++ src.freebsd/findutils/find/find.h
@@ -56,11 +56,7 @@
 #else
 #define HAVE_STRUCT_STAT_ST_BIRTHTIME 0
 #endif
-#if defined(MFSNAMELEN) || defined(MFSTYPENAMELEN)
 #define HAVE_STRUCT_STATFS_F_FSTYPENAME 1
-#else
-#define HAVE_STRUCT_STATFS_F_FSTYPENAME 0
-#endif
 
 /* forward declarations */
 struct _plandata;
--- src.orig/findutils/find/function.c
+++ src.freebsd/findutils/find/function.c
@@ -40,12 +40,12 @@
 __FBSDID("$FreeBSD$");
 
 #include <sys/param.h>
-#include <sys/ucred.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/acl.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
+#include <sys/statvfs.h>
 
 #include <dirent.h>
 #include <err.h>
@@ -64,6 +64,10 @@
 
 #include "find.h"
 
+#ifndef REG_STARTEND
+#define REG_STARTEND 0
+#endif
+
 static PLAN *palloc(OPTION *);
 static long long find_parsenum(PLAN *, const char *, char *, char *);
 static long long find_parsetime(PLAN *, const char *, char *);
@@ -874,6 +878,64 @@
 }
 
 #if HAVE_STRUCT_STATFS_F_FSTYPENAME
+struct mntinfo {
+    dev_t devn;
+    char fstype[64];
+};
+
+const char *
+f_fstypename(dev_t curdev)
+{
+	static struct mntinfo *minfo = NULL;
+	static size_t ninfos = 0;
+	char curfstype[64];
+	/* to be freed */
+	if (!curdev) {
+		free(minfo);
+		minfo = NULL;
+		ninfos = 0;
+		return NULL;
+	}
+	if (!minfo) {
+		FILE *f = fopen("/proc/self/mountinfo", "rb");
+		if (!f)
+			return NULL;
+		char *lbuf = NULL;
+		size_t lsize = 0, ncap = 64;
+		minfo = malloc(ncap * sizeof(struct mntinfo));
+		if (!minfo)
+			err(1, "malloc");
+		const char *rfs = NULL;
+		while (getline(&lbuf, &lsize, f) > 0) {
+			unsigned int maj, min;
+			if (sscanf(
+			    lbuf, "%*d %*d %u:%u %*s %*s %*s %*s - %63s %*s %*s",
+			    &maj, &min, curfstype
+			) <= 0)
+				continue;
+			if (ninfos == ncap) {
+				ncap *= 2;
+				minfo = realloc(minfo, ncap * sizeof(struct mntinfo));
+				if (!minfo)
+					err(1, "realloc");
+			}
+			minfo[ninfos].devn = makedev(maj, min);
+			memcpy(minfo[ninfos].fstype, curfstype, sizeof(curfstype));
+			if (minfo[ninfos].devn == curdev)
+				rfs = minfo[ninfos].fstype;
+			++ninfos;
+		}
+		free(lbuf);
+		fclose(f);
+		return rfs;
+	}
+	for (size_t i = 0; i < ninfos; ++i) {
+		if (minfo[i].devn == curdev)
+			return minfo[i].fstype;
+	}
+	return NULL;
+}
+
 /*
  * -fstype functions --
  *
@@ -884,9 +946,9 @@
 {
 	static dev_t curdev;	/* need a guaranteed illegal dev value */
 	static int first = 1;
-	struct statfs sb;
-	static int val_flags;
-	static char fstype[sizeof(sb.f_fstypename)];
+	struct statvfs sb;
+	static unsigned long val_flags;
+	static const char *fstype;
 	char *p, save[2] = {0,0};
 
 	if ((plan->flags & F_MTMASK) == F_MTUNKNOWN)
@@ -897,7 +959,7 @@
 		curdev = entry->fts_statp->st_dev;
 
 		/*
-		 * Statfs follows symlinks; find wants the link's filesystem,
+		 * Statvfs follows symlinks; find wants the link's filesystem,
 		 * not where it points.
 		 */
 		if (entry->fts_info == FTS_SL ||
@@ -913,7 +975,7 @@
 		} else
 			p = NULL;
 
-		if (statfs(entry->fts_accpath, &sb)) {
+		if (statvfs(entry->fts_accpath, &sb)) {
 			if (!ignore_readdir_race || errno != ENOENT) {
 				warn("statfs: %s", entry->fts_accpath);
 				exitstatus = 1;
@@ -932,14 +994,14 @@
 		 * Further tests may need both of these values, so
 		 * always copy both of them.
 		 */
-		val_flags = sb.f_flags;
-		strlcpy(fstype, sb.f_fstypename, sizeof(fstype));
+		val_flags = sb.f_flag;
+		fstype = f_fstypename(curdev);
 	}
 	switch (plan->flags & F_MTMASK) {
 	case F_MTFLAG:
 		return val_flags & plan->mt_data;
 	case F_MTTYPE:
-		return (strncmp(fstype, plan->c_data, sizeof(fstype)) == 0);
+		return fstype && (strcmp(fstype, plan->c_data) == 0);
 	default:
 		abort();
 	}
@@ -956,17 +1018,10 @@
 
 	new = palloc(option);
 	switch (*fsname) {
-	case 'l':
-		if (!strcmp(fsname, "local")) {
-			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_LOCAL;
-			return new;
-		}
-		break;
 	case 'r':
 		if (!strcmp(fsname, "rdonly")) {
 			new->flags |= F_MTFLAG;
-			new->mt_data = MNT_RDONLY;
+			new->mt_data = ST_RDONLY;
 			return new;
 		}
 		break;
@@ -1261,7 +1316,9 @@
 int
 f_nogroup(PLAN *plan __unused, FTSENT *entry)
 {
-	return group_from_gid(entry->fts_statp->st_gid, 1) == NULL;
+	struct group *gr;
+	gr = getgrgid(entry->fts_statp->st_gid);
+	return gr == NULL;
 }
 
 PLAN *
@@ -1281,7 +1338,9 @@
 int
 f_nouser(PLAN *plan __unused, FTSENT *entry)
 {
-	return user_from_uid(entry->fts_statp->st_uid, 1) == NULL;
+	struct passwd *pw;
+	pw = getpwuid(entry->fts_statp->st_uid);
+	return pw == NULL;
 }
 
 PLAN *
--- src.orig/findutils/find/ls.c
+++ src.freebsd/findutils/find/ls.c
@@ -38,6 +38,7 @@
 
 #include <sys/param.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <err.h>
 #include <errno.h>
@@ -62,13 +63,29 @@
 printlong(char *name, char *accpath, struct stat *sb)
 {
 	char modep[15];
+	struct passwd *pw = NULL;
+	struct group *gr = NULL;
+	char *uname = NULL;
+	char *gname = NULL;
+
+	pw = getpwuid(sb->st_uid);
+	if (pw == NULL)
+		uname = "root";
+	else
+		uname = pw->pw_name;
+
+	gr = getgrgid(sb->st_gid);
+	if (gr == NULL)
+		gname = "root";
+	else
+		gname = gr->gr_name;
 
 	(void)printf("%6ju %8"PRId64" ", (uintmax_t)sb->st_ino, sb->st_blocks);
 	(void)strmode(sb->st_mode, modep);
 	(void)printf("%s %3ju %-*s %-*s ", modep, (uintmax_t)sb->st_nlink,
 	    MAXLOGNAME - 1,
-	    user_from_uid(sb->st_uid, 0), MAXLOGNAME - 1,
-	    group_from_gid(sb->st_gid, 0));
+	    uname, MAXLOGNAME - 1,
+	    gname);
 
 	if (S_ISCHR(sb->st_mode) || S_ISBLK(sb->st_mode))
 		(void)printf("%#8jx ", (uintmax_t)sb->st_rdev);
--- src.orig/findutils/find/main.c
+++ src.freebsd/findutils/find/main.c
@@ -32,9 +32,11 @@
  * SUCH DAMAGE.
  */
 
+#if 0
 static const char copyright[] =
 "@(#) Copyright (c) 1990, 1993, 1994\n\
 	The Regents of the University of California.  All rights reserved.\n";
+#endif
 
 #if 0
 static char sccsid[] = "@(#)main.c	8.4 (Berkeley) 5/4/95";
--- src.orig/findutils/find/misc.c
+++ src.freebsd/findutils/find/misc.c
@@ -51,6 +51,10 @@
 
 #include "find.h"
 
+#if defined(__linux__) && !defined(__GLIBC__)
+#include <rpmatch.h>
+#endif
+
 /*
  * brace_subst --
  *	Replace occurrences of {} in s1 with s2 and return the result string.
--- src.orig/findutils/xargs/strnsubst.c
+++ src.freebsd/findutils/xargs/strnsubst.c
@@ -15,6 +15,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdint.h>
 
 void	strnsubst(char **, const char *, const char *, size_t);
 
--- src.orig/findutils/xargs/xargs.c
+++ src.freebsd/findutils/xargs/xargs.c
@@ -51,8 +51,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/time.h>
-#include <sys/limits.h>
 #include <sys/resource.h>
+#include <limits.h>
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -92,7 +92,7 @@
 static const char *eofstr;
 static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
 static int cnt, Iflag, jfound, Lflag, Sflag, wasquoted, xflag;
-static int curprocs, maxprocs;
+static long unsigned int curprocs, maxprocs;
 static pid_t *childpids;
 
 static volatile int childerr;
@@ -597,6 +597,7 @@
 	case -1:
 		warn("vfork");
 		xexit(*argv, 1);
+		break;
 	case 0:
 		if (oflag) {
 			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1)
@@ -691,7 +692,7 @@
 static void
 pids_init(void)
 {
-	int i;
+	long unsigned int i;
 
 	if ((childpids = malloc(maxprocs * sizeof(*childpids))) == NULL)
 		errx(1, "malloc failed");
@@ -750,7 +751,7 @@
 static int
 findslot(pid_t pid)
 {
-	int slot;
+	long unsigned int slot;
 
 	for (slot = 0; slot < maxprocs; slot++)
 		if (childpids[slot] == pid)
@@ -772,22 +773,22 @@
 prompt(void)
 {
 	regex_t cre;
-	size_t rsize;
+	size_t rsize = 0;
 	int match;
-	char *response;
+	char *response = NULL;
 	FILE *ttyfp;
 
 	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
 		return (2);	/* Indicate that the TTY failed to open. */
 	(void)fprintf(stderr, "?...");
 	(void)fflush(stderr);
-	if ((response = fgetln(ttyfp, &rsize)) == NULL ||
+	if (getline(&response, &rsize, ttyfp) < 0 ||
 	    regcomp(&cre, nl_langinfo(YESEXPR), REG_EXTENDED) != 0) {
 		(void)fclose(ttyfp);
 		return (0);
 	}
-	response[rsize - 1] = '\0';
 	match = regexec(&cre, response, 0, NULL, 0);
+	free(response);
 	(void)fclose(ttyfp);
 	regfree(&cre);
 	return (match == 0);
--- src.orig/grep/file.c
+++ src.freebsd/grep/file.c
@@ -43,6 +43,7 @@
 #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
@@ -52,6 +53,10 @@
 
 #include "grep.h"
 
+#ifndef OFF_MAX
+#define OFF_MAX ((off_t)(((1ULL << (sizeof(off_t) * CHAR_BIT - 2)) - 1) * 2 + 1))
+#endif
+
 #define	MAXBUFSIZ	(32 * 1024)
 #define	LNBUFBUMP	80
 
@@ -190,7 +195,7 @@
 		    (!S_ISREG(st.st_mode)))
 			filebehave = FILE_STDIO;
 		else {
-			int flags = MAP_PRIVATE | MAP_NOCORE | MAP_NOSYNC;
+			int flags = MAP_PRIVATE;
 #ifdef MAP_PREFAULT_READ
 			flags |= MAP_PREFAULT_READ;
 #endif
--- src.orig/grep/grep.c
+++ src.freebsd/grep/grep.c
@@ -67,7 +67,7 @@
 
 /* Flags passed to regcomp() and regexec() */
 int		 cflags = REG_NOSUB | REG_NEWLINE;
-int		 eflags = REG_STARTEND;
+int		 eflags = 0;
 
 bool		 matchall;
 
--- src.orig/grep/grep.h
+++ src.freebsd/grep/grep.h
@@ -31,12 +31,10 @@
  * SUCH DAMAGE.
  */
 
-#include <bzlib.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdbool.h>
 #include <stdio.h>
-#include <zlib.h>
 
 extern const char		*errstr[];
 
--- src.orig/grep/util.c
+++ src.freebsd/grep/util.c
@@ -469,6 +469,30 @@
 
 #define iswword(x)	(iswalnum((x)) || (x) == L'_')
 
+#ifndef REG_STARTEND
+static int regexec_startend(
+    const regex_t *restrict preg, char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	regoff_t so = pmatch[0].rm_so;
+	regoff_t eo = pmatch[0].rm_eo;
+	char old = str[eo];
+	str[eo] = '\0';
+	int ret = regexec(preg, str + so, nmatch, pmatch, eflags);
+	str[eo] = old;
+	pmatch[0].rm_so += so;
+	pmatch[0].rm_eo += so;
+	return ret;
+}
+#else
+static int regexec_startend(
+    const regex_t *restrict preg, const char *restrict str, size_t nmatch,
+    regmatch_t pmatch[restrict], int eflags
+) {
+	return regexec(preg, str, nmatch, pmatch, eflags | REG_STARTEND);
+}
+#endif
+
 /*
  * Processes a line comparing it with the specified patterns.  Each pattern
  * is looped to be compared along with the full string, saving each and every
@@ -536,7 +560,7 @@
 				r = litexec(&pattern[i], pc->ln.dat, 1, &pmatch);
 			else
 #endif
-			r = regexec(&r_pattern[i], pc->ln.dat, 1, &pmatch,
+			r = regexec_startend(&r_pattern[i], pc->ln.dat, 1, &pmatch,
 			    leflags);
 			if (r != 0)
 				continue;
--- src.orig/gzip/gzip.c
+++ src.freebsd/gzip/gzip.c
@@ -49,13 +49,21 @@
  *	- make bzip2/compress -v/-t/-l support work as well as possible
  */
 
-#include <sys/endian.h>
+static inline unsigned le32dec(const void *s) {
+	const unsigned char *p = (const unsigned char *)s;
+	return (((unsigned)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+#define nitems(x) (sizeof((x)) / sizeof((x)[0]))
+
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <sys/types.h>
 
 #include <inttypes.h>
 #include <unistd.h>
+#include <signal.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -388,7 +396,7 @@
 			break;
 		case 'V':
 			display_version();
-			/* NOTREACHED */
+			break; /* NOTREACHED */
 #ifndef SMALL
 		case 'a':
 			fprintf(stderr, "%s: option --ascii ignored on this system\n", progname);
@@ -401,7 +409,7 @@
 			break;
 		case 'L':
 			display_license();
-			/* NOT REACHED */
+			break; /* NOT REACHED */
 		case 'N':
 			nflag = 0;
 			Nflag = 1;
@@ -1140,9 +1148,11 @@
 	if (futimens(fd, times) < 0)
 		maybe_warn("couldn't futimens: %s", file);
 
+#if 0
 	/* only try flags if they exist already */
         if (sb.st_flags != 0 && fchflags(fd, sb.st_flags) < 0)
 		maybe_warn("couldn't fchflags: %s", file);
+#endif
 }
 #endif
 
--- src.orig/gzip/unxz.c
+++ src.freebsd/gzip/unxz.c
@@ -38,6 +38,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <lzma.h>
+#include <sys/stat.h>
 
 static off_t
 unxz(int i, int o, char *pre, size_t prelen, off_t *bytes_in)
@@ -82,7 +83,7 @@
 			switch (strm.avail_in) {
 			case (size_t)-1:
 				maybe_err("read failed");
-				/*NOTREACHED*/
+				break; /*NOTREACHED*/
 			case 0:
 				action = LZMA_FINISH;
 				break;
--- src.orig/gzip/zuncompress.c
+++ src.freebsd/gzip/zuncompress.c
@@ -40,7 +40,12 @@
 
 /* This file is #included by gzip.c */
 
-static int	zread(void *, char *, int);
+static ssize_t
+zread(void *cookie, char *rbp, size_t num);
+
+#ifndef EFTYPE
+#define EFTYPE EINVAL
+#endif
 
 #define	tab_prefixof(i)	(zs->zs_codetab[i])
 #define	tab_suffixof(i)	((char_type *)(zs->zs_htab))[i]
@@ -174,6 +179,7 @@
 zdopen(int fd)
 {
 	struct s_zstate *zs;
+	cookie_io_functions_t zfuncs;
 
 	if ((zs = calloc(1, sizeof(struct s_zstate))) == NULL)
 		return (NULL);
@@ -201,7 +207,12 @@
 		return NULL;
 	}
 
-	return funopen(zs, zread, NULL, NULL, zclose);
+	zfuncs.read = zread;
+	zfuncs.write = NULL;
+	zfuncs.seek = NULL;
+	zfuncs.close = zclose;
+
+	return fopencookie(zs, "r", zfuncs);
 }
 
 /*
@@ -210,8 +221,8 @@
  * compressed file.  The tables used herein are shared with those of the
  * compress() routine.  See the definitions above.
  */
-static int
-zread(void *cookie, char *rbp, int num)
+static ssize_t
+zread(void *cookie, char *rbp, size_t num)
 {
 	u_int count, i;
 	struct s_zstate *zs;
File src.orig/include is a regular file while file src.freebsd/include is a directory
--- src.orig/m4/parser.y
+++ src.freebsd/m4/parser.y
@@ -20,6 +20,7 @@
 
 #include <math.h>
 #include <stdint.h>
+#include <stdlib.h>
 #define YYSTYPE	int32_t
 extern int32_t end_result;
 extern int yylex(void);
--- src.orig/miscutils/col/col.c
+++ src.freebsd/miscutils/col/col.c
@@ -52,6 +52,7 @@
 #include <capsicum_helpers.h>
 #include <err.h>
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
--- src.orig/miscutils/hexdump/conv.c
+++ src.freebsd/miscutils/hexdump/conv.c
@@ -104,7 +104,7 @@
 	if (odmode && MB_CUR_MAX > 1) {
 		oclen = 0;
 retry:
-		clen = mbrtowc(&wc, p, bufsize, &pr->mbstate);
+		clen = mbrtowc(&wc, (const char *)p, bufsize, &pr->mbstate);
 		if (clen == 0)
 			clen = 1;
 		else if (clen == (size_t)-1 || (clen == (size_t)-2 &&
--- src.orig/miscutils/hexdump/display.c
+++ src.freebsd/miscutils/hexdump/display.c
@@ -39,9 +39,9 @@
 
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/conf.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 
 #include <capsicum_helpers.h>
 #include <ctype.h>
@@ -107,7 +107,7 @@
 		for (pr = endfu->nextpr; pr; pr = pr->nextpr)
 			switch(pr->flags) {
 			case F_ADDRESS:
-				(void)printf(pr->fmt, (quad_t)eaddress);
+				(void)printf(pr->fmt, (long long)eaddress);
 				break;
 			case F_TEXT:
 				(void)printf("%s", pr->fmt);
@@ -131,7 +131,7 @@
 
 	switch(pr->flags) {
 	case F_ADDRESS:
-		(void)printf(pr->fmt, (quad_t)address);
+		(void)printf(pr->fmt, (long long)address);
 		break;
 	case F_BPAD:
 		(void)printf(pr->fmt, "");
@@ -164,15 +164,15 @@
 	case F_INT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (quad_t)(signed char)*bp);
+			(void)printf(pr->fmt, (long long)(signed char)*bp);
 			break;
 		case 2:
 			bcopy(bp, &s2, sizeof(s2));
-			(void)printf(pr->fmt, (quad_t)s2);
+			(void)printf(pr->fmt, (long long)s2);
 			break;
 		case 4:
 			bcopy(bp, &s4, sizeof(s4));
-			(void)printf(pr->fmt, (quad_t)s4);
+			(void)printf(pr->fmt, (long long)s4);
 			break;
 		case 8:
 			bcopy(bp, &s8, sizeof(s8));
@@ -195,15 +195,15 @@
 	case F_UINT:
 		switch(pr->bcnt) {
 		case 1:
-			(void)printf(pr->fmt, (u_quad_t)*bp);
+			(void)printf(pr->fmt, (unsigned long long)*bp);
 			break;
 		case 2:
 			bcopy(bp, &u2, sizeof(u2));
-			(void)printf(pr->fmt, (u_quad_t)u2);
+			(void)printf(pr->fmt, (unsigned long long)u2);
 			break;
 		case 4:
 			bcopy(bp, &u4, sizeof(u4));
-			(void)printf(pr->fmt, (u_quad_t)u4);
+			(void)printf(pr->fmt, (unsigned long long)u4);
 			break;
 		case 8:
 			bcopy(bp, &u8, sizeof(u8));
@@ -389,7 +389,6 @@
 void
 doskip(const char *fname, int statok)
 {
-	int type;
 	struct stat sb;
 
 	if (statok) {
@@ -406,16 +405,8 @@
 		return;
 	}
 	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
-		if (ioctl(fileno(stdin), FIODTYPE, &type))
-			err(1, "%s", fname);
-		/*
-		 * Most tape drives don't support seeking,
-		 * yet fseek() would succeed.
-		 */
-		if (type & D_TAPE) {
-			noseek();
-			return;
-		}
+		noseek();
+		return;
 	}
 	if (fseeko(stdin, skip, SEEK_SET)) {
 		noseek();
--- src.orig/miscutils/hexdump/parse.c
+++ src.freebsd/miscutils/hexdump/parse.c
@@ -52,7 +52,7 @@
 void
 addfile(const char *name)
 {
-	unsigned char *p;
+	char *p;
 	FILE *fp;
 	int ch;
 	char buf[2048 + 1];
@@ -77,7 +77,7 @@
 void
 add(const char *fmt)
 {
-	unsigned const char *p, *savep;
+	const char *p, *savep;
 	static FS **nextfs;
 	FS *tfs;
 	FU *tfu, **nextfu;
@@ -153,7 +153,7 @@
 {
 	FU *fu;
 	int bcnt, cursize;
-	unsigned char *fmt;
+	char *fmt;
 	int prec;
 
 	/* figure out the data block size needed for each format unit */
@@ -210,8 +210,8 @@
 	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	PR *pr, **nextpr;
 	FU *fu;
-	unsigned char *p1, *p2, *fmtp;
-	char savech, cs[3];
+	char *p1, *p2, *fmtp;
+	char savech, cs[4];
 	int nconv, prec;
 
 	prec = 0;
@@ -290,9 +290,10 @@
 				goto isint;
 			case 'o': case 'u': case 'x': case 'X':
 				pr->flags = F_UINT;
-isint:				cs[2] = '\0';
-				cs[1] = cs[0];
-				cs[0] = 'q';
+isint:				cs[3] = '\0';
+				cs[2] = cs[0];
+				cs[1] = 'l';
+				cs[0] = 'l';
 				switch(fu->bcnt) {
 				case 0: case 4:
 					pr->bcnt = 4;
@@ -334,6 +335,7 @@
 				switch(sokay) {
 				case NOTOKAY:
 					badsfmt();
+					return;
 				case USEBCNT:
 					pr->bcnt = fu->bcnt;
 					break;
@@ -354,9 +356,10 @@
 					++p2;
 					switch(p1[2]) {
 					case 'd': case 'o': case'x':
-						cs[0] = 'q';
-						cs[1] = p1[2];
-						cs[2] = '\0';
+						cs[0] = 'l';
+						cs[1] = 'l';
+						cs[2] = p1[2];
+						cs[3] = '\0';
 						break;
 					default:
 						p1[3] = '\0';
--- src.orig/miscutils/kill/kill.c
+++ src.freebsd/miscutils/kill/kill.c
@@ -62,7 +62,6 @@
 
 static void nosig(const char *);
 static void printsignals(FILE *);
-static int signame_to_signum(const char *);
 static void usage(void);
 
 int
@@ -91,9 +90,9 @@
 				errx(2, "illegal signal number: %s", *argv);
 			if (numsig >= 128)
 				numsig -= 128;
-			if (numsig <= 0 || numsig >= sys_nsig)
+			if (numsig <= 0 || numsig >= NSIG)
 				nosig(*argv);
-			printf("%s\n", sys_signame[numsig]);
+			printf("%s\n", signum_to_signame(numsig));
 			return (0);
 		}
 		printsignals(stdout);
@@ -157,20 +156,6 @@
 	return (errors);
 }
 
-static int
-signame_to_signum(const char *sig)
-{
-	int n;
-
-	if (strncasecmp(sig, "SIG", 3) == 0)
-		sig += 3;
-	for (n = 1; n < sys_nsig; n++) {
-		if (!strcasecmp(sys_signame[n], sig))
-			return (n);
-	}
-	return (-1);
-}
-
 static void
 nosig(const char *name)
 {
@@ -189,9 +174,9 @@
 {
 	int n;
 
-	for (n = 1; n < sys_nsig; n++) {
-		(void)fprintf(fp, "%s", sys_signame[n]);
-		if (n == (sys_nsig / 2) || n == (sys_nsig - 1))
+	for (n = 1; n < NSIG; n++) {
+		(void)fprintf(fp, "%s", signum_to_signame(n));
+		if (n == (NSIG / 2) || n == (NSIG - 1))
 			(void)fprintf(fp, "\n");
 		else
 			(void)fprintf(fp, " ");
--- src.orig/miscutils/look/look.c
+++ src.freebsd/miscutils/look/look.c
@@ -82,12 +82,12 @@
 
 static int dflag, fflag;
 
-static char	*binary_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 compare(wchar_t *, unsigned char *, unsigned char *);
-static char	*linear_search(wchar_t *, unsigned char *, unsigned char *);
-static int	 look(wchar_t *, unsigned char *, unsigned char *);
+static char	*binary_search(wchar_t *, char *, char *);
+static int	 compare(wchar_t *, char *, char *);
+static char	*linear_search(wchar_t *, char *, char *);
+static int	 look(wchar_t *, char *, char *);
 static wchar_t	*prepkey(const char *, wchar_t);
-static void	 print_from(wchar_t *, unsigned char *, unsigned char *);
+static void	 print_from(wchar_t *, char *, char *);
 
 static void usage(void);
 
@@ -105,8 +105,8 @@
 	struct stat sb;
 	int ch, fd, match;
 	wchar_t termchar;
-	unsigned char *back, *front;
-	unsigned const char *file;
+	char *back, *front;
+	const char *file;
 	wchar_t *key;
 
 	(void) setlocale(LC_CTYPE, "");
@@ -149,7 +149,7 @@
 	do {
 		if ((fd = open(file, O_RDONLY, 0)) < 0 || fstat(fd, &sb))
 			err(2, "%s", file);
-		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_T_MAX)
+		if ((uintmax_t)sb.st_size > (uintmax_t)SIZE_MAX)
 			errx(2, "%s: %s", file, strerror(EFBIG));
 		if (sb.st_size == 0) {
 			close(fd);
@@ -197,7 +197,7 @@
 }
 
 static int
-look(wchar_t *string, unsigned char *front, unsigned char *back)
+look(wchar_t *string, char *front, char *back)
 {
 
 	front = binary_search(string, front, back);
@@ -251,9 +251,9 @@
 	while (p < back && *p++ != '\n');
 
 static char *
-binary_search(wchar_t *string, unsigned char *front, unsigned char *back)
+binary_search(wchar_t *string, char *front, char *back)
 {
-	unsigned char *p;
+	char *p;
 
 	p = front + (back - front) / 2;
 	SKIP_PAST_NEWLINE(p, back);
@@ -285,7 +285,7 @@
  *	o front is before or at the first line to be printed.
  */
 static char *
-linear_search(wchar_t *string, unsigned char *front, unsigned char *back)
+linear_search(wchar_t *string, char *front, char *back)
 {
 	while (front < back) {
 		switch (compare(string, front, back)) {
@@ -305,7 +305,7 @@
  * Print as many lines as match string, starting at front.
  */
 static void
-print_from(wchar_t *string, unsigned char *front, unsigned char *back)
+print_from(wchar_t *string, char *front, char *back)
 {
 	for (; front < back && compare(string, front, back) == EQUAL; ++front) {
 		for (; front < back && *front != '\n'; ++front)
@@ -330,7 +330,7 @@
  * "back" terminated).
  */
 static int
-compare(wchar_t *s1, unsigned char *s2, unsigned char *back)
+compare(wchar_t *s1, char *s2, char *back)
 {
 	wchar_t ch1, ch2;
 	size_t len2;
--- src.orig/miscutils/rev/rev.c
+++ src.freebsd/miscutils/rev/rev.c
@@ -57,6 +57,46 @@
 
 static void usage(void);
 
+#define BUF_PIECE 1024
+
+static wchar_t *get_wln(FILE *f, size_t *len, wchar_t **sbuf, size_t *blen) {
+	wchar_t *wptr;
+	size_t wlen;
+
+	wptr = fgetws(*sbuf, *blen, f);
+	if (wptr) {
+		wlen = wcslen(wptr);
+		if (wptr[wlen - 1] == '\n' || feof(f)) {
+			*len = wlen;
+			return wptr;
+		}
+	} else {
+		return NULL;
+	}
+
+	for (;;) {
+		wchar_t *nptr;
+		*blen = wlen + BUF_PIECE;
+		*sbuf = realloc(*sbuf, *blen * sizeof(wchar_t));
+		if (*sbuf) err(1, "realloc");
+
+		nptr = fgetws(*sbuf + wlen, BUF_PIECE, f);
+		if (!nptr) {
+			if (feof(f))
+				break;
+			return NULL;
+		}
+
+		wlen += wcslen(nptr);
+		if ((*sbuf)[wlen - 1] == '\n' || feof(f)) {
+			break;
+		}
+	}
+
+	*len = wlen;
+	return *sbuf;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -65,6 +105,10 @@
 	FILE *fp;
 	size_t len;
 	int ch, rval;
+	size_t bufl = BUF_PIECE;
+	wchar_t *buf = malloc(bufl * sizeof(wchar_t));
+
+	if (!buf) err(1, "malloc");
 
 	setlocale(LC_ALL, "");
 
@@ -91,7 +135,7 @@
 			}
 			filename = *argv++;
 		}
-		while ((p = fgetwln(fp, &len)) != NULL) {
+		while ((p = get_wln(fp, &len, &buf, &bufl)) != NULL) {
 			if (p[len - 1] == '\n')
 				--len;
 			for (t = p + len - 1; t >= p; --t)
@@ -105,6 +149,7 @@
 		}
 		(void)fclose(fp);
 	} while(*argv);
+	free(buf);
 	exit(rval);
 }
 
--- src.orig/miscutils/wall/ttymsg.c
+++ src.freebsd/miscutils/wall/ttymsg.c
@@ -37,6 +37,7 @@
 static const char sccsid[] = "@(#)ttymsg.c	8.2 (Berkeley) 11/16/93";
 #endif
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <dirent.h>
@@ -68,6 +69,7 @@
 	static char errbuf[1024];
 	char *p;
 	int forked;
+	sigset_t set;
 
 	forked = 0;
 	if (iovcnt > (int)(sizeof(localiov) / sizeof(localiov[0])))
@@ -143,7 +145,8 @@
 			/* wait at most tmout seconds */
 			(void) signal(SIGALRM, SIG_DFL);
 			(void) signal(SIGTERM, SIG_DFL); /* XXX */
-			(void) sigsetmask(0);
+			sigemptyset(&set);
+			sigprocmask(SIG_SETMASK, &set, 0);
 			(void) alarm((u_int)tmout);
 			(void) fcntl(fd, F_SETFL, 0);	/* clear O_NONBLOCK */
 			continue;
--- src.orig/miscutils/wall/wall.c
+++ src.freebsd/miscutils/wall/wall.c
@@ -49,6 +49,7 @@
  */
 
 #include <sys/param.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/uio.h>
 
@@ -162,7 +163,7 @@
 					ingroup = 1;
 				else if ((grp = getgrgid(g->gid)) != NULL) {
 					for (np = grp->gr_mem; *np; np++) {
-						if (strcmp(*np, utmp->ut_user) == 0) {
+						if (strncmp(*np, utmp->ut_user, sizeof(utmp->ut_user)) == 0) {
 							ingroup = 1;
 							break;
 						}
--- src.orig/miscutils/write/write.c
+++ src.freebsd/miscutils/write/write.c
@@ -49,8 +49,6 @@
 
 #include <sys/param.h>
 #include <sys/capsicum.h>
-#include <sys/filio.h>
-#include <sys/signal.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 
@@ -58,13 +56,16 @@
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <locale.h>
 #include <paths.h>
 #include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <signal.h>
 #include <unistd.h>
+#include <time.h>
 #include <utmpx.h>
 #include <wchar.h>
 #include <wctype.h>
@@ -80,7 +81,7 @@
 int
 main(int argc, char **argv)
 {
-	unsigned long cmds[] = { TIOCGETA, TIOCGWINSZ, FIODGNAME };
+	unsigned long cmds[] = { 0 };
 	cap_rights_t rights;
 	struct passwd *pwd;
 	time_t atime;
@@ -203,7 +204,8 @@
 {
 	struct utmpx lu, *u;
 
-	strncpy(lu.ut_line, tty, sizeof lu.ut_line);
+	strncpy(lu.ut_line, tty, sizeof lu.ut_line - 1);
+	lu.ut_line[sizeof lu.ut_line - 1] = '\0';
 	while ((u = getutxline(&lu)) != NULL)
 		if (u->ut_type == USER_PROCESS &&
 		    strcmp(user, u->ut_user) == 0) {
@@ -244,7 +246,7 @@
 				continue;	/* bad term? skip */
 			if (myuid && !msgsok)
 				continue;	/* skip ttys with msgs off */
-			if (strcmp(u->ut_line, mytty) == 0) {
+			if (strncmp(u->ut_line, mytty, sizeof(u->ut_line)) == 0) {
 				user_is_me = 1;
 				continue;	/* don't write to yourself */
 			}
@@ -303,10 +305,9 @@
 	fd = openat(devfd, tty, O_WRONLY);
 	if (fd < 0)
 		err(1, "openat(%s%s)", _PATH_DEV, tty);
-	fclose(stdout);
-	stdout = fdopen(fd, "w");
-	if (stdout == NULL)
+	if (dup2(fd, STDOUT_FILENO) < 0)
 		err(1, "%s%s", _PATH_DEV, tty);
+	close(fd);
 
 	(void)signal(SIGINT, done);
 	(void)signal(SIGHUP, done);
--- src.orig/patch/backupfile.c
+++ src.freebsd/patch/backupfile.c
@@ -105,7 +105,7 @@
 	file_name_length = strlen(file);
 
 	while ((dp = readdir(dirp)) != NULL) {
-		if (dp->d_namlen <= file_name_length)
+		if (strlen(dp->d_name) <= file_name_length)
 			continue;
 
 		this_version = version_number(file, dp->d_name, file_name_length);
--- src.orig/patch/inp.c
+++ src.freebsd/patch/inp.c
@@ -35,6 +35,7 @@
 
 #include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <libgen.h>
 #include <paths.h>
 #include <spawn.h>
@@ -284,8 +285,9 @@
 plan_b(const char *filename)
 {
 	FILE	*ifp;
-	size_t	i = 0, j, len, maxlen = 1;
-	char	*lbuf = NULL, *p;
+	size_t	i = 0, j, blen = 0, maxlen = 1;
+	ssize_t len;
+	char	*p = NULL;
 	bool	found_revision = (revision == NULL);
 
 	using_plan_a = false;
@@ -294,26 +296,20 @@
 	unlink(TMPINNAME);
 	if ((tifd = open(TMPINNAME, O_EXCL | O_CREAT | O_WRONLY, 0666)) < 0)
 		pfatal("can't open file %s", TMPINNAME);
-	while ((p = fgetln(ifp, &len)) != NULL) {
+	while ((len = getline(&p, &blen, ifp)) >= 0) {
 		if (p[len - 1] == '\n')
 			p[len - 1] = '\0';
 		else {
-			/* EOF without EOL, copy and add the NUL */
-			if ((lbuf = malloc(len + 1)) == NULL)
-				fatal("out of memory\n");
-			memcpy(lbuf, p, len);
-			lbuf[len] = '\0';
-			p = lbuf;
-
+			/* EOF without EOL */
 			last_line_missing_eol = true;
 			len++;
 		}
 		if (revision != NULL && !found_revision && rev_in_string(p))
 			found_revision = true;
-		if (len > maxlen)
+		if ((size_t)len > maxlen)
 			maxlen = len;   /* find longest line */
 	}
-	free(lbuf);
+	free(p);
 	if (ferror(ifp))
 		pfatal("can't read file %s", filename);
 
--- src.orig/patch/patch.c
+++ src.freebsd/patch/patch.c
@@ -558,7 +558,11 @@
 	Argv_last = Argv;
 	if (!Argc)
 		return;
+#ifdef __GLIBC__
+	optind = 0;
+#else
 	optreset = optind = 1;
+#endif
 	while ((ch = getopt_long(Argc, Argv, options, longopts, NULL)) != -1) {
 		switch (ch) {
 		case 'b':
--- src.orig/patch/pch.c
+++ src.freebsd/patch/pch.c
@@ -1214,14 +1214,15 @@
 size_t
 pgets(bool do_indent)
 {
-	char *line;
-	size_t len;
+	char *line = NULL;
+	ssize_t len = 0;
+	size_t buflen = 0;
 	int indent = 0, skipped = 0;
 
-	line = fgetln(pfp, &len);
-	if (line != NULL) {
-		if (len + 1 > buf_size) {
-			while (len + 1 > buf_size)
+	if ((len = getline(&line, &buflen, pfp)) >= 0) {
+		char *linep = line;
+		if ((size_t)(len + 1) > buf_size) {
+			while ((size_t)(len + 1) > buf_size)
 				buf_size *= 2;
 			free(buf);
 			buf = malloc(buf_size);
@@ -1240,8 +1241,10 @@
 		}
 		memcpy(buf, line, len - skipped);
 		buf[len - skipped] = '\0';
+		line = linep;
 	}
-	return len;
+	free(line);
+	return (len > 0) ? len : 0;
 }
 
 
--- src.orig/sed/main.c
+++ src.freebsd/sed/main.c
@@ -262,7 +262,7 @@
 			state = ST_STRING;
 			goto again;
 		default:
-			__unreachable();
+			abort(); /* unreachable */
 		}
 	case ST_FILE:
 		if ((p = fgets(buf, n, f)) != NULL) {
--- src.orig/sed/process.c
+++ src.freebsd/sed/process.c
@@ -73,7 +73,7 @@
 static void		 do_tr(struct s_tr *);
 static void		 flush_appends(void);
 static void		 lputs(char *, size_t);
-static int		 regexec_e(regex_t *, const char *, int, int, size_t,
+static int		 regexec_e(regex_t *, char *, int, int, size_t,
 			     size_t);
 static void		 regsub(SPACE *, char *, char *);
 static int		 substitute(struct s_command *);
@@ -665,7 +665,7 @@
 }
 
 static int
-regexec_e(regex_t *preg, const char *string, int eflags, int nomatch,
+regexec_e(regex_t *preg, char *string, int eflags, int nomatch,
 	size_t start, size_t stop)
 {
 	int eval;
@@ -677,11 +677,23 @@
 		defpreg = preg;
 
 	/* Set anchors */
+#ifndef REG_STARTEND
+	char old = string[stop];
+	string[stop] = '\0';
+	eval = regexec(defpreg, string + start,
+	    nomatch ? 0 : maxnsub + 1, match, eflags);
+	string[stop] = old;
+	for (size_t i = 0; i <= (nomatch ? 0 : maxnsub); ++i) {
+		match[i].rm_so += start;
+		match[i].rm_eo += start;
+	}
+#else
 	match[0].rm_so = start;
 	match[0].rm_eo = stop;
 
 	eval = regexec(defpreg, string,
 	    nomatch ? 0 : maxnsub + 1, match, eflags | REG_STARTEND);
+#endif
 	switch(eval) {
 	case 0:
 		return (1);
--- src.orig/sh/arith_yacc.c
+++ src.freebsd/sh/arith_yacc.c
@@ -199,6 +199,7 @@
 		return ~primary(op, val, yylex(), noeval);
 	default:
 		yyerror("expecting primary");
+		return 0; /* unreachable */
 	}
 }
 
--- src.orig/sh/error.h
+++ src.freebsd/sh/error.h
@@ -83,12 +83,3 @@
 void warning(const char *, ...) __printflike(1, 2);
 void error(const char *, ...) __printf0like(1, 2) __dead2;
 void errorwithstatus(int, const char *, ...) __printf0like(2, 3) __dead2;
-
-
-/*
- * BSD setjmp saves the signal mask, which violates ANSI C and takes time,
- * so we use _setjmp instead.
- */
-
-#define setjmp(jmploc)	_setjmp(jmploc)
-#define longjmp(jmploc, val)	_longjmp(jmploc, val)
--- src.orig/sh/expand.c
+++ src.freebsd/sh/expand.c
@@ -645,7 +645,8 @@
 		}
 		error("%.*s: parameter %snot set", (int)(p - var - 1),
 		      var, (varflags & VSNUL) ? "null or " : "");
-
+		abort();
+		break;
 	default:
 		abort();
 	}
@@ -802,6 +803,7 @@
 		c = p - var - 1;
 		error("${%.*s%s}: Bad substitution", c, var,
 		    (c > 0 && *p != CTLENDVAR) ? "..." : "");
+		break; /* unreachable */
 
 	default:
 		abort();
@@ -1171,7 +1173,7 @@
 		if (dp->d_name[0] == '.' && ! matchdot)
 			continue;
 		if (patmatch(start, dp->d_name)) {
-			namlen = dp->d_namlen;
+			namlen = strlen(dp->d_name);
 			if (enddir + namlen + 1 > expdir_end)
 				continue;
 			memcpy(enddir, dp->d_name, namlen + 1);
--- src.orig/sh/histedit.c
+++ src.freebsd/sh/histedit.c
@@ -74,9 +74,13 @@
 static char *fc_replace(const char *, char *, char *);
 static int not_fcnumber(const char *);
 static int str_to_event(const char *, int);
-static int comparator(const void *, const void *, void *);
+#ifdef HAVE_FN_COMPLETE2
+static int comparator(const void *, const void *);
 static char **sh_matches(const char *, int, int);
 static unsigned char sh_complete(EditLine *, int);
+#else
+#define sh_complete _el_fn_complete
+#endif
 
 /*
  * Set history and editing status.  Called whenever the status may
@@ -513,16 +517,17 @@
 	return ret;
 }
 
+#ifdef HAVE_FN_COMPLETE2
+static size_t comp_curpos;
 /*
  * Comparator function for qsort(). The use of curpos here is to skip
  * characters that we already know to compare equal (common prefix).
  */
 static int
-comparator(const void *a, const void *b, void *thunk)
+comparator(const void *a, const void *b)
 {
-	size_t curpos = (intptr_t)thunk;
-	return (strcmp(*(char *const *)a + curpos,
-		*(char *const *)b + curpos));
+	return (strcmp(*(char *const *)a + comp_curpos,
+		*(char *const *)b + comp_curpos));
 }
 
 /*
@@ -592,8 +597,8 @@
 	}
 	uniq = 1;
 	if (i > 1) {
-		qsort_s(matches + 1, i, sizeof(matches[0]), comparator,
-			(void *)(intptr_t)curpos);
+		comp_curpos = curpos;
+		qsort(matches + 1, i, sizeof(matches[0]), comparator);
 		for (size_t k = 2; k <= i; k++) {
 			const char *l = matches[uniq] + curpos;
 			const char *r = matches[k] + curpos;
@@ -645,6 +650,7 @@
 		L" \t\n\"\\'`@$><=;|&{(", NULL, NULL, (size_t)100,
 		NULL, &((int) {0}), NULL, NULL, FN_QUOTE_MATCH);
 }
+#endif
 
 #else
 #include "error.h"
--- src.orig/sh/input.c
+++ src.freebsd/sh/input.c
@@ -59,7 +59,9 @@
 #include "error.h"
 #include "alias.h"
 #include "parser.h"
+#ifndef NO_HISTORY
 #include "myhistedit.h"
+#endif
 #include "trap.h"
 
 #define EOF_NLEFT -99		/* value of parsenleft when EOF pushed back */
--- src.orig/sh/jobs.h
+++ src.freebsd/sh/jobs.h
@@ -55,7 +55,7 @@
 void showjobs(int, int);
 struct job *makejob(union node *, int);
 pid_t forkshell(struct job *, union node *, int);
-pid_t vforkexecshell(struct job *, char **, char **, const char *, int, int []);
+pid_t vforkexecshell(struct job *, char **, char **, const char *, int, int [2]);
 int waitforjob(struct job *, int *);
 int stoppedjobs(void);
 int backgndpidset(void);
--- src.orig/sh/main.c
+++ src.freebsd/sh/main.c
@@ -139,19 +139,16 @@
 	INTON;
 	if (iflag)
 		chkmail(1);
-	if (argv[0] && argv[0][0] == '-') {
+	if (lflag) {
 		state = 1;
 		read_profile("/etc/profile");
 state1:
 		state = 2;
-		if (privileged == 0)
-			read_profile("${HOME-}/.profile");
-		else
-			read_profile("/etc/suid_profile");
+		read_profile("${HOME-}/.profile");
 	}
 state2:
 	state = 3;
-	if (!privileged && iflag) {
+	if (iflag) {
 		if ((shinit = lookupvar("ENV")) != NULL && *shinit != '\0') {
 			state = 3;
 			read_profile(shinit);
@@ -341,4 +338,5 @@
 		exitshell(number(argv[1]));
 	else
 		exitshell_savedstatus();
+	return 1; /* unreachable */
 }
--- src.orig/sh/memalloc.h
+++ src.freebsd/sh/memalloc.h
@@ -37,6 +37,9 @@
 
 #include <string.h>
 
+#define ALIGNBYTES (sizeof(void *) - 1)
+#define ALIGN(v) (((uintptr_t)(v) + ALIGNBYTES) & ~ALIGNBYTES)
+
 struct stackmark {
 	struct stack_block *stackp;
 	char *stacknxt;
--- src.orig/sh/miscbltin.c
+++ src.freebsd/sh/miscbltin.c
@@ -567,7 +567,8 @@
 				error("bad number");
 			uval *= l->factor;
 			val = (rlim_t)uval;
-			if (val < 0 || (uintmax_t)val != uval ||
+			/* posix says rlim_t is unsigned */
+			if (uval > ((rlim_t)~(rlim_t)0) ||
 			    val == RLIM_INFINITY)
 				error("bad number");
 		}
--- src.orig/sh/mkbuiltins
+++ src.freebsd/sh/mkbuiltins
@@ -34,13 +34,14 @@
 #	@(#)mkbuiltins	8.2 (Berkeley) 5/4/95
 # $FreeBSD$
 
-temp=`mktemp -t ka`
+temp=`mktemp`
 srcdir=$1
+dstdir=$2
 havejobs=0
 if grep '^#define[	 ]*JOBS[	 ]*1' $srcdir/shell.h > /dev/null
 then	havejobs=1
 fi
-exec > builtins.c
+exec > "${dstdir}/builtins.c"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
@@ -71,7 +72,7 @@
 	}}' $temp
 echo '};'
 
-exec > builtins.h
+exec > "${dstdir}/builtins.h"
 cat <<\!
 /*
  * This file was generated by the mkbuiltins program.
--- src.orig/sh/mknodes.c
+++ src.freebsd/sh/mknodes.c
@@ -97,7 +97,7 @@
 
 static void parsenode(void);
 static void parsefield(void);
-static void output(char *);
+static void output(char *, char *, char *);
 static void outsizes(FILE *);
 static void outfunc(FILE *, int);
 static void indent(int, FILE *);
@@ -113,7 +113,7 @@
 {
 	FILE *infp;
 
-	if (argc != 3)
+	if (argc != 5)
 		error("usage: mknodes file");
 	if ((infp = fopen(argv[1], "r")) == NULL)
 		error("Can't open %s: %s", argv[1], strerror(errno));
@@ -124,7 +124,7 @@
 			parsenode();
 	}
 	fclose(infp);
-	output(argv[2]);
+	output(argv[2], argv[3], argv[4]);
 	exit(0);
 }
 
@@ -214,7 +214,7 @@
 \n";
 
 static void
-output(char *file)
+output(char *file, char *nodesh, char *nodesc)
 {
 	FILE *hfile;
 	FILE *cfile;
@@ -226,9 +226,9 @@
 
 	if ((patfile = fopen(file, "r")) == NULL)
 		error("Can't open %s: %s", file, strerror(errno));
-	if ((hfile = fopen("nodes.h", "w")) == NULL)
+	if ((hfile = fopen(nodesh, "w")) == NULL)
 		error("Can't create nodes.h: %s", strerror(errno));
-	if ((cfile = fopen("nodes.c", "w")) == NULL)
+	if ((cfile = fopen(nodesc, "w")) == NULL)
 		error("Can't create nodes.c");
 	fputs(writer, hfile);
 	for (i = 0 ; i < ntypes ; i++)
--- src.orig/sh/mksyntax.c
+++ src.freebsd/sh/mksyntax.c
@@ -114,18 +114,23 @@
 static void output_type_macros(void);
 
 int
-main(int argc __unused, char **argv __unused)
+main(int argc, char **argv)
 {
 	int i;
 	char buf[80];
 	int pos;
 
+	if (argc <= 2) {
+		fprintf(stderr, "not enough arguments\n");
+		return 1;
+	}
+
 	/* Create output files */
-	if ((cfile = fopen("syntax.c", "w")) == NULL) {
+	if ((cfile = fopen(argv[2], "w")) == NULL) {
 		perror("syntax.c");
 		exit(2);
 	}
-	if ((hfile = fopen("syntax.h", "w")) == NULL) {
+	if ((hfile = fopen(argv[1], "w")) == NULL) {
 		perror("syntax.h");
 		exit(2);
 	}
--- src.orig/sh/mktokens
+++ src.freebsd/sh/mktokens
@@ -38,7 +38,8 @@
 # token marks the end of a list.  The third column is the name to print in
 # error messages.
 
-temp=`mktemp -t ka`
+temp=`mktemp`
+dstdir=$1
 cat > $temp <<\!
 TEOF	1	end of file
 TNL	0	newline
@@ -70,7 +71,7 @@
 TNOT	0	"!"
 !
 nl=`wc -l $temp`
-exec > token.h
+exec > "${dstdir}/token.h"
 awk '{print "#define " $1 " " NR-1}' $temp
 echo '
 /* Array indicating which tokens mark the end of a list */
--- src.orig/sh/myhistedit.h
+++ src.freebsd/sh/myhistedit.h
@@ -38,7 +38,21 @@
 extern EditLine *el;
 extern int displayhist;
 
-#include <filecomplete.h>
+#ifdef HAVE_FN_COMPLETE2
+#define FN_QUOTE_MATCH 1U
+/* while this is not a part of the public API in libedit, it is a part of
+ * its public ABI (in recent versions, older ones did not have it, which
+ * is why this is guarded here)
+ *
+ * i hope libedit will at very least play nice and not break it, as that
+ * could get ugly
+ */
+int fn_complete2(EditLine *,
+    char *(*)(const char *, int),
+    char **(*)(const char *, int, int),
+    const wchar_t *, const wchar_t *, const char *(*)(const char *), size_t,
+    int *, int *, int *, int *, unsigned int);
+#endif
 
 void histedit(void);
 void sethistsize(const char *);
--- src.orig/sh/options.c
+++ src.freebsd/sh/options.c
@@ -91,11 +91,11 @@
 	char *scriptname;
 
 	argptr = argv;
+	lflag = argptr[0] && argptr[0][0] == '-';
 	if (argc > 0)
 		argptr++;
 	for (i = 0; i < NOPTS; i++)
 		optval[i] = 2;
-	privileged = (getuid() != geteuid() || getgid() != getegid());
 	options(1);
 	if (*argptr == NULL && minusc == NULL)
 		sflag = 1;
@@ -198,6 +198,8 @@
 				if (q == NULL || minusc != NULL)
 					error("Bad -c option");
 				minusc = q;
+			} else if (c == 'l' && cmdline) {
+				lflag |= 1;
 			} else if (c == 'o') {
 				minus_o(*argptr, val);
 				if (*argptr)
@@ -284,12 +286,6 @@
 static void
 setoptionbyindex(int idx, int val)
 {
-	if (&optval[idx] == &privileged && !val && privileged) {
-		if (setgid(getgid()) == -1)
-			error("setgid");
-		if (setuid(getuid()) == -1)
-			error("setuid");
-	}
 	optval[idx] = val;
 	if (val) {
 		/* #%$ hack for ksh semantics */
--- src.orig/sh/options.h
+++ src.freebsd/sh/options.h
@@ -62,21 +62,22 @@
 #define	aflag optval[12]
 #define	bflag optval[13]
 #define	uflag optval[14]
-#define	privileged optval[15]
-#define	Tflag optval[16]
-#define	Pflag optval[17]
-#define	hflag optval[18]
-#define	nologflag optval[19]
-#define	pipefailflag optval[20]
+#define	Tflag optval[15]
+#define	Pflag optval[16]
+#define	hflag optval[17]
+#define	nologflag optval[18]
+#define	pipefailflag optval[19]
 
-#define NSHORTOPTS	19
-#define NOPTS		21
+#define NSHORTOPTS	18
+#define NOPTS		20
 
+extern char lflag;
 extern char optval[NOPTS];
 extern const char optletter[NSHORTOPTS];
 #ifdef DEFINE_OPTIONS
+char lflag;
 char optval[NOPTS];
-const char optletter[NSHORTOPTS] = "efIimnsxvVECabupTPh";
+const char optletter[NSHORTOPTS] = "efIimnsxvVECabuTPh";
 static const unsigned char optname[] =
 	"\007errexit"
 	"\006noglob"
@@ -93,7 +94,6 @@
 	"\011allexport"
 	"\006notify"
 	"\007nounset"
-	"\012privileged"
 	"\012trapsasync"
 	"\010physical"
 	"\010trackall"
--- src.orig/sh/output.c
+++ src.freebsd/sh/output.c
@@ -71,7 +71,7 @@
 #define MEM_OUT -2		/* output to dynamically allocated memory */
 #define OUTPUT_ERR 01		/* error occurred on output */
 
-static int doformat_wr(void *, const char *, int);
+static ssize_t doformat_wr(void *, const char *, size_t);
 
 struct output output = {NULL, NULL, NULL, OUTBUFSIZ, 1, 0};
 struct output errout = {NULL, NULL, NULL, 256, 2, 0};
@@ -318,8 +318,8 @@
 	INTON;
 }
 
-static int
-doformat_wr(void *cookie, const char *buf, int len)
+static ssize_t
+doformat_wr(void *cookie, const char *buf, size_t len)
 {
 	struct output *o;
 
@@ -329,12 +329,19 @@
 	return (len);
 }
 
+static cookie_io_functions_t func = {
+    .write = doformat_wr,
+    .read = NULL,
+    .seek = NULL,
+    .close = NULL
+};
+
 void
 doformat(struct output *dest, const char *f, va_list ap)
 {
 	FILE *fp;
 
-	if ((fp = fwopen(dest, doformat_wr)) != NULL) {
+	if ((fp = fopencookie(dest, "a", func)) != NULL) {
 		vfprintf(fp, f, ap);
 		fclose(fp);
 	}
@@ -343,7 +350,7 @@
 FILE *
 out1fp(void)
 {
-	return fwopen(out1, doformat_wr);
+	return fopencookie(out1, "a", func);
 }
 
 /*
--- src.orig/sh/parser.c
+++ src.freebsd/sh/parser.c
@@ -592,6 +592,9 @@
 	case TRP:
 		if (!redir)
 			synexpect(-1);
+		tokpushback++;
+		n1 = simplecmd(rpp, redir);
+		return n1;
 	case TWORD:
 		tokpushback++;
 		n1 = simplecmd(rpp, redir);
@@ -1092,7 +1095,6 @@
 	struct jmploc jmploc;
 	struct jmploc *const savehandler = handler;
 	size_t savelen;
-	int saveprompt;
 	const int bq_startlinno = plinno;
 	char *volatile ostr = NULL;
 	struct parsefile *const savetopfile = getcurrentfile();
@@ -1180,18 +1182,16 @@
 	(*nlpp)->next = NULL;
 
 	if (oldstyle) {
-		saveprompt = doprompt;
+		int saveprompt = doprompt;
 		doprompt = 0;
-	}
-
-	n = list(0);
-
-	if (oldstyle) {
+		n = list(0);
 		if (peektoken() != TEOF)
 			synexpect(-1);
 		doprompt = saveprompt;
-	} else
+	} else {
+		n = list(0);
 		consumetoken(TRP);
+	}
 
 	(*nlpp)->n = n;
         if (oldstyle) {
@@ -1240,12 +1240,13 @@
 readcstyleesc(char *out)
 {
 	int c, vc, i, n;
-	unsigned int v;
+	unsigned int v = 0;
 
 	c = pgetc();
 	switch (c) {
 	case '\0':
 		synerror("Unterminated quoted string");
+		return NULL; /* unreachable */
 	case '\n':
 		plinno++;
 		if (doprompt)
@@ -1989,7 +1990,7 @@
 static void
 getusername(char *name, size_t namelen)
 {
-	static char cached_name[MAXLOGNAME];
+	static char cached_name[LOGIN_NAME_MAX];
 	struct passwd *pw;
 	uid_t euid;
 
--- src.orig/sh/redir.c
+++ src.freebsd/sh/redir.c
@@ -175,7 +175,7 @@
 	struct stat sb;
 	int fd = redir->nfile.fd;
 	const char *fname;
-	int f;
+	int f = 0;
 	int e;
 
 	memory[fd] = 0;
--- src.orig/sh/sh.1
+++ src.freebsd/sh/sh.1
@@ -278,22 +278,6 @@
 to
 .Fl P
 (physical directory layout).
-.It Fl p Li privileged
-Turn on privileged mode.
-This mode is enabled on startup
-if either the effective user or group ID is not equal to the
-real user or group ID.
-Turning this mode off sets the
-effective user and group IDs to the real user and group IDs.
-When this mode is enabled for interactive shells, the file
-.Pa /etc/suid_profile
-is sourced instead of
-.Pa ~/.profile
-after
-.Pa /etc/profile
-is sourced, and the contents of the
-.Ev ENV
-variable are ignored.
 .It Fl s Li stdin
 Read commands from standard input (set automatically
 if no file arguments are present).
--- src.orig/sh/trap.c
+++ src.freebsd/sh/trap.c
@@ -58,8 +58,9 @@
 #include "trap.h"
 #include "mystring.h"
 #include "builtins.h"
+#ifndef NO_HISTORY
 #include "myhistedit.h"
-
+#endif
 
 /*
  * Sigmode records the current value of the signal handlers for the various
@@ -111,10 +112,11 @@
 
 		if (strncasecmp(sig, "SIG", 3) == 0)
 			sig += 3;
-		for (n = 1; n < sys_nsig; n++)
-			if (sys_signame[n] &&
-			    strcasecmp(sys_signame[n], sig) == 0)
+		for (n = 1; n < NSIG; n++) {
+			const char *sign = signum_to_signame(n);
+			if (sign && strcasecmp(sign, sig) == 0)
 				return (n);
+		}
 	}
 	return (-1);
 }
@@ -129,16 +131,17 @@
 	int n, outlen;
 
 	outlen = 0;
-	for (n = 1; n < sys_nsig; n++) {
-		if (sys_signame[n]) {
-			out1fmt("%s", sys_signame[n]);
-			outlen += strlen(sys_signame[n]);
+	for (n = 1; n < NSIG; n++) {
+		const char *sign = signum_to_signame(n);
+		if (sign) {
+			out1fmt("%s", sign);
+			outlen += strlen(sign);
 		} else {
 			out1fmt("%d", n);
 			outlen += 3;	/* good enough */
 		}
 		++outlen;
-		if (outlen > 71 || n == sys_nsig - 1) {
+		if (outlen > 71 || n == NSIG - 1) {
 			out1str("\n");
 			outlen = 0;
 		} else {
@@ -169,14 +172,15 @@
 	argv = argptr;
 
 	if (*argv == NULL) {
-		for (signo = 0 ; signo < sys_nsig ; signo++) {
+		for (signo = 0 ; signo < NSIG ; signo++) {
 			if (signo < NSIG && trap[signo] != NULL) {
+				const char *sign = signum_to_signame(signo);
 				out1str("trap -- ");
 				out1qstr(trap[signo]);
 				if (signo == 0) {
 					out1str(" EXIT\n");
-				} else if (sys_signame[signo]) {
-					out1fmt(" %s\n", sys_signame[signo]);
+				} else if (sign) {
+					out1fmt(" %s\n", sign);
 				} else {
 					out1fmt(" %d\n", signo);
 				}
